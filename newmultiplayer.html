<!DOCTYPE html>
<html lang="en" dir="ltr">
    <head></head>
    <div class="gamepage-wrapper">
        <!-- Basic header. Should hold simple branding and navigation. -->
        <header class="gamepage-header">
            <!-- Image provided by Eucalyp Studio in Artificial Intelligence from https://www.iconfinder.com/iconsets/artificial-intelligence-6 -->
            <!-- <img id="site-logo" src="assets/iconfinder_ArtificialIntelligence29_2890576_blackwhite.png"> -->
            <ul class="nav-content">
                <!-- <li class="nav-list-item"><a class="nav-link-text" href="">Home</a></li> -->
                <!-- <li class="nav-list-item"><a class="nav-link-text" href="https://www.linkedin.com/in/cole-ditzler-41b160133/" target="_blank">About</a></li> --></ul>
        </header>
        <!-- Container for page content. Contains and aligns instructions, game, and ads. -->
        <div class="game-content-container">
            <!-- Left side banner. Should contain instuctions for the game. -->
            <aside class="gamepage-left-aside"></aside>
            <!-- Game container. Holds the game for this page scaled to fit.  -->
            <div class="game-container">
                <div id="dog-image-container">
                    <canvas
                        id="canvas"
                        width="1280"
                        height="720"
                        class="canvas"
                    ></canvas>
                    <canvas
                        hidden
                        id="map"
                        width="1280"
                        height="1280"
                        class="canvas"
                    ></canvas>
                    <canvas
                        hidden
                        id="gCanvas"
                        width="1280"
                        height="1280"
                        class="canvas"
                    ></canvas>
                    <script src="https://ditzbitz.com/spiral.js"></script>
                    <script src="https://ditzbitz.com/outmap.js"></script>
                    <script src="https://ditzbitz.com/outmap2.js"></script>
                    <script src="https://ditzbitz.com/outmap3.js"></script>
                    <script src="https://ditzbitz.com/outmap4.js"></script>
                    <script src="https://ditzbitz.com/outmap5.js"></script>
                    <script src="https://ditzbitz.com/outmap6.js"></script>
                    <script src="https://ditzbitz.com/outmap7.js"></script>
                    <script src="https://ditzbitz.com/outmap8.js"></script>
                    <script src="https://ditzbitz.com/outmap9.js"></script>
                    <script src="https://ditzbitz.com/outmap10.js"></script>
                    <script src="https://ditzbitz.com/outmap11.js"></script>
                    <script src="https://ditzbitz.com/outmap12.js"></script>
                    <script src="https://ditzbitz.com/outmap13.js"></script>
                    <script src="https://ditzbitz.com/outmap14.js"></script>
                    <script src="https://ditzbitz.com/outmap15.js"></script>
                    <script src="https://ditzbitz.com/colditzleriancampaign1.js"></script>
                    <script src="https://ditzbitz.com/colditzleriancampaign2.js"></script>
                    <script src="https://ditzbitz.com/colditzleriancampaign3.js"></script>
                    <script src="https://ditzbitz.com/colditzleriancampaign4.js"></script>
                    <script src="https://ditzbitz.com/colditzleriancampaign5.js"></script>
                    <script src="https://ditzbitz.com/humancampaign1.js"></script>
                    <script src="https://ditzbitz.com/humancampaign2.js"></script>
                    <script src="https://ditzbitz.com/humancampaign3.js"></script>
                    <script src="https://ditzbitz.com/wallclipastar.js"></script>
                    <script src="https://ditzbitz.com/astar.js"></script>
                    <script src="https://ditzbitz.com/slimyastar.js"></script>
                    <script src="https://ditzbitz.com/slimemakingastar.js"></script>
                    <script>
let controlking = 0
let totalbytes = 0
let frames = 0
let worldnow = Date.now()
let worldscale = 128
let campaignController = {}
let pflag = 0
let qflag = 0
let globalHealthDraw = false
let controllerSupport = 0
let globalframe = 0
let AImode = 0
let takenMap = 0
window.addEventListener('DOMContentLoaded', (event) => {


    let idcount = 1

    let ws
    let HOST = location.origin.replace(/^http/, 'ws')
    ws = new WebSocket(HOST);

    let globalAItimeFlag = Date.now()
    undefined = -8
    // //////////console.log(31610054640417607788145206291543662493274686990)
    const gargantuanNumber = 31610054640417607788145206291543662493274686990
    const ten46 = 1000000000000000000000000000000000000000000000
    // let hotsum = 0
    let unitcap = 50
    let video_recorder
    let recording = 0
    // function CanvasCaptureToWEBM(canvas, bitrate) {
    //     // the video_recorder is set to  '= new CanvasCaptureToWEBM(canvas, 4500000);' in the setup, 
    //     // it uses the same canvas as the rest of the file.
    //     // to start a recording call .record() on video_recorder
    //     /*
    //     for example, 
    //     if(keysPressed['-'] && recording == 0){
    //         recording = 1
    //         video_recorder.record()
    //     }
    //     if(keysPressed['='] && recording == 1){
    //         recording = 0
    //         video_recorder.stop()
    //         video_recorder.download('File Name As A String.webm')
    //     }
    //     */
    //     this.record = Record
    //     this.stop = Stop
    //     this.download = saveToDownloads
    //     let blobCaptures = []
    //     let outputFormat = {}
    //     let recorder = {}
    //     let canvasInput = canvas.captureStream()
    //     if (typeof canvasInput == undefined || !canvasInput) {
    //         return
    //     }
    //     let video = document.createElement('video')
    //     video.style.display = 'none'

    //     function Record() {
    //         let formats = [
    //             "video/webm\;codecs=h264",
    //             "video/webm\;codecs=vp8",
    //             'video/vp8',
    //             "video/webm",
    //             'video/webm,codecs=vp9',
    //             "video/webm\;codecs=daala",
    //             "video/mpeg"
    //         ];

    //         for (let t = 0; t < formats.length; t++) {
    //             if (MediaRecorder.isTypeSupported(formats[t])) {
    //                 outputFormat = formats[t]
    //                 break
    //             }
    //         }
    //         if (typeof outputFormat != "string") {
    //             return
    //         } else {
    //             let videoSettings = {
    //                 mimeType: outputFormat,
    //                 videoBitsPerSecond: bitrate || 2000000 // 2Mbps
    //             };
    //             blobCaptures = []
    //             try {
    //                 recorder = new MediaRecorder(canvasInput, videoSettings)
    //             } catch (error) {
    //                 return;
    //             }
    //             recorder.onstop = handleStop
    //             recorder.ondataavailable = handleAvailableData
    //             recorder.start(100)
    //         }
    //     }
    //     function handleAvailableData(event) {
    //         if (event.data && event.data.size > 0) {
    //             blobCaptures.push(event.data)
    //         }
    //     }
    //     function handleStop() {
    //         let superBuffer = new Blob(blobCaptures, { type: outputFormat })
    //         video.src = window.URL.createObjectURL(superBuffer)
    //     }
    //     function Stop() {
    //         recorder.stop()
    //         video.controls = true
    //     }
    //     function saveToDownloads(input) { // specifying a file name for the output
    //         let name = input || 'video_out.webm'
    //         let blob = new Blob(blobCaptures, { type: outputFormat })
    //         let url = window.URL.createObjectURL(blob)
    //         let storageElement = document.createElement('a')
    //         storageElement.style.display = 'none'
    //         storageElement.href = url
    //         storageElement.download = name
    //         document.body.appendChild(storageElement)
    //         storageElement.click()
    //         setTimeout(() => {
    //             document.body.removeChild(storageElement)
    //             window.URL.revokeObjectURL(url)
    //         }, 100)
    //     }
    // }

    let dynamic2 = 0
    let dynamic1 = 0
    // const engageconstant = .4
    const engageconstant = .04

    let playstart = 0
    let debreak = 1
    let manual = 0
    let start = 0 // whether it's okay to draw the game into the canvas element.
    function empty() {

    }
    let dataflop = 0 // enforces only 1 
    // preferential towards buildings
    // elite units

    // startup frames
    const startupart = new Image()
    startupart.src = 'https://ditzbitz.com/startupart.png'

    // background
    const snow = new Image()
    snow.src = 'https://ditzbitz.com/smoothsnow4.png'
    const rawdirt = new Image()
    rawdirt.src = 'https://ditzbitz.com/rawdirt4.png'
    const fogblock = new Image()
    fogblock.src = 'https://ditzbitz.com/fogy.png'
    const fogblockx = new Image()
    fogblockx.src = 'https://ditzbitz.com/fogx.png'
    // barriers
    const nowalk = new Image()
    nowalk.src = 'https://ditzbitz.com/nowalk.png'
    const nowalksheet = new Image()
    nowalksheet.src = 'https://ditzbitz.com/nowalksheet.png'


    //schlorkupine sprites
    const schlorkupineimg = new Image()
    schlorkupineimg.src = 'https://ditzbitz.com/schlorkupine.png'
    const schlorkupineinvimg = new Image()
    schlorkupineinvimg.src = 'https://ditzbitz.com/schlorkupine2inv.png'

    //targetroid sprited

    const targetroidimg = new Image()
    targetroidimg.src = 'https://ditzbitz.com/danger.png'

    const targetroidwalksheet = new Image()
    targetroidwalksheet.src = 'https://ditzbitz.com/dangerwalksheet.png'
    const targetroidwalksheetinv = new Image()
    targetroidwalksheetinv.src = 'https://ditzbitz.com/dangerwalksheetinv.png'

    const targetroidimginv = new Image()
    targetroidimginv.src = 'https://ditzbitz.com/dangerinv.png'
    const targetroidface = new Image()
    targetroidface.src = 'https://ditzbitz.com/striderface.png'
    const targetroidfaceinv = new Image()
    targetroidfaceinv.src = 'https://ditzbitz.com/striderfaceinv.png'

    const schlorkupineface = new Image()
    schlorkupineface.src = 'https://ditzbitz.com/schlorkupineface.png'
    const schlorkupinefaceinv = new Image()
    schlorkupinefaceinv.src = 'https://ditzbitz.com/schlorkupinefaceinv.png'

    const closedgate = new Image()
    closedgate.src = 'https://ditzbitz.com/closedgate.png'

    const opengate = new Image()
    opengate.src = 'https://ditzbitz.com/opengate.png'

    const sounds = []
    let soundspamdrop = .1
    let selectionspam = .1
    let pathspamdrop = .1
    let deathspam = 1


    const postwind = new Audio()
    postwind.src = "https://ditzbitz.com/postwind.mp3"
    // sounds.push(postwind)
    postwind.volume = .4



    const campaignsounds = []


    const sana1 = new Audio()
    sana1.src = "https://ditzbitz.com/sana1.mp3"
    campaignsounds.push(sana1)
    const sana2 = new Audio()
    sana2.src = "https://ditzbitz.com/sana2.mp3"
    campaignsounds.push(sana2)
    const sana3 = new Audio()
    sana3.src = "https://ditzbitz.com/sana3.mp3"
    campaignsounds.push(sana3)

    const park1 = new Audio()
    park1.src = "https://ditzbitz.com/park1.mp3"
    campaignsounds.push(park1)




    const hopeyouknow = new Audio()
    hopeyouknow.src = "https://ditzbitz.com/hopeyouknow.mp3"
    sounds.push(hopeyouknow)
    const myfuneral = new Audio()
    myfuneral.src = "https://ditzbitz.com/myfuneral.mp3"
    sounds.push(myfuneral)
    const systems = new Audio()
    systems.src = "https://ditzbitz.com/systems.mp3"
    sounds.push(systems)
    const redlight = new Audio()
    redlight.src = "https://ditzbitz.com/redlight.mp3"
    sounds.push(redlight)
    const feelcold = new Audio()
    feelcold.src = "https://ditzbitz.com/feelcold.mp3"
    sounds.push(feelcold)
    const hitsomething = new Audio()
    hitsomething.src = "https://ditzbitz.com/hitsomething.mp3"
    sounds.push(hitsomething)
    const rollout = new Audio()
    rollout.src = "https://ditzbitz.com/rollout.mp3"
    sounds.push(rollout)
    const overtime = new Audio()
    overtime.src = "https://ditzbitz.com/overtime.mp3"
    const undertime1 = new Audio()
    undertime1.src = "https://ditzbitz.com/undertime1x.mp3"
    const undertime2 = new Audio()
    undertime2.src = "https://ditzbitz.com/undertime2x.mp3"
    const undertime3 = new Audio()
    undertime3.src = "https://ditzbitz.com/undertime3x.mp3"
    const undertime4 = new Audio()
    undertime4.src = "https://ditzbitz.com/undertime4x.mp3"
    const undertime5 = new Audio()
    undertime5.src = "https://ditzbitz.com/undertime0x.mp3"
    undertime1.volume = 1
    undertime2.volume = 1
    undertime3.volume = 1
    undertime4.volume = 1
    undertime5.volume = 1

    sounds.push(undertime1)
    sounds.push(undertime2)
    sounds.push(undertime3)
    sounds.push(undertime4)
    sounds.push(undertime5)
    sounds.push(overtime)
    const movin = new Audio()
    movin.src = "https://ditzbitz.com/movin.mp3"
    sounds.push(movin)

    const movin1 = new Audio()
    movin1.src = "https://ditzbitz.com/movin1.mp3"
    sounds.push(movin1)

    const movin2 = new Audio()
    movin2.src = "https://ditzbitz.com/movin2.mp3"
    sounds.push(movin2)

    const movin3 = new Audio()
    movin3.src = "https://ditzbitz.com/movin3.mp3"
    sounds.push(movin3)

    //gate audio

    const closing1 = new Audio()
    closing1.src = "https://ditzbitz.com/closing1.mp3"
    sounds.push(closing1)
    const closing2 = new Audio()
    closing2.src = "https://ditzbitz.com/closing2.mp3"
    sounds.push(closing2)
    const closing3 = new Audio()
    closing3.src = "https://ditzbitz.com/closing3.mp3"
    sounds.push(closing3)
    const opening1 = new Audio()
    opening1.src = "https://ditzbitz.com/opening1.mp3"
    sounds.push(opening1)
    const opening2 = new Audio()
    opening2.src = "https://ditzbitz.com/opening2.mp3"
    sounds.push(opening2)

    // soldier audio
    const arerats = new Audio()
    arerats.src = "https://ditzbitz.com/arerats.mp3"
    sounds.push(arerats)
    const reallytacky = new Audio()
    reallytacky.src = "https://ditzbitz.com/reallytacky.mp3"
    sounds.push(reallytacky)
    const youareabuse = new Audio()
    youareabuse.src = "https://ditzbitz.com/youareabuse.mp3"
    sounds.push(youareabuse)
    const inthejetsarm = new Audio()
    inthejetsarm.src = "https://ditzbitz.com/inthejetsarm.mp3"
    sounds.push(inthejetsarm)
    const torus = new Audio()
    torus.src = "https://ditzbitz.com/torus.mp3"
    sounds.push(torus)
    const enormoushead = new Audio()
    enormoushead.src = "https://ditzbitz.com/enormoushead.mp3"
    sounds.push(enormoushead)
    const testroom = new Audio()
    testroom.src = "https://ditzbitz.com/testroom.mp3"
    sounds.push(testroom)
    const sorcery = new Audio()
    sorcery.src = "https://ditzbitz.com/sorcery.mp3"
    sounds.push(sorcery)
    const pagetti = new Audio()
    pagetti.src = "https://ditzbitz.com/pagetti.mp3"
    sounds.push(pagetti)
    const saytome = new Audio()
    saytome.src = "https://ditzbitz.com/saytome.mp3"
    sounds.push(saytome)
    const seearoundme = new Audio()
    seearoundme.src = "https://ditzbitz.com/seearoundme.mp3"
    sounds.push(seearoundme)
    const snnazzyroom = new Audio()
    snnazzyroom.src = "https://ditzbitz.com/snnazzyroom.mp3"
    sounds.push(snnazzyroom)
    const snazzyroom = new Audio()
    snazzyroom.src = "https://ditzbitz.com/snazzyroom.mp3"
    sounds.push(snazzyroom)


    //invader audio
    const iamerror = new Audio()
    iamerror.src = "https://ditzbitz.com/iamerror.mp3"
    sounds.push(iamerror)
    const incroiable = new Audio()
    incroiable.src = "https://ditzbitz.com/incroiable.mp3"
    sounds.push(incroiable)
    const youhome = new Audio()
    youhome.src = "https://ditzbitz.com/youhome.mp3"
    sounds.push(youhome)
    const gentlemen = new Audio()
    gentlemen.src = "https://ditzbitz.com/gentlemen.mp3"
    sounds.push(gentlemen)
    const zero = new Audio()
    zero.src = "https://ditzbitz.com/zero.mp3"
    sounds.push(zero)
    const ohgeezyouvehurtme = new Audio()
    ohgeezyouvehurtme.src = "https://ditzbitz.com/ohgeezyouvehurtme.mp3"
    sounds.push(ohgeezyouvehurtme)
    const ritual = new Audio()
    ritual.src = "https://ditzbitz.com/ritual.mp3"
    sounds.push(ritual)

    //plaztilite audio
    const seeraudio = new Audio()
    seeraudio.src = "https://ditzbitz.com/seeraudio.mp3"
    sounds.push(seeraudio)
    const vizieraudio = new Audio()
    vizieraudio.src = "https://ditzbitz.com/vizieraudio2.mp3"
    sounds.push(vizieraudio)
    const mycoknightaudio = new Audio()
    mycoknightaudio.src = "https://ditzbitz.com/mycoknightaudio.mp3"
    sounds.push(mycoknightaudio)
    const buddyaudio = new Audio()
    buddyaudio.src = "https://ditzbitz.com/fruitingbuddyaudio.mp3"
    sounds.push(buddyaudio)


    //pollinator audio
    const pollinatoraudio = new Audio()
    pollinatoraudio.src = "https://ditzbitz.com/pollinatoraudioamp2.mp3"
    sounds.push(pollinatoraudio)

    //pufffellow audio
    const pufffellowaudio = new Audio()
    pufffellowaudio.src = "https://ditzbitz.com/pufffellowaudio.mp3"
    sounds.push(pufffellowaudio)

    //golophyte audio
    const golophyteaudio = new Audio()
    golophyteaudio.src = "https://ditzbitz.com/golophyteaudio.mp3"
    sounds.push(golophyteaudio)

    // podman audio
    const youworkforme = new Audio()
    youworkforme.src = "https://ditzbitz.com/youworkforme.mp3"
    sounds.push(youworkforme)
    const whatdoweneed = new Audio()
    whatdoweneed.src = "https://ditzbitz.com/whatdoweneed.mp3"
    sounds.push(whatdoweneed)
    const gushorgushnot = new Audio()
    gushorgushnot.src = "https://ditzbitz.com/gushorgushnot.mp3"
    sounds.push(gushorgushnot)
    const nahimgood = new Audio()
    nahimgood.src = "https://ditzbitz.com/nahimgood.mp3"
    sounds.push(nahimgood)
    const backwithclass = new Audio()
    backwithclass.src = "https://ditzbitz.com/backwithclass.mp3"
    sounds.push(backwithclass)
    const hotmore = new Audio()
    hotmore.src = "https://ditzbitz.com/hotmore.mp3"
    sounds.push(hotmore)
    const maybegofishing = new Audio()
    maybegofishing.src = "https://ditzbitz.com/maybegofishing.mp3"
    sounds.push(maybegofishing)
    const walkinthesunpostskirmish = new Audio()
    walkinthesunpostskirmish.src = "https://ditzbitz.com/walkinthesunpostskirmish.mp3"
    sounds.push(walkinthesunpostskirmish)
    const whosthegas = new Audio()
    whosthegas.src = "https://ditzbitz.com/whosthegas.mp3"
    sounds.push(whosthegas)
    const bombbuoy = new Audio()
    bombbuoy.src = "https://ditzbitz.com/bombbuoy.mp3"
    sounds.push(bombbuoy)
    const seeyesineed = new Audio()
    seeyesineed.src = "https://ditzbitz.com/seeyesineed.mp3"
    sounds.push(seeyesineed)
    const notinhere = new Audio()
    notinhere.src = "https://ditzbitz.com/notinhere.mp3"
    sounds.push(notinhere)
    const whatdoesthisdo = new Audio()
    whatdoesthisdo.src = "https://ditzbitz.com/whatdoesthisdo.mp3"
    sounds.push(whatdoesthisdo)
    const moveitalong = new Audio()
    moveitalong.src = "https://ditzbitz.com/moveitalong.mp3"
    sounds.push(moveitalong)

    //sniper audio
    const adjustingforwindspeed = new Audio()
    adjustingforwindspeed.src = "https://ditzbitz.com/adjustingforwindspeed.mp3"
    sounds.push(adjustingforwindspeed)
    const bossaroundhere = new Audio()
    bossaroundhere.src = "https://ditzbitz.com/bossaroundhere.mp3"
    sounds.push(bossaroundhere)
    const bossaroundhere2 = new Audio()
    bossaroundhere2.src = "https://ditzbitz.com/bossaroundhere2.mp3"
    sounds.push(bossaroundhere2)
    const doyouunderstand = new Audio()
    doyouunderstand.src = "https://ditzbitz.com/doyouunderstand.mp3"
    sounds.push(doyouunderstand)
    const goingdown = new Audio()
    goingdown.src = "https://ditzbitz.com/doyouunderstand.mp3"
    sounds.push(goingdown)
    const idontunderstand = new Audio()
    idontunderstand.src = "https://ditzbitz.com/idontunderstand.mp3"
    sounds.push(idontunderstand)
    const isnipedyouaweekago = new Audio()
    isnipedyouaweekago.src = "https://ditzbitz.com/isnipedyouaweekago.mp3"
    sounds.push(isnipedyouaweekago)
    const isnipedyouaweekago2 = new Audio()
    isnipedyouaweekago2.src = "https://ditzbitz.com/isnipedyouaweekago2.mp3"
    sounds.push(isnipedyouaweekago2)
    const ivegotanhour = new Audio()
    ivegotanhour.src = "https://ditzbitz.com/ivegotanhour.mp3"
    sounds.push(ivegotanhour)
    const ivoryeh = new Audio()
    ivoryeh.src = "https://ditzbitz.com/ivegotanhour.mp3"
    sounds.push(ivoryeh)
    const jobsthejob = new Audio()
    jobsthejob.src = "https://ditzbitz.com/jobsthejob.mp3"
    sounds.push(jobsthejob)
    const likecontrolling = new Audio()
    likecontrolling.src = "https://ditzbitz.com/likecontrolling.mp3"
    sounds.push(likecontrolling)
    const oratleastone = new Audio()
    oratleastone.src = "https://ditzbitz.com/oratleastone.mp3"
    sounds.push(oratleastone)
    const theresone = new Audio()
    theresone.src = "https://ditzbitz.com/theresone.mp3"
    sounds.push(theresone)
    const timber = new Audio()
    timber.src = "https://ditzbitz.com/timber.mp3"
    sounds.push(timber)
    const veryprecise = new Audio()
    veryprecise.src = "https://ditzbitz.com/veryprecise.mp3"
    sounds.push(veryprecise)
    const veryprecise2 = new Audio()
    veryprecise2.src = "https://ditzbitz.com/veryprecise2.mp3"
    sounds.push(veryprecise2)
    const wealthstatusandpower = new Audio()
    wealthstatusandpower.src = "https://ditzbitz.com/wealthstatusandpower.mp3"
    sounds.push(wealthstatusandpower)
    const wontbesolucky = new Audio()
    wontbesolucky.src = "https://ditzbitz.com/wontbesolucky.mp3"
    sounds.push(wontbesolucky)
    const youunderstandany = new Audio()
    youunderstandany.src = "https://ditzbitz.com/youunderstandany.mp3"
    sounds.push(youunderstandany)
    const ahgeez = new Audio()
    ahgeez.src = "https://ditzbitz.com/ahgeez.mp3"
    sounds.push(ahgeez)

    //gamergate audio
    const hovness = new Audio()
    hovness.src = "https://ditzbitz.com/hovness.mp3"
    sounds.push(hovness)
    const dontstopeating = new Audio()
    dontstopeating.src = "https://ditzbitz.com/dontstopeating.mp3"
    sounds.push(dontstopeating)
    const solutionnotobey = new Audio()
    solutionnotobey.src = "https://ditzbitz.com/solutionnotobey.mp3"
    sounds.push(solutionnotobey)
    const youhurtme = new Audio()
    youhurtme.src = "https://ditzbitz.com/youhurtme.mp3"
    sounds.push(youhurtme)
    const slurpslurp = new Audio()
    slurpslurp.src = "https://ditzbitz.com/slurpslurp.mp3"
    sounds.push(slurpslurp)
    const buyburbon = new Audio()
    buyburbon.src = "https://ditzbitz.com/buyburbon.mp3"
    sounds.push(buyburbon)
    const whatisthis = new Audio()
    whatisthis.src = "https://ditzbitz.com/whatisthis.mp3"
    sounds.push(whatisthis)
    const doyouwantsome = new Audio()
    doyouwantsome.src = "https://ditzbitz.com/doyouwantsome.mp3"
    sounds.push(doyouwantsome)
    const hoppe = new Audio()
    hoppe.src = "https://ditzbitz.com/hoppe.mp3"
    sounds.push(hoppe)
    const letemseeit = new Audio()
    letemseeit.src = "https://ditzbitz.com/letemseeit.mp3"
    sounds.push(letemseeit)
    const gooutside = new Audio()
    gooutside.src = "https://ditzbitz.com/gooutside.mp3"
    sounds.push(gooutside)
    const ggd1 = new Audio()
    ggd1.src = "https://ditzbitz.com/ggd1.mp3"
    sounds.push(ggd1)
    const ggd2 = new Audio()
    ggd2.src = "https://ditzbitz.com/ggd2.mp3"
    sounds.push(ggd2)
    const ggd3 = new Audio()
    ggd3.src = "https://ditzbitz.com/ggd3.mp3"
    sounds.push(ggd3)


    //nymph audio
    const itstheedgeofusfight = new Audio()
    itstheedgeofusfight.src = "https://ditzbitz.com/itstheedgeofusfight.mp3"
    sounds.push(itstheedgeofusfight)
    const sureilike = new Audio()
    sureilike.src = "https://ditzbitz.com/sureilike.mp3"
    sounds.push(sureilike)
    const seethemseetheme = new Audio()
    seethemseetheme.src = "https://ditzbitz.com/seethemseetheme.mp3"
    sounds.push(seethemseetheme)
    const seeasvillaneh = new Audio()
    seeasvillaneh.src = "https://ditzbitz.com/seeasvillaneh.mp3"
    sounds.push(seeasvillaneh)
    const spreadoutseemult = new Audio()
    spreadoutseemult.src = "https://ditzbitz.com/spreadoutseemult.mp3"
    sounds.push(spreadoutseemult)
    const whoarewetomolt = new Audio()
    whoarewetomolt.src = "https://ditzbitz.com/whoarewetomolt.mp3"
    sounds.push(whoarewetomolt)

    //scuttler audio
    const scuttlerdeath = new Audio()
    scuttlerdeath.src = "https://ditzbitz.com/scuttlerdeath.mp3"
    sounds.push(scuttlerdeath)
    const whoelsezagtheoystergush = new Audio()
    whoelsezagtheoystergush.src = "https://ditzbitz.com/whoelsezagtheoystergush.mp3"
    sounds.push(whoelsezagtheoystergush)
    const sureiwillstandup = new Audio()
    sureiwillstandup.src = "https://ditzbitz.com/sureiwillstandup.mp3"
    sounds.push(sureiwillstandup)
    const suresawwithvenom = new Audio()
    suresawwithvenom.src = "https://ditzbitz.com/suresawwithvenom.mp3"
    sounds.push(suresawwithvenom)
    const suresauna = new Audio()
    suresauna.src = "https://ditzbitz.com/suresauna.mp3"
    sounds.push(suresauna)
    const stallusyourworth = new Audio()
    stallusyourworth.src = "https://ditzbitz.com/stallusyourworth.mp3"
    sounds.push(stallusyourworth)
    const getinthebathsootheyourson = new Audio()
    getinthebathsootheyourson.src = "https://ditzbitz.com/getinthebathsootheyourson.mp3"
    sounds.push(getinthebathsootheyourson)
    const illness = new Audio()
    illness.src = "https://ditzbitz.com/illness.mp3"
    sounds.push(illness)
    const whatareyoufreesievingoutput = new Audio()
    whatareyoufreesievingoutput.src = "https://ditzbitz.com/whatreyoufreesievingoutput.mp3"
    sounds.push(whatareyoufreesievingoutput)
    const icannamethevillans = new Audio()
    icannamethevillans.src = "https://ditzbitz.com/icannamethevillans.mp3"
    sounds.push(icannamethevillans)
    const mylifesmine = new Audio()
    mylifesmine.src = "https://ditzbitz.com/mylifesmine.mp3"
    sounds.push(mylifesmine)
    const iknowcomeon = new Audio()
    iknowcomeon.src = "https://ditzbitz.com/iknowcomeon.mp3"
    sounds.push(iknowcomeon)
    const guessillgothen = new Audio()
    guessillgothen.src = "https://ditzbitz.com/guessillgothen.mp3"
    sounds.push(guessillgothen)
    const yeahimfamiliarsee = new Audio()
    yeahimfamiliarsee.src = "https://ditzbitz.com/yeahimfamiliarsee.mp3"
    sounds.push(yeahimfamiliarsee)
    const amiaringer = new Audio()
    amiaringer.src = "https://ditzbitz.com/amiaringer.mp3"
    sounds.push(amiaringer)
    const ohisthattheeyeofthesnake = new Audio()
    ohisthattheeyeofthesnake.src = "https://ditzbitz.com/ohisthattheeyeofthesnake.mp3"
    sounds.push(ohisthattheeyeofthesnake)
    const snazzyrim = new Audio()
    snazzyrim.src = "https://ditzbitz.com/snazzyrim.mp3"
    sounds.push(snazzyrim)
    const hangintheremanlol = new Audio()
    hangintheremanlol.src = "https://ditzbitz.com/hangintheremanlol.mp3"
    sounds.push(hangintheremanlol)
    const slowworkingsite = new Audio()
    slowworkingsite.src = "https://ditzbitz.com/slowworkingsite.mp3"
    sounds.push(slowworkingsite)

    //imago audio
    const boh = new Audio()
    boh.src = "https://ditzbitz.com/boh.mp3"
    sounds.push(boh)
    const sieveceaselessly = new Audio()
    sieveceaselessly.src = "https://ditzbitz.com/sieveceaselessly.mp3"
    sounds.push(sieveceaselessly)
    const sieveseejunior = new Audio()
    sieveseejunior.src = "https://ditzbitz.com/sieveseejunior.mp3"
    sounds.push(sieveseejunior)
    const ahhbarber = new Audio()
    ahhbarber.src = "https://ditzbitz.com/ahhbarber.mp3"
    sounds.push(ahhbarber)
    const go = new Audio()
    go.src = "https://ditzbitz.com/go.mp3"
    sounds.push(go)
    const die = new Audio()
    die.src = "https://ditzbitz.com/die.mp3"
    sounds.push(die)
    const youneedmyassagain = new Audio()
    youneedmyassagain.src = "https://ditzbitz.com/youneedmyassagain.mp3"
    sounds.push(youneedmyassagain)
    const yeahiminthisroom = new Audio()
    yeahiminthisroom.src = "https://ditzbitz.com/yeahiminthisroom.mp3"
    sounds.push(yeahiminthisroom)
    const slamdownmustard = new Audio()
    slamdownmustard.src = "https://ditzbitz.com/slamdownmustard.mp3"
    sounds.push(slamdownmustard)


    const donttellme = new Audio()
    donttellme.src = "https://ditzbitz.com/onmyway.mp3"
    sounds.push(donttellme)
    const reporting = new Audio()
    reporting.src = "https://ditzbitz.com/reporting.mp3"
    sounds.push(reporting)
    const onmyway = new Audio()
    onmyway.src = "https://ditzbitz.com/onmyway.mp3"
    sounds.push(onmyway)
    const lesgo = new Audio()
    lesgo.src = "https://ditzbitz.com/lesgo.mp3"
    sounds.push(lesgo)
    const lightemup = new Audio()
    lightemup.src = "https://ditzbitz.com/lightemup.mp3"
    sounds.push(lightemup)
    const tellmywife = new Audio()
    tellmywife.src = "https://ditzbitz.com/tellmywife.mp3"
    sounds.push(tellmywife)
    const deathrattle = new Audio()
    deathrattle.src = "https://ditzbitz.com/deathrattle.mp3"
    sounds.push(deathrattle)
    const orders = new Audio()
    orders.src = "https://ditzbitz.com/orders.mp3"
    sounds.push(orders)
    const orders1 = new Audio()
    orders1.src = "https://ditzbitz.com/orders1.mp3"
    sounds.push(orders1)
    const orders2 = new Audio()
    orders2.src = "https://ditzbitz.com/orders2.mp3"
    sounds.push(orders2)
    const orders3 = new Audio()
    orders3.src = "https://ditzbitz.com/orders3.mp3"
    sounds.push(orders3)
    const orders4 = new Audio()
    orders4.src = "https://ditzbitz.com/orders4.mp3"
    sounds.push(orders4)
    const righton = new Audio()
    righton.src = "https://ditzbitz.com/righton.mp3"
    sounds.push(righton)
    const freezin = new Audio()
    freezin.src = "https://ditzbitz.com/freezin.mp3"
    sounds.push(freezin)
    const freezin1 = new Audio()
    freezin1.src = "https://ditzbitz.com/freezin1.mp3"
    sounds.push(freezin1)
    const freezin2 = new Audio()
    freezin2.src = "https://ditzbitz.com/freezin2.mp3"
    sounds.push(freezin2)
    const freezin3 = new Audio()
    freezin3.src = "https://ditzbitz.com/freezin3.mp3"
    sounds.push(freezin3)
    const freezin4 = new Audio()
    freezin4.src = "https://ditzbitz.com/freezin4.mp3"
    sounds.push(freezin4)


    const combatinit = new Audio()
    combatinit.src = "https://ditzbitz.com/combatinit.mp3"
    sounds.push(combatinit)
    const online = new Audio()
    online.src = "https://ditzbitz.com/online.mp3"
    sounds.push(online)
    const scanning = new Audio()
    scanning.src = "https://ditzbitz.com/scanning.mp3"
    sounds.push(scanning)
    const hello = new Audio()
    hello.src = "https://ditzbitz.com/hello.mp3"
    sounds.push(hello)
    const pathfound = new Audio()
    pathfound.src = "https://ditzbitz.com/pathfound.mp3"
    sounds.push(pathfound)
    const pathing = new Audio()
    pathing.src = "https://ditzbitz.com/pathing.mp3"
    sounds.push(pathing)
    const signallost = new Audio()
    signallost.src = "https://ditzbitz.com/signallost.mp3"
    sounds.push(signallost)
    const error = new Audio()
    error.src = "https://ditzbitz.com/error.mp3"
    sounds.push(signallost)
    const collect = new Audio()
    collect.src = "https://ditzbitz.com/collect.mp3"
    sounds.push(collect)


    //beeple audio

    const beeaudio1 = new Audio()
    beeaudio1.src = "https://ditzbitz.com/beeaudio1.mp3"
    sounds.push(beeaudio1)
    const beeaudio2 = new Audio()
    beeaudio2.src = "https://ditzbitz.com/beeaudio2.mp3"
    sounds.push(beeaudio2)
    const beeaudio3 = new Audio()
    beeaudio3.src = "https://ditzbitz.com/beeaudio3.mp3"
    sounds.push(beeaudio3)
    const beeaudio4 = new Audio()
    beeaudio4.src = "https://ditzbitz.com/beeaudio4.mp3"
    sounds.push(beeaudio4)
    const beeaudio5 = new Audio()
    beeaudio5.src = "https://ditzbitz.com/beeaudio5.mp3"
    sounds.push(beeaudio5)
    const beeaudio6 = new Audio()
    beeaudio6.src = "https://ditzbitz.com/beeaudio6.mp3"
    sounds.push(beeaudio6)
    const beeaudio7 = new Audio()
    beeaudio7.src = "https://ditzbitz.com/beeaudio7.mp3"
    sounds.push(beeaudio7)
    const beeaudio8 = new Audio()
    beeaudio8.src = "https://ditzbitz.com/beeaudio8.mp3"
    sounds.push(beeaudio8)
    const beeaudio9 = new Audio()
    beeaudio9.src = "https://ditzbitz.com/beeaudio9.mp3"
    beeaudio1.playbackRate = 2
    beeaudio2.playbackRate = 2
    beeaudio3.playbackRate = 2
    beeaudio4.playbackRate = 2
    beeaudio5.playbackRate = 2
    beeaudio6.playbackRate = 2
    beeaudio7.playbackRate = 2
    beeaudio8.playbackRate = 2
    beeaudio1.volume= .5
    beeaudio2.volume= .5
    beeaudio3.volume= .5
    beeaudio4.volume= .5
    beeaudio5.volume= .5
    beeaudio6.volume= .5
    beeaudio7.volume= .5
    beeaudio8.volume= .5
    beeaudio9.volume= .5
    sounds.push(beeaudio9)

    //avesection audio hack 
    let avesounds = []
    for (let t = 1; t < 24; t++) {
        const audi = new Audio()
        audi.src = `https://ditzbitz.com/avesectianaudio${t}.mp3`
        sounds.push(audi)
        avesounds.push(audi)
    }

    //////////console.log(avesounds)

    //plazt
    const funintro = new Image()
    funintro.src = "https://ditzbitz.com/funintro.png"
    const aveintro = new Image()
    aveintro.src = "https://ditzbitz.com/aveintro.png"
    const gogonautfaces = new Image()
    gogonautfaces.src = "https://ditzbitz.com/gogonautfaces.png"
    const alagadilefaces = new Image()
    alagadilefaces.src = "https://ditzbitz.com/alagadilefaces.png"

    


    // gogonaughts sprites
    const gogonaut = new Image()
    gogonaut.src = "https://ditzbitz.com/gogonaut.png"
    const gogonautwalksheet = new Image()
    gogonautwalksheet.src = "https://ditzbitz.com/gogonautwalksheet.png"
    const gogonautchampion = new Image()
    gogonautchampion.src = "https://ditzbitz.com/gogonautchampion.png"
    const gogonautchampionwalksheet = new Image()
    gogonautchampionwalksheet.src = "https://ditzbitz.com/gogonautchampionwalksheet.png"
    const gogonautteamwalksheet = new Image()
    gogonautteamwalksheet.src = "https://ditzbitz.com/gogonautteamwalksheet.png"



    const gogonautchampionwalksheetinv = new Image()
    gogonautchampionwalksheetinv.src = "https://ditzbitz.com/gogonautchampionwalksheetinv.png"
    const gogonautteamwalksheetinv = new Image()
    gogonautteamwalksheetinv.src = "https://ditzbitz.com/gogonautteamwalksheetinv.png"
    const gogonautwalksheetinv = new Image()
    gogonautwalksheetinv.src = "https://ditzbitz.com/gogonautwalksheetinv.png"




    const gogonautdefender = new Image()
    gogonautdefender.src = "https://ditzbitz.com/gogonautdefender.png"
    const gogonautdefenderwalksheet = new Image()
    gogonautdefenderwalksheet.src = "https://ditzbitz.com/gogonautdefenderwalksheet.png"
    const gogonautdefenderwalksheetinv = new Image()
    gogonautdefenderwalksheetinv.src = "https://ditzbitz.com/gogonautdefenderwalksheetinv.png"

    const gogonautteam = new Image()
    gogonautteam.src = "https://ditzbitz.com/gogonautteam.png"

    const gogonautinv = new Image()
    gogonautinv.src = "https://ditzbitz.com/gogonautinv.png"
    const gogonautchampioninv = new Image()
    gogonautchampioninv.src = "https://ditzbitz.com/gogonautchampioninv.png"
    const gogonautdefenderinv = new Image()
    gogonautdefenderinv.src = "https://ditzbitz.com/gogonautdefenderinv.png"
    const gogonautteaminv = new Image()
    gogonautteaminv.src = "https://ditzbitz.com/gogonautteaminv.png"


    const gogonautface = new Image()
    gogonautface.src = "https://ditzbitz.com/gogonautface.png"
    const gogonautchampionface = new Image()
    gogonautchampionface.src = "https://ditzbitz.com/gogonautchampionface2.png"
    const gogonautdefenderface = new Image()
    gogonautdefenderface.src = "https://ditzbitz.com/gogonautchampionface.png"
    const gogonautteamface = new Image()
    gogonautteamface.src = "https://ditzbitz.com/gogonautteamface.png"

    const gogonautfaceinv = new Image()
    gogonautfaceinv.src = "https://ditzbitz.com/gogonautfaceinv.png"
    const gogonautchampionfaceinv = new Image()
    gogonautchampionfaceinv.src = "https://ditzbitz.com/gogonautchampionface2inv.png"
    const gogonautdefenderfaceinv = new Image()
    gogonautdefenderfaceinv.src = "https://ditzbitz.com/gogonautdefenderfaceinv.png"
    const gogonautteamfaceinv = new Image()
    gogonautteamfaceinv.src = "https://ditzbitz.com/gogonautteamfaceinv.png"



    const gogonautdeathinv = new Image()
    gogonautdeathinv.src = "https://ditzbitz.com/gogonautdeathinv.png"
    const gogonautchampiondeathinv = new Image()
    gogonautchampiondeathinv.src = "https://ditzbitz.com/gogonautchampiondeathinv.png"
    const gogonautdefenderdeathinv = new Image()
    gogonautdefenderdeathinv.src = "https://ditzbitz.com/gogonautdefenderdeathinv.png"
    const gogonautteamdeathinv = new Image()
    gogonautteamdeathinv.src = "https://ditzbitz.com/gogonautteamdeathinv.png"

    const gogonautdeath = new Image()
    gogonautdeath.src = "https://ditzbitz.com/gogonautdeath.png"
    const gogonautchampiondeath = new Image()
    gogonautchampiondeath.src = "https://ditzbitz.com/gogonautchampiondeath.png"
    const gogonautdefenderdeath = new Image()
    gogonautdefenderdeath.src = "https://ditzbitz.com/gogonautdefenderdeath.png"
    const gogonautteamdeath = new Image()
    gogonautteamdeath.src = "https://ditzbitz.com/gogonautteamdeath.png"




    const gogonauttree = new Image()
    gogonauttree.src = "https://ditzbitz.com/gogonauttreesheet.png"


    const gogonauttree2 = new Image()
    gogonauttree2.src = "https://ditzbitz.com/gogonauttree.png"

    const gogonauttreeinv2 = new Image()
    gogonauttreeinv2.src = "https://ditzbitz.com/gogonauttreeinv.png"

    const gogonauttreesheetinv = new Image()
    gogonauttreesheetinv.src = "https://ditzbitz.com/gogonauttreesheetinv.png"


    // colditzlerian faces
    const coldintro = new Image()
    coldintro.src = "https://ditzbitz.com/coldintro.png"


    const nymphface = new Image()
    nymphface.src = "https://ditzbitz.com/nymphface2.png"
    const imagoface = new Image()
    imagoface.src = "https://ditzbitz.com/imagoface2.png"
    const scurrierface = new Image()
    scurrierface.src = "https://ditzbitz.com/scurrierface2.png"
    const gamergateface = new Image()
    gamergateface.src = "https://ditzbitz.com/gamergateface2.png"

    const nymphfacesana = new Image()
    nymphfacesana.src = "https://ditzbitz.com/nymphface2sana.png"
    const imagofacesana = new Image()
    imagofacesana.src = "https://ditzbitz.com/imagoface2sana.png"
    const scurrierfacesana = new Image()
    scurrierfacesana.src = "https://ditzbitz.com/scurrierface2sana.png"
    const gamergatefacesana = new Image()
    gamergatefacesana.src = "https://ditzbitz.com/gamergateface2sana.png"

    const babyalagadileface = new Image()
    babyalagadileface.src = "https://ditzbitz.com/alagadileface.png"
    const bigalagadileface = new Image()
    bigalagadileface.src = "https://ditzbitz.com/big alagadileface.png"
    const bighunchalagadileface = new Image()
    bighunchalagadileface.src = "https://ditzbitz.com/big hunch alagadileface.png"
    const hunchalagadileface = new Image()
    hunchalagadileface.src = "https://ditzbitz.com/hunch alagadileface.png"

    //Plaztilite sprites


    // const knightface = new Image()
    // knightface.src = "https://ditzbitz.com/mycodefenderface.png"
    // const vizirface = new Image()
    // vizirface.src = "https://ditzbitz.com/whistlerface.png"
    // const seerface = new Image()
    // seerface.src = "https://ditzbitz.com/seenface.png"
    // const buddyface = new Image()
    // buddyface.src = "https://ditzbitz.com/boomface.png"



    const knightface = new Image()
    knightface.src = "https://ditzbitz.com/knightface.png"
    const vizirface = new Image()
    vizirface.src = "https://ditzbitz.com/vizirface.png"
    const seerface = new Image()
    seerface.src = "https://ditzbitz.com/seerface3.png"
    const buddyface = new Image()
    buddyface.src = "https://ditzbitz.com/buddyface4.png"


    const fruitingbuddy = new Image()
    fruitingbuddy.src = "https://ditzbitz.com/fruitingbuddy.png" //fruingbuddy
    const fruitingbuddywalksheet = new Image()
    fruitingbuddywalksheet.src = "https://ditzbitz.com/fruitingbuddywalksheet.png" //fruingbuddy
    const fruitingbuddywalksheetinv = new Image()
    fruitingbuddywalksheetinv.src = "https://ditzbitz.com/fruitingbuddywalksheetinv.png" //fruingbuddy

    const mycoknight = new Image()
    mycoknight.src = "https://ditzbitz.com/mycoknight3.png" //mycoknight3
    const sporevizir = new Image()
    sporevizir.src = "https://ditzbitz.com/sporevizir.png" //sporevizir
    const sporeseer = new Image()
    sporeseer.src = "https://ditzbitz.com/sporeseer.png" //sporeseer


    const fruitingbuddydeath = new Image()
    fruitingbuddydeath.src = "https://ditzbitz.com/fruitingbuddydeath.png" //fruingbuddy
    const fruitingbuddydeathinv = new Image()
    fruitingbuddydeathinv.src = "https://ditzbitz.com/fruitingbuddydeathinv.png" //fruingbuddy
    const mycoknightdeathinv = new Image()
    mycoknightdeathinv.src = "https://ditzbitz.com/mycoknight3deathinv.png" //mycoknight3
    const mycoknightdeath = new Image()
    mycoknightdeath.src = "https://ditzbitz.com/mycoknight3death.png" //mycoknight3
    const sporevizirdeathinv = new Image()
    sporevizirdeathinv.src = "https://ditzbitz.com/sporevizirdeathinv.png" //sporevizir
    const sporevizirdeath = new Image()
    sporevizirdeath.src = "https://ditzbitz.com/sporevizirdeath.png" //sporevizir
    const sporeseerdeathinv = new Image()
    sporeseerdeathinv.src = "https://ditzbitz.com/sporeseerdeathinv.png" //sporeseer
    const sporeseerdeath = new Image()
    sporeseerdeath.src = "https://ditzbitz.com/sporeseerdeath.png" //sporeseer

    const fruitingbuddyinv = new Image()
    fruitingbuddyinv.src = "https://ditzbitz.com/fruitingbuddyinv.png" //fruingbuddy
    const mycoknightinv = new Image()
    mycoknightinv.src = "https://ditzbitz.com/mycoknight3inv.png" //mycoknight3
    const sporevizirinv = new Image()
    sporevizirinv.src = "https://ditzbitz.com/sporevizirinv.png" //sporevizir
    const sporeseerinv = new Image()
    sporeseerinv.src = "https://ditzbitz.com/sporeseerinv.png" //sporeseer
    const sporevizirwalksheet = new Image()
    sporevizirwalksheet.src = "https://ditzbitz.com/sporevizirwalksheet.png" //sporeseer
    const mycoknightwalksheet = new Image()
    mycoknightwalksheet.src = "https://ditzbitz.com/mycoknightwalksheet.png" //sporeseer
    const sporeseerwalksheet = new Image()
    sporeseerwalksheet.src = "https://ditzbitz.com/sporeseerwalksheet.png" //sporeseer



    const sporevizirwalksheetinv = new Image()
    sporevizirwalksheetinv.src = "https://ditzbitz.com/sporevizirwalksheetinv.png" //sporeseer
    const mycoknightwalksheetinv = new Image()
    mycoknightwalksheetinv.src = "https://ditzbitz.com/mycoknightwalksheetinv.png" //sporeseer
    const sporeseerwalksheetinv = new Image()
    sporeseerwalksheetinv.src = "https://ditzbitz.com/sporeseerwalksheetinv.png" //sporeseer




    const boombuddy = new Image()
    boombuddy.src = "https://ditzbitz.com/boombuddy.png" //fruingbuddy
    const mycodefender = new Image()
    mycodefender.src = "https://ditzbitz.com/mycodefender.png" //mycoknight3
    const sporewhistler = new Image()
    sporewhistler.src = "https://ditzbitz.com/whistler.png" //sporevizir
    const sporeseen = new Image()
    sporeseen.src = "https://ditzbitz.com/spoorseen.png" //sporeseer

    // human faces
    const humanfacesintro = new Image()
    humanfacesintro.src = "https://ditzbitz.com/humanfacesintro.png"
    const infantryface = new Image()
    infantryface.src = "https://ditzbitz.com/infantryface2.png"
    const droneface = new Image()
    droneface.src = "https://ditzbitz.com/droneface2.png"
    const sniperface = new Image()
    sniperface.src = "https://ditzbitz.com/sniperface2.png"
    const harvesterface = new Image()
    harvesterface.src = "https://ditzbitz.com/harvesterface2.png"

    const superinfantryface = new Image()
    superinfantryface.src = "https://ditzbitz.com/superinfantryface.png"
    const superdroneface = new Image()
    superdroneface.src = "https://ditzbitz.com/superdroneface.png"
    const supersniperface = new Image()
    supersniperface.src = "https://ditzbitz.com/supersniperface.png"
    const superharvesterface = new Image()
    superharvesterface.src = "https://ditzbitz.com/superharvesterface.png"




    // hamartan faces
    const hamintro = new Image()
    hamintro.src = "https://ditzbitz.com/hamintro.png"
    const hamartanscoutface = new Image()
    hamartanscoutface.src = "https://ditzbitz.com/hamartanscoutface2.png" //hamartanscoutface2
    const hamartansoldierface = new Image()
    hamartansoldierface.src = "https://ditzbitz.com/hamartansoldierface2.png"  //hamartansoldierface2
    const hamartanworkerface = new Image()
    hamartanworkerface.src = "https://ditzbitz.com/hamartanworkerface2.png" //hamartanworkerface2
    const hamartaninvaderface = new Image()
    hamartaninvaderface.src = "https://ditzbitz.com/hamartaninvaderface2.png" //hamartaninvaderface2



    const hamartanfragmentface = new Image()
    hamartanfragmentface.src = "https://ditzbitz.com/hamartanfragmentface.png" //hamartanscoutface2
    const hamartanfragmenterface = new Image()
    hamartanfragmenterface.src = "https://ditzbitz.com/hamartanfragmenterface.png"  //hamartansoldierface2
    const hamartansuperworkerface = new Image()
    hamartansuperworkerface.src = "https://ditzbitz.com/hamartansuperworkerface.png" //hamartanworkerface2
    const hamartandiggerface = new Image()
    hamartandiggerface.src = "https://ditzbitz.com/hamartandiggerface.png" //hamartaninvaderface2


    let pollinatornotch = 0
    let pollinatortick = Math.floor(Math.random() * 20) + 25

    let puffnotch = 0
    let pufftick = Math.floor(Math.random() * 20) + 25

    let golonotch = 0
    let golotick = Math.floor(Math.random() * 20) + 25

    let buddynotch = 0
    let seernotch = 0
    let viznotch = 0
    let myconotch = 0
    let buddytick = Math.floor(Math.random() * 20) + 25
    let seertick = Math.floor(Math.random() * 20) + 25
    let mycotick = Math.floor(Math.random() * 20) + 25
    let viztick = Math.floor(Math.random() * 20) + 25


    // for (let  t = 0; t < sounds.length; t++) {
    // sounds[t].preservesPitch = false
    // sounds[t].playbackRate = 1.1
    // }


    function soundCancel() {
        if (start == 1) {
            /* sets chance of audio playback  */
            soundspamdrop = .04
            selectionspam = .04
            pathspamdrop = .04
            for (let t = 0; t < sounds.length; t++) {
                if(!sounds[t].paused){
                    sounds[t].pause()
                    sounds[t].currentTime = 0
                }
            }
            pollinatornotch = Math.floor(Math.random() * pollinatoraudio.duration)
            pollinatoraudio.currentTime = pollinatornotch
            pollinatoraudio.volume = .5
            puffnotch = Math.floor(Math.random() * pufffellowaudio.duration)
            pufffellowaudio.currentTime = puffnotch
            pufffellowaudio.volume = .5


            buddynotch = Math.floor(Math.random() * buddyaudio.duration)
            buddyaudio.currentTime = buddynotch
            buddyaudio.volume = .5

            viznotch = Math.floor(Math.random() * vizieraudio.duration)
            vizieraudio.currentTime = viznotch
            vizieraudio.volume = .5

            seernotch = Math.floor(Math.random() * seeraudio.duration)
            seeraudio.currentTime = seernotch
            seeraudio.volume = .5


            myconotch = Math.floor(Math.random() * mycoknightaudio.duration)
            mycoknightaudio.currentTime = myconotch
            mycoknightaudio.volume = .5


            golonotch = Math.floor(Math.random() * golophyteaudio.duration)
            golophyteaudio.currentTime = golonotch
            golophyteaudio.volume = .5
            //////////console.log(pollinatoraudio.duration)
            pollinatortick = ((Math.random() * 400) + 1000) / 1000
            pufftick = ((Math.random() * 400) + 900) / 1000
            golotick = ((Math.random() * 400) + 800) / 1000

            buddytick = ((Math.random() * 400) + 500) / 1000
            seertick = ((Math.random() * 400) + 700) / 1000
            viztick = ((Math.random() * 400) + 700) / 1000
            mycotick = ((Math.random() * 400) + 1000) / 1000
        }
    }

    // const defenseicon = new Image()
    // defenseicon.src = "https://ditzbitz.com/defenseicon.png"
    // const attackicon = new Image()
    // attackicon.src = "https://ditzbitz.com/attackicon.png"

    const occupiedpit = new Image()
    occupiedpit.src = 'https://ditzbitz.com/occupiedpit.png'

    const sporeball = new Image()
    sporeball.src = "https://ditzbitz.com/sporeball2.png"

    const sporeballinv = new Image()
    sporeballinv.src = "https://ditzbitz.com/sporeball2inv.png"
    const slime = new Image()
    slime.src = "https://ditzbitz.com/slimesheet.png"
    const slimeinv = new Image()
    slimeinv.src = "https://ditzbitz.com/slimesheetinv.png"



    const hotslime = new Image()
    hotslime.src = "https://ditzbitz.com/hotslime.png"
    const hotslimeinv = new Image()
    hotslimeinv.src = "https://ditzbitz.com/hotslimeinv.png"

    const icewall = new Image()
    icewall.src = "https://ditzbitz.com/icewall2.png"
    const barracks = new Image()
    barracks.src = "https://ditzbitz.com/barrackssheet.png"
    const machinelab = new Image()
    machinelab.src = "https://ditzbitz.com/machinelabsheet.png"

    //avesectian buildings
    const eggmound = new Image()
    eggmound.src = "https://ditzbitz.com/eggmound.png"
    const aveegg = new Image()
    aveegg.src = "https://ditzbitz.com/aveegg.png"
    const aveeggsheet = new Image()
    aveeggsheet.src = "https://ditzbitz.com/aveeggcrack.png"
    const aveeggsheetinv = new Image()
    aveeggsheetinv.src = "https://ditzbitz.com/aveeggcrackinv.png"

    const eggmoundinv = new Image()
    eggmoundinv.src = "https://ditzbitz.com/eggmoundinv.png"
    const aveegginv = new Image()
    aveegginv.src = "https://ditzbitz.com/aveegginv.png"

    //alagadile buildings
    const pond = new Image()
    pond.src = "https://ditzbitz.com/pondsheet.png"
    const teleporterimg = new Image()
    teleporterimg.src = "https://ditzbitz.com/teleporterimg.png"
    const pondinv = new Image()
    pondinv.src = "https://ditzbitz.com/pondsheetinv.png"




    //campaign librilian faces
    const xlibrilbianpollinatorface = new Image()
    xlibrilbianpollinatorface.src = "https://ditzbitz.com/librilbian rooterface.png"
    const xgolophyteface = new Image()
    xgolophyteface.src = "https://ditzbitz.com/librilbian blossomfolkface.png"
    const xpufffellowface = new Image()
    xpufffellowface.src = "https://ditzbitz.com/librilbian fernmanface.png"
    const xpodmanface = new Image()
    xpodmanface.src = "https://ditzbitz.com/librilbian bloommanface.png"




    // //librilian faces
    const bibiintro = new Image()
    bibiintro.src = "https://ditzbitz.com/bibiintro.png"
    const librilbianpollinatorface = new Image()
    librilbianpollinatorface.src = "https://ditzbitz.com/librilbianpollinatorface2.png"
    const golophyteface = new Image()
    golophyteface.src = "https://ditzbitz.com/librilbiangoliophyteface2.png"
    const pufffellowface = new Image()
    pufffellowface.src = "https://ditzbitz.com/pufffellowface4.png"
    const podmanface = new Image()
    podmanface.src = "https://ditzbitz.com/podmanface7.png"


    // campaign librilbian sprites
    const xlibrilbianpodman = new Image()
    xlibrilbianpodman.src = "https://ditzbitz.com/librilbian bloomman.png" //podman
    const xlibrilbianpufffellow = new Image()
    xlibrilbianpufffellow.src = "https://ditzbitz.com/librilbian fernfellow3.png" //librilbian 
    const xlibrilbiangoliophyte = new Image()
    xlibrilbiangoliophyte.src = "https://ditzbitz.com/librilbian blossomfolk3.png" //librilbian goliophyte
    const xlibrilbianpollinator = new Image()
    xlibrilbianpollinator.src = "https://ditzbitz.com/librilbian rootlayer.png" //librilbian pollinator
    const goliophytewalksheet = new Image()
    goliophytewalksheet.src = "https://ditzbitz.com/librilbian goliophytewalksheet.png" //librilbian pollinator

    const goliophytewalksheetinv = new Image()
    goliophytewalksheetinv.src = "https://ditzbitz.com/librilbian goliophytewalksheetinv.png" //librilbian pollinator

    //librilbian sprites
    const librilbianbulbplant = new Image()
    librilbianbulbplant.src = "https://ditzbitz.com/bulbplantsheet.png"
    const librilbianpodmother = new Image()
    librilbianpodmother.src = "https://ditzbitz.com/librilbian podmothersheet.png"

    const librilbianpodman = new Image()
    librilbianpodman.src = "https://ditzbitz.com/librilbian podman.png"
    const librilbianpufffellow = new Image()
    librilbianpufffellow.src = "https://ditzbitz.com/librilbian pufffellow.png"
    const librilbiangoliophyte = new Image()
    librilbiangoliophyte.src = "https://ditzbitz.com/librilbian goliophyte.png"
    const librilbianpollinator = new Image()
    librilbianpollinator.src = "https://ditzbitz.com/librilbian pollinator.png"
    const librilbianpollinatorwalksheet = new Image()
    librilbianpollinatorwalksheet.src = "https://ditzbitz.com/librilbian pollinatorwalksheet.png"
    const librilbianpollinatorwalksheetinv = new Image()
    librilbianpollinatorwalksheetinv.src = "https://ditzbitz.com/librilbian pollinatorwalksheetinv.png"

    const pufffellowwalksheet = new Image()
    pufffellowwalksheet.src = "https://ditzbitz.com/librilbian pufffellowwalksheet.png"
    const pufffellowwalksheetinv = new Image()
    pufffellowwalksheetinv.src = "https://ditzbitz.com/librilbian pufffellowwalksheetinv.png"


    const librilbianpodmandeath = new Image()
    librilbianpodmandeath.src = "https://ditzbitz.com/librilbian podmandeath.png"
    const librilbianpufffellowdeath = new Image()
    librilbianpufffellowdeath.src = "https://ditzbitz.com/librilbian pufffellowdead.png"
    const librilbiangoliophytedeath = new Image()
    librilbiangoliophytedeath.src = "https://ditzbitz.com/librilbian goliophytedeath.png"
    const librilbianpollinatordeath = new Image()
    librilbianpollinatordeath.src = "https://ditzbitz.com/librilbian pollinatordeath.png"



    const librilbianpodmandeathinv = new Image()
    librilbianpodmandeathinv.src = "https://ditzbitz.com/librilbian podmandeathinv.png"
    const librilbianpufffellowdeathinv = new Image()
    librilbianpufffellowdeathinv.src = "https://ditzbitz.com/librilbian pufffellowdeadinv.png"
    const librilbiangoliophytedeathinv = new Image()
    librilbiangoliophytedeathinv.src = "https://ditzbitz.com/librilbian goliophytedeathinv.png"
    const librilbianpollinatordeathinv = new Image()
    librilbianpollinatordeathinv.src = "https://ditzbitz.com/librilbian pollinatordeathinv.png"


    //inv
    const librilbianbulbplantinv = new Image()
    librilbianbulbplantinv.src = "https://ditzbitz.com/bulbplantsheetinv.png"
    const librilbianpodmotherinv = new Image()
    librilbianpodmotherinv.src = "https://ditzbitz.com/librilbian podmothersheetinv.png"

    const librilbianpodmaninv = new Image()
    librilbianpodmaninv.src = "https://ditzbitz.com/podmanwalkinv.png"
    const librilbianpufffellowinv = new Image()
    librilbianpufffellowinv.src = "https://ditzbitz.com/librilbian pufffellowinv.png"
    const librilbiangoliophyteinv = new Image()
    librilbiangoliophyteinv.src = "https://ditzbitz.com/librilbian goliophyteinv.png"
    const librilbianpollinatorinv = new Image()
    librilbianpollinatorinv.src = "https://ditzbitz.com/librilbian pollinatorinv.png"

    const podmanwalk = new Image()
    podmanwalk.src = "https://ditzbitz.com/podmanwalk.png"

    //human and base sprites
    const windmeter = new Image()
    windmeter.src = "https://ditzbitz.com/windmeter.png"
    const progress = new Image()
    progress.src = "https://ditzbitz.com/progressmeter.png"
    const harvester = new Image()
    harvester.src = "https://ditzbitz.com/harvester2.png"
    const drone = new Image()
    drone.src = "https://ditzbitz.com/drone.png"
    const dronewalksheet = new Image()
    dronewalksheet.src = "https://ditzbitz.com/dronewalksheet.png"
    const dronewalksheetinv = new Image()
    dronewalksheetinv.src = "https://ditzbitz.com/dronewalksheetinv.png"
    const infantry = new Image()
    infantry.src = "https://ditzbitz.com/infantry.png"
    const infantrywalksheet = new Image()
    infantrywalksheet.src = "https://ditzbitz.com/infantrywalksheet.png"
    const infantrywalksheetinv = new Image()
    infantrywalksheetinv.src = "https://ditzbitz.com/infantrywalksheetinv.png"
    const sniper1 = new Image()
    sniper1.src = "https://ditzbitz.com/sniper5.png"
    const sniperwalksheet = new Image()
    sniperwalksheet.src = "https://ditzbitz.com/sniperwalksheet.png"
    const sniperwalksheetinv = new Image()
    sniperwalksheetinv.src = "https://ditzbitz.com/sniperwalksheetinv.png"


    // alagadile sprites
    const bigalagadile = new Image()
    bigalagadile.src = "https://ditzbitz.com/big alagadile.png"
    const bigalagadilewalksheet = new Image()
    bigalagadilewalksheet.src = "https://ditzbitz.com/big alagadilewalksheet.png"
    const bigalagadilewalksheetinv = new Image()
    bigalagadilewalksheetinv.src = "https://ditzbitz.com/big alagadilewalksheetinv.png"
    const alagadile = new Image()
    alagadile.src = "https://ditzbitz.com/alagadile.png"
    const alagadilewalksheet = new Image()
    alagadilewalksheet.src = "https://ditzbitz.com/alagadilewalksheet.png"
    const alagadilewalksheetinv = new Image()
    alagadilewalksheetinv.src = "https://ditzbitz.com/alagadilewalksheetinv.png"
    const hunchalagadile = new Image()
    hunchalagadile.src = "https://ditzbitz.com/hunch alagadile.png"
    const hunchalagadilewalksheet = new Image()
    hunchalagadilewalksheet.src = "https://ditzbitz.com/hunch alagadilewalksheet.png"
    const hunchalagadilewalksheetinv = new Image()
    hunchalagadilewalksheetinv.src = "https://ditzbitz.com/hunch alagadilewalksheetinv.png"
    const bighunchalagadile = new Image()
    bighunchalagadile.src = "https://ditzbitz.com/big hunch alagadile.png"

    const bigalagadileinv = new Image()
    bigalagadileinv.src = "https://ditzbitz.com/big alagadileinv.png"
    const alagadileinv = new Image()
    alagadileinv.src = "https://ditzbitz.com/alagadileinv.png"
    const hunchalagadileinv = new Image()
    hunchalagadileinv.src = "https://ditzbitz.com/hunch alagadileinv.png"
    const bighunchalagadileinv = new Image()
    bighunchalagadileinv.src = "https://ditzbitz.com/big hunch alagadileinv.png"

    const alagadiledeathinv = new Image()
    alagadiledeathinv.src = "https://ditzbitz.com/alagadiledeathinv.png"
    const bighunchalagadiledeathinv = new Image()
    bighunchalagadiledeathinv.src = "https://ditzbitz.com/big hunch alagadiledeathinv.png"
    const hunchalagadiledeath = new Image()
    hunchalagadiledeath.src = "https://ditzbitz.com/hunch alagadiledeath.png"
    const hunchalagadiledeathinv = new Image()
    hunchalagadiledeathinv.src = "https://ditzbitz.com/hunch alagadiledeathinv.png"
    const bigalagadiledeathinv = new Image()
    bigalagadiledeathinv.src = "https://ditzbitz.com/big alagadiledeathinv.png"
    const bigalagadiledeath = new Image()
    bigalagadiledeath.src = "https://ditzbitz.com/big alagadiledeath.png"


    // const bigalagadile = new Image()
    // bigalagadile.src = "https://ditzbitz.com/big alagadile.png"
    const alagadiledeath = new Image()
    alagadiledeath.src = "https://ditzbitz.com/alagadiledeath.png"
    // const hunchalagadile = new Image()
    // hunchalagadile.src = "https://ditzbitz.com/hunch alagadile.png"
    const bighunchalagadiledeath = new Image()
    bighunchalagadiledeath.src = "https://ditzbitz.com/big hunch alagadiledeath.png"
    const bighunchalagadilewalksheet = new Image()
    bighunchalagadilewalksheet.src = "https://ditzbitz.com/big hunch alagadilewalksheet.png"
    const bighunchalagadilewalksheetinv = new Image()
    bighunchalagadilewalksheetinv.src = "https://ditzbitz.com/big hunch alagadilewalksheetinv.png"

    const harvesterdeath = new Image()
    harvesterdeath.src = "https://ditzbitz.com/harvester2death.png"
    const dronedeath = new Image()
    dronedeath.src = "https://ditzbitz.com/dronedeath.png"
    const infantrydeath = new Image()
    infantrydeath.src = "https://ditzbitz.com/infantrydeath.png"
    const sniper1death = new Image()
    sniper1death.src = "https://ditzbitz.com/sniper5death.png"
    const infantrydeathinv = new Image()
    infantrydeathinv.src = "https://ditzbitz.com/infantrydeathinv.png"
    const sniper1deathinv = new Image()
    sniper1deathinv.src = "https://ditzbitz.com/sniper5deathinv.png"

    const dronedeathinv = new Image()
    dronedeathinv.src = "https://ditzbitz.com/dronedeathinv.png"

    const harvesterinv = new Image()
    harvesterinv.src = "https://ditzbitz.com/harvester2inv.png"
    const droneinv = new Image()
    droneinv.src = "https://ditzbitz.com/drone1inv.png"
    const infantryinv = new Image()
    infantryinv.src = "https://ditzbitz.com/infantryinv.png"
    const sniper1inv = new Image()
    sniper1inv.src = "https://ditzbitz.com/sniper5inv.png"


    const supersniper1 = new Image()
    supersniper1.src = "https://ditzbitz.com/supersniper.png"
    const superharvester = new Image()
    superharvester.src = "https://ditzbitz.com/superharvester.png"
    const superdrone = new Image()
    superdrone.src = "https://ditzbitz.com/superdrone.png"
    const superinfantry = new Image()
    superinfantry.src = "https://ditzbitz.com/superinfantry.png"


    // beeple sprites

    const beeworkerimgwalk = new Image()
    beeworkerimgwalk.src = "https://ditzbitz.com/bee workerwalk.png"
    const beemegaimgwalk = new Image()
    beemegaimgwalk.src = "https://ditzbitz.com/bee megawalk.png"
    const beesoldierimgwalk = new Image()
    beesoldierimgwalk.src = "https://ditzbitz.com/bee soldierwalk.png"
    const beescoutimgwalk = new Image()
    beescoutimgwalk.src = "https://ditzbitz.com/bee scoutwalk.png"




    const beemegaface = new Image()
    beemegaface.src = "https://ditzbitz.com/bee megaface3.png"
    const beehiveimg = new Image()
    beehiveimg.src = "https://ditzbitz.com/beehivesheet.png"
    const beeworkerimg = new Image()
    beeworkerimg.src = "https://ditzbitz.com/bee worker.png"
    const beemegaimg = new Image()
    beemegaimg.src = "https://ditzbitz.com/bee mega.png"
    const beesoldierimg = new Image()
    beesoldierimg.src = "https://ditzbitz.com/bee soldier.png"
    const beescoutimg = new Image()
    beescoutimg.src = "https://ditzbitz.com/bee scout.png"
    const beescoutdeathimg = new Image()
    beescoutdeathimg.src = "https://ditzbitz.com/bee scoutdeath.png"
    const beesoldierdeathimg = new Image()
    beesoldierdeathimg.src = "https://ditzbitz.com/bee soldierdeath.png"
    const beemegadeathimg = new Image()
    beemegadeathimg.src = "https://ditzbitz.com/bee megadeath.png"
    const beeworkerdeathimg = new Image()
    beeworkerdeathimg.src = "https://ditzbitz.com/bee workerdeath.png"
    //itzler sprites
    const imago = new Image()
    imago.src = "https://ditzbitz.com/imagobl3.png" //imagobl3
    const imagosheet = new Image()
    imagosheet.src = "https://ditzbitz.com/imagowalksheet.png" //imagobl3
    const imagowalksheetinv = new Image()
    imagowalksheetinv.src = "https://ditzbitz.com/imagowalksheetinv.png" //imagobl3

    const nymphsheet = new Image()
    nymphsheet.src = "https://ditzbitz.com/nymphwalksheet.png" //imagobl3

    const nymphwalksheetinv = new Image()
    nymphwalksheetinv.src = "https://ditzbitz.com/nymphwalksheetinv.png" //imagobl3
    const gamergate = new Image()
    gamergate.src = "https://ditzbitz.com/gamergate.png" //gamergate
    const gamergatesheet = new Image()
    gamergatesheet.src = "https://ditzbitz.com/gamergatewalksheet.png" //gamergate
    const gamergatewalksheetinv = new Image()
    gamergatewalksheetinv.src = "https://ditzbitz.com/gamergatewalksheetinv.png" //gamergate




    const gamergatedug = new Image()
    gamergatedug.src = "https://ditzbitz.com/gamergatedug.png" //dug?
    const scuttler = new Image()
    scuttler.src = "https://ditzbitz.com/scuttler2.png" //scuttler2
    const scuttlersheet = new Image()
    scuttlersheet.src = "https://ditzbitz.com/scurrierwalksheet.png" //scuttler2
    const scuttlersheetinv = new Image()
    scuttlersheetinv.src = "https://ditzbitz.com/scurrierwalksheetinv.png" //scuttler2
    const nymph = new Image()
    nymph.src = "https://ditzbitz.com/nymph2.png" //nymph2

    const imagodeath = new Image()
    imagodeath.src = "https://ditzbitz.com/imagobl3death.png" //imagobl3
    const gamergatedeath = new Image()
    gamergatedeath.src = "https://ditzbitz.com/gamergatedeath.png" //gamergate
    const scuttlerdeathimg = new Image()
    scuttlerdeathimg.src = "https://ditzbitz.com/scuttler2death.png" //scuttler2
    const nymphdeath = new Image()
    nymphdeath.src = "https://ditzbitz.com/nymph2death.png" //nymph2


    const imagodeathinv = new Image()
    imagodeathinv.src = "https://ditzbitz.com/imagobl3deathinv.png" //imagobl3
    const gamergatedeathinv = new Image()
    gamergatedeathinv.src = "https://ditzbitz.com/gamergatedeathinv.png" //gamergate
    const scuttlerdeathimginv = new Image()
    scuttlerdeathimginv.src = "https://ditzbitz.com/scuttler2deathinv.png" //scuttler2
    const nymphdeathinv = new Image()
    nymphdeathinv.src = "https://ditzbitz.com/nymph2deathinv.png" //nymph2



    //inv itzler sprites
    const imagoinv = new Image()
    imagoinv.src = "https://ditzbitz.com/imagobl3inv.png" //imagobl3
    const gamergateinv = new Image()
    gamergateinv.src = "https://ditzbitz.com/gamergateinv.png" //gamergate
    const gamergateduginv = new Image()
    gamergateduginv.src = "https://ditzbitz.com/gamergateduginv.png" //dug?
    const scuttlerinv = new Image()
    scuttlerinv.src = "https://ditzbitz.com/scuttler3inv.png" //scuttler2
    const nymphinv = new Image()
    nymphinv.src = "https://ditzbitz.com/nymph2inv.png" //nymph2

    //avesectian sprites
    const flugoon = new Image()
    flugoon.src = "https://ditzbitz.com/avesectian flugoon.png" //imagobl3
    const starbatross = new Image()
    starbatross.src = "https://ditzbitz.com/avesectian starbatross.png" //gamergate
    const megagnat = new Image()
    megagnat.src = "https://ditzbitz.com/avesectian megagnat.png" //scuttler2
    const buzzlet = new Image()
    buzzlet.src = "https://ditzbitz.com/avesectian buzzlet.png" //nymph2
    const buzzletwalksheet = new Image()
    buzzletwalksheet.src = "https://ditzbitz.com/avesectian buzzletwalksheet.png" //nymph2
    const buzzletwalksheetinv = new Image()
    buzzletwalksheetinv.src = "https://ditzbitz.com/avesectian buzzletwalksheetinv.png" //nymph2


    const flugoondeath = new Image()
    flugoondeath.src = "https://ditzbitz.com/avesectian flugoondeath.png" //imagobl3
    const starbatrossdeath = new Image()
    starbatrossdeath.src = "https://ditzbitz.com/avesectian starbatrossdeath.png" //gamergate
    const megagnatdeath = new Image()
    megagnatdeath.src = "https://ditzbitz.com/avesectian megagnatdeath.png" //scuttler2
    const buzzletdeath = new Image()
    buzzletdeath.src = "https://ditzbitz.com/avesectian buzzletdeath.png" //nymph2


    //invavesectian sprites

    const flugoonwalksheetinv = new Image()
    flugoonwalksheetinv.src = "https://ditzbitz.com/avesectian flugoonwalksheetinv.png"

    const megagnatwalksheetinv = new Image()
    megagnatwalksheetinv.src = "https://ditzbitz.com/avesectian megagnatwalksheetinv.png"

    const starbatrosswalksheetinv = new Image()
    starbatrosswalksheetinv.src = "https://ditzbitz.com/avesectian starbatrosswalksheetinv.png"



    const flugoonwalksheet = new Image()
    flugoonwalksheet.src = "https://ditzbitz.com/avesectian flugoonwalksheet.png"

    const megagnatwalksheet = new Image()
    megagnatwalksheet.src = "https://ditzbitz.com/avesectian megagnatwalksheet.png"

    const starbatrosswalksheet = new Image()
    starbatrosswalksheet.src = "https://ditzbitz.com/avesectian starbatrosswalksheet.png"

    const flugooninv = new Image()
    flugooninv.src = "https://ditzbitz.com/avesectian flugooninv.png" //imagobl3
    const starbatrossinv = new Image()
    starbatrossinv.src = "https://ditzbitz.com/avesectian starbatrossinv.png" //gamergate
    const megagnatinv = new Image()
    megagnatinv.src = "https://ditzbitz.com/avesectian megagnatinv.png" //scuttler2
    const buzzletinv = new Image()
    buzzletinv.src = "https://ditzbitz.com/avesectian buzzletinv.png" //nymph2

    const flugoondeathinv = new Image()
    flugoondeathinv.src = "https://ditzbitz.com/avesectian flugoondeathinv.png" //imagobl3
    const starbatrossdeathinv = new Image()
    starbatrossdeathinv.src = "https://ditzbitz.com/avesectian starbatrossdeathinv.png" //gamergate
    const megagnatdeathinv = new Image()
    megagnatdeathinv.src = "https://ditzbitz.com/avesectian megagnatdeathinv.png" //scuttler2
    const buzzletdeathinv = new Image()
    buzzletdeathinv.src = "https://ditzbitz.com/avesectian buzzletdeathinv.png" //nymph2

    const flugoonface = new Image()
    flugoonface.src = "https://ditzbitz.com/avesectian flugoonface.png" //imagobl3
    const starbatrossface = new Image()
    starbatrossface.src = "https://ditzbitz.com/avesectian starbatrossface.png" //gamergate
    const megagnatface = new Image()
    megagnatface.src = "https://ditzbitz.com/avesectian megagnatface.png" //scuttler2
    const buzzletface = new Image()
    buzzletface.src = "https://ditzbitz.com/avesectian buzzletface.png" //nymph2


    //sana sprites

    const imagosana = new Image()
    imagosana.src = "https://ditzbitz.com/susersaunaimago12.png" //imagobl3
    const gamergatesana = new Image()
    gamergatesana.src = "https://ditzbitz.com/sanagamergate.png" //gamergate
    const gamergatedugsana = new Image()
    gamergatedugsana.src = "https://ditzbitz.com/sanadug.png" //dug?
    const scuttlersana = new Image()
    scuttlersana.src = "https://ditzbitz.com/susersanascuttler.png" //scuttler2
    const nymphsana = new Image()
    nymphsana.src = "https://ditzbitz.com/susersananymph.png" //nymph2



    const hotrock1 = new Image()
    hotrock1.src = "https://ditzbitz.com/hotrock3a.png"
    const hotrock2 = new Image()
    hotrock2.src = "https://ditzbitz.com/hotrock5.png"


    //hamartan sprites
    const spire = new Image()
    spire.src = "https://ditzbitz.com/spire.png"
    const assembler2 = new Image()
    assembler2.src = "https://ditzbitz.com/assembler2sheet.png"
    const assembler3 = new Image()
    assembler3.src = "https://ditzbitz.com/assembler3sheet.png"
    const assembler1 = new Image()
    assembler1.src = "https://ditzbitz.com/assembler1.png"
    const hamartandeath = new Image()
    hamartandeath.src = "https://ditzbitz.com/hamartandeath.png"


    const spireinv = new Image()
    spireinv.src = "https://ditzbitz.com/spireinv.png"
    const assembler2inv = new Image()
    assembler2inv.src = "https://ditzbitz.com/assembler2sheetinv.png"
    const assembler3inv = new Image()
    assembler3inv.src = "https://ditzbitz.com/assembler3sheetinv.png"
    const assembler1inv = new Image()
    assembler1inv.src = "https://ditzbitz.com/assembler1inv.png"


    const hamartansoldier = new Image()
    hamartansoldier.src = "https://ditzbitz.com/hamartansoldier.png" //hamartansoldier
    const hamartansoldierwalksheet = new Image()
    hamartansoldierwalksheet.src = "https://ditzbitz.com/hamartansoldierwalksheet.png" //hamartansoldier
    const hamartansoldierwalksheetinv = new Image()
    hamartansoldierwalksheetinv.src = "https://ditzbitz.com/hamartansoldierwalksheetinv.png" //hamartansoldier
    const hamartanscout = new Image()
    hamartanscout.src = "https://ditzbitz.com/hamartanscout.png" //hamartanscout
    const hamartanscoutwalksheet = new Image()
    hamartanscoutwalksheet.src = "https://ditzbitz.com/hamartanscoutwalksheet.png" //hamartanscout
    const hamartanscoutwalksheetinv = new Image()
    hamartanscoutwalksheetinv.src = "https://ditzbitz.com/hamartanscoutwalksheetinv.png" //hamartanscout
    const hamartaninvader = new Image()
    hamartaninvader.src = "https://ditzbitz.com/hamartaninvader.png" //hamartaninvader
    const hamartaninvaderwalksheet = new Image()
    hamartaninvaderwalksheet.src = "https://ditzbitz.com/hamartaninvaderwalksheet.png" //hamartaninvader
    const hamartaninvaderwalksheetinv = new Image()
    hamartaninvaderwalksheetinv.src = "https://ditzbitz.com/hamartaninvaderwalksheetinv.png" //hamartaninvader
    const hamartanworker = new Image()
    hamartanworker.src = "https://ditzbitz.com/hamartanworker.png" //hamartanworker
    const hamartanworkerwalk = new Image()
    hamartanworkerwalk.src = "https://ditzbitz.com/hamartanworkerwalk.png" //hamartanworker
    const hamartanworkerwalkinv = new Image()
    hamartanworkerwalkinv.src = "https://ditzbitz.com/hamartanworkerwalkinv.png" //hamartanworker


    const hamartansoldierinv = new Image()
    hamartansoldierinv.src = "https://ditzbitz.com/hamartansoldierinv.png" //hamartansoldier
    const hamartanscoutinv = new Image()
    hamartanscoutinv.src = "https://ditzbitz.com/hamartanscoutinv.png" //hamartanscout
    const hamartaninvaderinv = new Image()
    hamartaninvaderinv.src = "https://ditzbitz.com/hamartaninvaderinv.png" //hamartaninvader
    const hamartanworkerinv = new Image()
    hamartanworkerinv.src = "https://ditzbitz.com/hamartanworkerinv.png" //hamartanworker





    const hamartanfragmenter = new Image()
    hamartanfragmenter.src = "https://ditzbitz.com/hamartanfragmenter.png" //hamartansoldier
    const hamartanfragment = new Image()
    hamartanfragment.src = "https://ditzbitz.com/hamartanfragment.png" //hamartanscout
    const hamarmartandigger = new Image()
    hamarmartandigger.src = "https://ditzbitz.com/hamarmartandigger.png" //hamartaninvader
    const superhamartanworker = new Image()
    superhamartanworker.src = "https://ditzbitz.com/superhamartanworker.png" //hamartanworker
    // const sniper1 = new Image()
    // sniper1.src = "https://ditzbitz.com/supersniper.png"
    // const sniper2 = new Image()
    // sniper2.src = "https://ditzbitz.com/sniper2.png"

    const rectstart = {}
    rectstart.x = 0
    rectstart.y = 0
    let selectrect = {}
    selectrect.x = 0
    selectrect.y = 0
    selectrect.width = 0
    selectrect.height = 0
    selectrect.color = "transparent"
    selectrect.draw = empty
    selectrect.isPointInside = empty



    const squaretable = {} // this section of code is an optimization for use of the hypotenuse function on Line and LineOP objects
    for (let t = 0; t < 10000000; t++) {
        squaretable[`${t}`] = Math.sqrt(t)
        if (t > 999) {
            t += 9
        }
    }


    // const distancetable = {}
    // function makeDistanceTable(t,k, g,n) {
    //     var distX = Math.abs(t - g);
    //     var distY = Math.abs(k - nodeB.y);

    //     if (distX > distY) {
    //         return ((1.4 * distY) + ((distX - distY)))

    //     }
    //     return (1.4 * distX + ((distY - distX)));
    // }
    // //////////console.time("onetile")
    // for(let t = 0;t<100;t+=10){
    //     for(let k = 0;k<1280;k+=10){
    //         for(let g = 0;g<1280;g+=10){
    //             for(let n = 0;n<1280;n+=10){
    //                 const ob1 = {}
    //                 ob1.x = t
    //                 ob1.y = k
    //                 const ob2 = {}
    //                 ob2.x = g
    //                 ob2.y = n
    //                 distancetable[`${t},${k},${g},${n}`] = makeDistanceTable(t,k, g,n)
    //             }
    //             //////////console.log(g)
    //         }
    //     }
    //     //////////console.log(t)
    // }
    // // distancetable = JSON.stringify(distancetable)
    // function downloadObject(obj, filename){
    //     var blob = new Blob([JSON.stringify(obj, null, 2)], {type: "application/json;charset=utf-8"}).slice(2,-1);
    //     var url = URL.createObjectURL(blob);
    //     var elem = document.createElement("a");
    //     elem.href = url;
    //     elem.download = filename;
    //     document.body.appendChild(elem);
    //     elem.click();
    //     document.body.removeChild(elem);
    //   }
    //   downloadObject(distancetable, "paths")
    const gamepadAPI = {
        controller: {},
        turbo: true,
        connect: function (evt) {
            if (navigator.getGamepads()[0] != null) {
                gamepadAPI.controller = navigator.getGamepads()[0]
                gamepadAPI.turbo = true;
            } else if (navigator.getGamepads()[1] != null) {
                gamepadAPI.controller = navigator.getGamepads()[0]
                gamepadAPI.turbo = true;
            } else if (navigator.getGamepads()[2] != null) {
                gamepadAPI.controller = navigator.getGamepads()[0]
                gamepadAPI.turbo = true;
            } else if (navigator.getGamepads()[3] != null) {
                gamepadAPI.controller = navigator.getGamepads()[0]
                gamepadAPI.turbo = true;
            }
            for (let  i = 0; i < gamepads.length; i++) {
                if (gamepads[i] === null) {
                    continue;
                }
                if (!gamepads[i].connected) {
                    continue;
                }
            }
        },
        disconnect: function (evt) {
            gamepadAPI.turbo = false;
            delete gamepadAPI.controller;
        },
        update: function () {
            gamepadAPI.controller = navigator.getGamepads()[0]
            gamepadAPI.buttonsCache = [];// clear the buttons cache
            for (var k = 0; k < gamepadAPI.buttonsStatus.length; k++) {// move the buttons status from the previous frame to the cache
                gamepadAPI.buttonsCache[k] = gamepadAPI.buttonsStatus[k];
            }
            gamepadAPI.buttonsStatus = [];// clear the buttons status
            var c = gamepadAPI.controller || {}; // get the gamepad object
            var pressed = [];
            if (c.buttons) {
                for (var b = 0, t = c.buttons.length; b < t; b++) {// loop through buttons and push the pressed ones to the array
                    if (c.buttons[b].pressed) {
                        pressed.push(gamepadAPI.buttons[b]);
                    }
                }
            }
            var axes = [];
            if (c.axes) {
                for (var a = 0, x = c.axes.length; a < x; a++) {// loop through axes and push their values to the array
                    axes.push(c.axes[a].toFixed(2));
                }
            }
            gamepadAPI.axesStatus = axes;// assign received values
            gamepadAPI.buttonsStatus = pressed;
            // //////////console.log(pressed); // return buttons for debugging purposes
            return pressed;
        },
        buttonPressed: function (button, hold) {
            var newPress = false;
            for (var i = 0, s = gamepadAPI.buttonsStatus.length; i < s; i++) {// loop through pressed buttons
                if (gamepadAPI.buttonsStatus[i] == button) {// if we found the button we're looking for...
                    newPress = true;// set the boolean variable to true
                    if (!hold) {// if we want to check the single press
                        for (var j = 0, p = gamepadAPI.buttonsCache.length; j < p; j++) {// loop through the cached states from the previous frame
                            if (gamepadAPI.buttonsCache[j] == button) { // if the button was already pressed, ignore new press
                                newPress = false;
                            }
                        }
                    }
                }
            }
            return newPress;
        },
        buttons: [
            'A', 'B', 'X', 'Y', 'LB', 'RB', 'Left-Trigger', 'Right-Trigger', 'Back', 'Start', 'Axis-Left', 'Axis-Right', 'DPad-Up', 'DPad-Down', 'Dpad-Left', 'DPad-Right', "Power"
        ],
        buttonsCache: [],
        buttonsStatus: [],
        axesStatus: []
    };
    let canvas
    let canvas_context
    const keysPressed = {}
    let FLEX_engine
    const TIP_engine = {}
    let XS_engine
    let YS_engine
    TIP_engine.x = 350
    TIP_engine.y = 350
    class Point {
        constructor(x, y) {
            this.x = x
            this.y = y
            this.radius = 0
        }
        pointDistance(point) {
            return (new LineOP(this, point, "transparent", 0)).hypotenuse()
        }
    }


    class Weight {
        constructor(from, to) {
            this.value = this.weight()
            this.from = from
            this.to = to
            this.change = 0
            this.delta = 1
        }
        valueOf() {
            return this.value
        }
        weight() {
            return (Math.random() - .5)
        }
        setChange(num) {
            this.change = num
        }
        setWeight(num) {
            this.value = num
        }
    }
    class Perceptron {
        constructor(inputs) {
            this.bias = (Math.random() - .5)
            this.value = this.bias
            this.weights = []
            this.outputConnections = []
            this.inputs = inputs
            this.error = 0
            this.delta = 1
            for (let t = 0; t < this.inputs.length; t++) {
                this.weights.push(this.weight(this.inputs[t]))
            }
            this.z = -1
            this.change = 0
        }
        setError(error) {
            this.error = error
        }
        setDelta(delta) {
            this.delta = delta
            for (let t = 0; t < this.outputConnections.length; t++) {
                this.outputConnections[t].delta = this.delta
            }
        }
        setBias(bias) {
            this.bias = bias
        }
        setChange(num) {
            this.change = num
        }
        weight(link) {
            const weight = new Weight(link, this)
            if (typeof link != "number") {
                link.outputConnections.push(weight)
            }
            return weight
        }
        valueOf() {
            return this.value
        }
        compute(inputs = this.inputs) {
            this.inputs = inputs
            this.value = this.bias
            for (let t = 0; t < inputs.length; t++) {
                if (t > this.weights.length - 1) {
                    this.weights.push(this.weight())
                    this.value += (inputs[t].valueOf() * this.weights[t].valueOf())
                } else {
                    this.value += (inputs[t].valueOf() * this.weights[t].valueOf())
                }
            }
            this.relu()
            return this.value
        }
        relu() {
            this.value = Math.min(Math.max(this.value, 0.001), .999)
        }
    }
    class Network {
        constructor(inputs, layerSetupArray) {
            this.momentum = .1
            this.learningRate = .15
            this.setup = layerSetupArray
            this.inputs = inputs
            this.structure = []
            this.outputs = []
            for (let t = 0; t < layerSetupArray.length; t++) {
                const scaffold = []
                for (let k = 0; k < layerSetupArray[t]; k++) {
                    let cept
                    if (t == 0) {
                        cept = new Perceptron(this.inputs)
                    } else {
                        cept = new Perceptron(this.structure[t - 1])
                    }
                    scaffold.push(cept)
                }
                this.structure.push(scaffold)
            }
            this.lastinputs = [...this.inputs]
            this.lastgoals = [...this.lastinputs]
            this.swap = []
        }

        becomeNetworkFrom(network) { //using a js file with one variable can be good for this
            // //////////console.log(this.structure[0][0].bias)
            for (let t = 0; t < this.structure.length; t++) {
                // //////////console.log("h1")
                for (let k = 0; k < this.structure[t].length; k++) {
                    // //////////console.log("h2")
                    this.structure[t][k].bias = network.structure[t][k].bias
                    for (let w = 0; w < this.structure[t][k].weights.length; w++) {
                        // //////////console.log("h3")
                        this.structure[t][k].weights[w].setWeight(network.structure[t][k][w].valueOf())
                    }
                }
            }
            // //////////console.log(this.structure[0][0].bias)
        }
        log() {
            const json = {}
            json.structure = []
            json.setup = [...this.setup]
            for (let t = 0; t < this.structure.length; t++) {
                json.structure.push({})
                for (let k = 0; k < this.structure[t].length; k++) {
                    json.structure[t][k] = {}
                    json.structure[t][k].bias = this.structure[t][k].bias.valueOf()
                    for (let w = 0; w < this.structure[t][k].weights.length; w++) {
                        json.structure[t][k][w] = (this.structure[t][k].weights[w].valueOf())
                    }
                }
            }
            //////////console.log(json)
        }
        calculateDeltasSigmoid(goals) {
            for (let t = this.structure.length - 1; t >= 0; t--) {
                const layer = this.structure[t]
                for (let k = 0; k < layer.length; k++) {
                    const perceptron = layer[k]
                    const output = perceptron.valueOf()
                    const error = 0
                    if (t === this.structure.length - 1) {
                        error = goals[k] - output;
                    } else {
                        for (let k = 0; k < perceptron.outputConnections.length; k++) {
                            const currentConnection = perceptron.outputConnections[k]
                            //////////console.log(currentConnection)
                            error += currentConnection.to.delta * currentConnection.valueOf()
                        }
                    }
                    perceptron.setError(error)
                    perceptron.setDelta(error * output * (1 - output))
                }
            }
        }
        adjustWeights() {
            for (let t = 0; t < this.structure.length; t++) {
                const layer = this.structure[t]
                for (let k = 0; k < layer.length; k++) {
                    const perceptron = layer[k]
                    const delta = perceptron.delta
                    for (let i = 0; i < perceptron.weights.length; i++) {
                        const connection = perceptron.weights[i]
                        const change = connection.change
                        change = (this.learningRate * delta * perceptron.inputs[i].valueOf()) + (this.momentum * change);
                        connection.setChange(change)
                        connection.setWeight(connection.valueOf() + change)
                    }
                    perceptron.setBias(perceptron.bias + (this.learningRate * delta))
                }
            }
        }
        clone(nw) {
            const input = nw.inputs
            const perc = new Network(input, nw.setup)
            for (let t = 0; t < nw.structure.length; t++) {
                for (let k = 0; k < nw.structure[t].length; k++) {
                    perc.structure[t][k] = new Perceptron([0, 0, 0, 0, 0, 0, 0])
                    for (let f = 0; f < nw.structure[t][k].weights.length; f++) {
                        perc.structure[t][k].weights[f] = nw.structure[t][k].weights[f]
                        perc.structure[t][k].bias = nw.structure[t][k].bias
                    }
                }
            }
            return perc
        }
        compute(inputs = this.inputs) {
            this.inputs = [...inputs]
            for (let t = 0; t < this.structure.length; t++) {
                for (let k = 0; k < this.structure[t].length; k++) {
                    if (t == 0) {
                        this.structure[t][k].compute(this.inputs)
                    } else {
                        this.structure[t][k].compute(this.structure[t - 1])
                    }
                }
            }
            this.outputs = []
            this.dataoutputs = []
            for (let t = 0; t < this.structure[this.structure.length - 1].length; t++) {
                this.outputs.push(this.structure[this.structure.length - 1][t].valueOf())
                this.dataoutputs.push(new Data(this.structure[this.structure.length - 1][t].valueOf()))
            }
        }
    }
    class Data {
        constructor(input = -100) {
            this.delta = 0
            this.outputConnections = []
            if (input == -100) {
                this.value = this.weight()
            } else {
                this.value = input
            }
        }
        valueOf() {
            return this.value
        }
        weight() {
            return Math.random() - .5
        }
    }

    class Vector { // vector math and physics if you prefer this over vector components on circles
        constructor(object = (new Point(0, 0)), xmom = 0, ymom = 0) {
            this.xmom = xmom
            this.ymom = ymom
            this.object = object
        }
        isToward(point) {
            const link = new LineOP(this.object, point)
            const dis1 = link.squareDistance()
            const dummy = new Point(this.object.x + this.xmom, this.object.y + this.ymom)
            const link2 = new LineOP(dummy, point)
            const dis2 = link2.squareDistance()
            if (dis2 < dis1) {
                return true
            } else {
                return false
            }
        }
        rotate(angleGoal) {
            const link = new Line(this.xmom, this.ymom, 0, 0)
            const length = link.hypotenuse()
            const x = (length * Math.cos(angleGoal))
            const y = (length * Math.sin(angleGoal))
            this.xmom = x
            this.ymom = y
        }
        magnitude() {
            return (new Line(this.xmom, this.ymom, 0, 0)).hypotenuse()
        }
        normalize(size = 1) {
            const magnitude = this.magnitude()
            this.xmom /= magnitude
            this.ymom /= magnitude
            this.xmom *= size
            this.ymom *= size
        }
        multiply(vect) {
            const point = new Point(0, 0)
            const end = new Point(this.xmom + vect.xmom, this.ymom + vect.ymom)
            return point.pointDistance(end)
        }
        add(vect) {
            return new Vector(this.object, this.xmom + vect.xmom, this.ymom + vect.ymom)
        }
        subtract(vect) {
            return new Vector(this.object, this.xmom - vect.xmom, this.ymom - vect.ymom)
        }
        divide(vect) {
            return new Vector(this.object, this.xmom / vect.xmom, this.ymom / vect.ymom) //be careful with this, I don't think this is right
        }
        draw() {
            const dummy = new Point(this.object.x + this.xmom, this.object.y + this.ymom)
            const link = new LineOP(this.object, dummy, "#FFFFFF", 1)
            link.draw()
        }
    }
    class Line {
        constructor(x, y, x2, y2, color, width) {
            this.x1 = x
            this.y1 = y
            this.x2 = x2
            this.y2 = y2
            this.color = color
            this.width = width
        }
        angle() {
            return Math.atan2(this.y1 - this.y2, this.x1 - this.x2)
        }
        squareDistance() {
            const xdif = this.x1 - this.x2
            const ydif = this.y1 - this.y2
            const squareDistance = (xdif * xdif) + (ydif * ydif)
            return squareDistance
        }
        hypotenuse() {
            const xdif = this.x1 - this.x2
            const ydif = this.y1 - this.y2
            const hypotenuse = (xdif * xdif) + (ydif * ydif)
            if (hypotenuse < 10000000 - 1) {
                if (hypotenuse > 1000) {
                    return squaretable[`${Math.round(10 * Math.round((hypotenuse * .1)))}`]
                } else {
                    return squaretable[`${Math.round(hypotenuse)}`]
                }
            } else {
                return Math.sqrt(hypotenuse)
            }
        }
        draw() {
            const linewidthstorage = map_context.lineWidth
            map_context.strokeStyle = this.color
            map_context.lineWidth = this.width
            map_context.beginPath()
            map_context.moveTo(this.x1, this.y1)
            map_context.lineTo(this.x2, this.y2)
            map_context.stroke()
            map_context.lineWidth = linewidthstorage
        }
    }
    class LineOP {
        constructor(object, target, color, width) {
            this.object = object
            this.target = target
            this.color = color
            this.width = width
        }
        squareDistance() {
            const xdif = this.object.x - this.target.x
            const ydif = this.object.y - this.target.y
            const squareDistance = (xdif * xdif) + (ydif * ydif)
            return squareDistance
        }
        hypotenuse() {
            const xdif = this.object.x - this.target.x
            const ydif = this.object.y - this.target.y
            const hypotenuse = (xdif * xdif) + (ydif * ydif)
            if (hypotenuse < 10000000 - 1) {
                if (hypotenuse > 1000) {
                    return squaretable[`${Math.round(10 * Math.round((hypotenuse * .1)))}`]
                } else {
                    return squaretable[`${Math.round(hypotenuse)}`]
                }
            } else {
                return Math.sqrt(hypotenuse)
            }
        }
        angle() {
            return Math.atan2(this.object.y - this.target.y, this.object.x - this.target.x)
        }
        draw() {
            const linewidthstorage = canvas_context.lineWidth
            canvas_context.strokeStyle = this.color
            canvas_context.lineWidth = this.width
            canvas_context.beginPath()
            canvas_context.moveTo(this.object.x, this.object.y)
            canvas_context.lineTo(this.target.x, this.target.y)
            canvas_context.stroke()
            canvas_context.lineWidth = linewidthstorage
        }
    }
    class LinePO {
        constructor(object, target, color, width) {
            this.object = object
            this.target = target
            this.color = color
            this.width = width
        }
        squareDistance() {
            const xdif = this.object.x - this.target.x
            const ydif = this.object.y - this.target.y
            const squareDistance = (xdif * xdif) + (ydif * ydif)
            return squareDistance
        }
        hypotenuse() {
            const xdif = this.object.xp - this.target.x
            const ydif = this.object.yp - this.target.y
            const hypotenuse = (xdif * xdif) + (ydif * ydif)
            if (hypotenuse < 10000000 - 1) {
                if (hypotenuse > 1000) {
                    return squaretable[`${Math.round(10 * Math.round((hypotenuse * .1)))}`]
                } else {
                    return squaretable[`${Math.round(hypotenuse)}`]
                }
            } else {
                return Math.sqrt(hypotenuse)
            }
        }
        angle() {
            return Math.atan2(this.object.y - this.target.y, this.object.x - this.target.x)
        }
        draw() {
            const linewidthstorage = canvas_context.lineWidth
            canvas_context.strokeStyle = this.color
            canvas_context.lineWidth = this.width
            canvas_context.beginPath()
            canvas_context.moveTo(this.object.x, this.object.y)
            canvas_context.lineTo(this.target.x, this.target.y)
            canvas_context.stroke()
            canvas_context.lineWidth = linewidthstorage
        }
    }
    class Triangle {
        constructor(x, y, color, length, fill = 0, strokeWidth = 0, leg1Ratio = 1, leg2Ratio = 1, heightRatio = 1) {
            this.x = x
            this.y = y
            this.color = color
            this.length = length
            this.x1 = this.x + this.length * leg1Ratio
            this.x2 = this.x - this.length * leg2Ratio
            this.tip = this.y - this.length * heightRatio
            this.accept1 = (this.y - this.tip) / (this.x1 - this.x)
            this.accept2 = (this.y - this.tip) / (this.x2 - this.x)
            this.fill = fill
            this.stroke = strokeWidth
        }
        draw() {
            canvas_context.strokeStyle = this.color
            canvas_context.stokeWidth = this.stroke
            canvas_context.beginPath()
            canvas_context.moveTo(this.x, this.y)
            canvas_context.lineTo(this.x1, this.y)
            canvas_context.lineTo(this.x, this.tip)
            canvas_context.lineTo(this.x2, this.y)
            canvas_context.lineTo(this.x, this.y)
            if (this.fill == 1) {
                canvas_context.fill()
            }
            canvas_context.stroke()
            canvas_context.closePath()
        }
        isPointInside(point) {
            if (point.x <= this.x1) {
                if (point.y >= this.tip) {
                    if (point.y <= this.y) {
                        if (point.x >= this.x2) {
                            this.accept1 = (this.y - this.tip) / (this.x1 - this.x)
                            this.accept2 = (this.y - this.tip) / (this.x2 - this.x)
                            this.basey = point.y - this.tip
                            this.basex = point.x - this.x
                            if (this.basex == 0) {
                                return true
                            }
                            this.slope = this.basey / this.basex
                            if (this.slope >= this.accept1) {
                                return true
                            } else if (this.slope <= this.accept2) {
                                return true
                            }
                        }
                    }
                }
            }
            return false
        }
    }
    class Rectangle {
        constructor(x, y, width, height, color, fill = 1, stroke = 0, strokeWidth = 1) {
            this.x = x
            this.y = y
            this.height = height
            this.width = width
            this.color = color
            this.xmom = 0
            this.ymom = 0
            this.stroke = stroke
            this.strokeWidth = strokeWidth
            this.fill = fill
        }
        draw() {
            map_context.fillStyle = this.color
            map_context.fillRect(this.x, this.y, this.width, this.height)
        }
        move() {
            this.x += this.xmom
            this.y += this.ymom
        }
        isPointInside(point) {
            if (point.x >= this.x) {
                if (point.y >= this.y) {
                    if (point.x <= this.x + this.width) {
                        if (point.y <= this.y + this.height) {
                            return true
                        }
                    }
                }
            }
            return false
        }
        doesPerimeterTouch(point) {
            if (point.x + point.radius >= this.x) {
                if (point.y + point.radius >= this.y) {
                    if (point.x - point.radius <= this.x + this.width) {
                        if (point.y - point.radius <= this.y + this.height) {
                            return true
                        }
                    }
                }
            }
            return false
        }
    }
    class UiRectangle {
        constructor(x, y, width, height, color, fill = 1, stroke = 0, strokeWidth = 1) {
            this.x = x
            this.y = y
            this.height = height
            this.width = width
            this.color = color
            this.xmom = 0
            this.ymom = 0
            this.stroke = stroke
            this.strokeWidth = strokeWidth
            this.fill = fill
        }
        draw() {
            canvas_context.fillStyle = this.color
            canvas_context.fillRect(this.x, this.y, this.width, this.height)
        }
        move() {
            this.x += this.xmom
            this.y += this.ymom
        }
        isPointInside(point) {
            if (point.x >= this.x) {
                if (point.y >= this.y) {
                    if (point.x <= this.x + this.width) {
                        if (point.y <= this.y + this.height) {
                            return true
                        }
                    }
                }
            }
            return false
        }
        doesPerimeterTouch(point) {
            if (point.x + point.radius >= this.x) {
                if (point.y + point.radius >= this.y) {
                    if (point.x - point.radius <= this.x + this.width) {
                        if (point.y - point.radius <= this.y + this.height) {
                            return true
                        }
                    }
                }
            }
            return false
        }
    }


    let factionNames = ["Earthoids", "Cold Itzlerians", "Hamartans", "Librilbians", "Plaztilites", "Avesectians", "Schlorkupine", "Alagadiles", "Targetroid", "Gogonauts", "Beeple", "None"]

    class DropDownDifficulty {
        constructor(player){
            this.body = new UiRectangle(100, 70, 200, 40, "#999999")
            this.player = player
            this.options = [1,2,5,10,15,25,35,50,100,200,400, -1, -2]
            this.names = ["Absolute-Zero","Bone-Chilling","Frigid","Frosty","Sweater-Weather","Cold","Chilly","Drafty","Room-Temperature","Warm","Toasty", "Dynamic", "AI OFF/Manual"]
            this.boundingRect =  new UiRectangle(100, 70, 200, 390, "#555555")
            this.active = 0
        }
        isPointInside(point){
            if(this.active == 0){
                if(this.body.isPointInside(point)){
                    this.active = 1
                }
            }else{
                if(this.boundingRect.isPointInside(point)){
                    if(this.options[Math.min(Math.max((Math.floor((TIP_engine.y-this.boundingRect.y)/30)),0),12)] == -2){
                        this.player.isAI = 0
                        this.player.clickrate = -2
                    }else{
                        this.player.clickrate = this.options[Math.min(Math.max((Math.floor((TIP_engine.y-this.boundingRect.y)/30)),0),12)]
                        this.player.isAI = 1
                        if(this.options[Math.min(Math.max((Math.floor((TIP_engine.y-this.boundingRect.y)/30)),0),12)] == -1){
                            this.player.dynamic = 1
                            this.player.clickrate = -1
                        }
                    }
                    this.active = 0
                    return true
                }else{
                    this.active = 0
                }
            }

        }
        draw(g = 0){
            this.body.x = 140+(g*250)
            this.boundingRect.x = 140+(g*250)
            if(this.active == 0){
                this.body.draw()
                canvas_context.font = "20px arial"
                canvas_context.fillStyle = "Black"
                canvas_context.fillText(this.names[this.options.indexOf(this.player.clickrate)], this.body.x+10, this.body.y+20)
            }else{
                this.boundingRect.draw()
                if(this.boundingRect.isPointInside(TIP_engine)){
                                const glow = new UiRectangle(this.boundingRect.x, this.boundingRect.y+(Math.floor((TIP_engine.y-this.boundingRect.y)/30)*30), this.boundingRect.width, 30, "#FFFFFF")
                                glow.draw()
                }
                for(let t = 0;t<this.names.length;t++){
                    canvas_context.font = "20px arial"
                    canvas_context.fillStyle = "Black"
                    canvas_context.fillText(this.names[t], this.boundingRect.x+10, this.boundingRect.y+20+(30*t))
                }
            }
        }
    }
    class DropDownFaction {
        constructor(player){
            this.body = new UiRectangle(100, 120, 200, 40, "#999999")
            this.player = player
            this.options = [1,2,5,10,15,25,35,50,100,200,400, -1]
            this.names = [...factionNames]
            this.boundingRect =  new UiRectangle(100, 120, 200, 360, "#555555")
            this.active = 0
        }
        isPointInside(point){
            if(this.active == 0){
                if(this.body.isPointInside(point)){
                    this.active = 1
                }
            }else{
                if(this.boundingRect.isPointInside(point)){
                    this.player.type = Math.min(Math.max((Math.floor((TIP_engine.y-this.boundingRect.y)/30)),0),11)
                    this.player.name = this.names[this.player.type]
                    if(Math.min(Math.max((Math.floor((TIP_engine.y-this.boundingRect.y)/30)),0),10) == 11){

                    }   
                    startGame()
                    this.active = 0
                    return true
                }else{
                    this.active = 0
                }
            }

        }
        draw(g = 0){
            this.body.x = 140+(g*250)
            this.boundingRect.x = 140+(g*250)
            if(this.active == 0){
                this.body.draw()
                canvas_context.font = "20px arial"
                canvas_context.fillStyle = "Black"
                canvas_context.fillText(this.names[this.player.type], this.body.x+10, this.body.y+20)
            }else{
                this.boundingRect.draw()
                if(this.boundingRect.isPointInside(TIP_engine)){
                                const glow = new UiRectangle(this.boundingRect.x, this.boundingRect.y+(Math.floor((TIP_engine.y-this.boundingRect.y)/30)*30), this.boundingRect.width, 30, "#FFFFFF")
                                glow.draw()
                }
                for(let t = 0;t<this.names.length;t++){
                    canvas_context.font = "20px arial"
                    canvas_context.fillStyle = "Black"
                    canvas_context.fillText(this.names[t], this.boundingRect.x+10, this.boundingRect.y+20+(30*t))
                }
            }
        }
    }

    class SetSelector {
        constructor (player){
            this.player = player
            this.menus = []

        }
        draw(){

        }
    }


    class Circle {
        constructor(x, y, radius, color, xmom = 0, ymom = 0, friction = 1, reflect = 0, strokeWidth = 0, strokeColor = "transparent") {
            this.x = x
            this.y = y
            this.radius = radius
            this.color = color
            this.xmom = xmom
            this.ymom = ymom
            this.friction = friction
            this.reflect = reflect
            this.strokeWidth = strokeWidth
            this.strokeColor = strokeColor
        }
        draw() {
            canvas_context.lineWidth = 1
            canvas_context.strokeStyle = this.color
            canvas_context.beginPath();
            if (this.radius > 0) {
                canvas_context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
                canvas_context.fillStyle = this.color
                canvas_context.fill()
                canvas_context.stroke();
            } else {
                //////////console.log("The circle is below a radius of 0, and has not been drawn. The circle is:", this)
            }
        }
        move() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x += this.xmom
            this.y += this.ymom
        }
        unmove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x -= this.xmom
            this.y -= this.ymom
        }
        frictiveMove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x += this.xmom
            this.y += this.ymom
            this.xmom *= this.friction
            this.ymom *= this.friction
        }
        frictiveunMove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.xmom /= this.friction
            this.ymom /= this.friction
            this.x -= this.xmom
            this.y -= this.ymom
        }
        isPointInside(point) {
            this.areaY = point.y - this.y
            this.areaX = point.x - this.x
            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.radius * this.radius)) {
                return true
            }
            return false
        }
        doesPerimeterTouch(point) {
            this.areaY = point.y - this.y
            this.areaX = point.x - this.x
            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= ((this.radius + point.radius) * (this.radius + point.radius))) {
                return true
            }
            return false
        }
    }
    class UnitCircle {
        constructor(x, y, radius, color, xmom = 0, ymom = 0, friction = 1, reflect = 0, strokeWidth = 0, strokeColor = "transparent") {
            this.x = x
            this.y = y
            this.radius = radius
            this.color = color
            this.xmom = xmom
            this.ymom = ymom
            this.friction = friction
            this.reflect = reflect
            this.strokeWidth = strokeWidth
            this.strokeColor = strokeColor
        }
        draw() {
            map_context.lineWidth = this.strokeWidth
            map_context.strokeStyle = this.color
            map_context.beginPath();
            if (this.radius > 0) {
                map_context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
                map_context.fillStyle = this.color
                map_context.fill()
                // map_context.strokeStyle = "#00000010"
            } else {
                //////////console.log("The circle is below a radius of 0, and has not been drawn. The circle is:", this)
            }
        }
        move() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x += this.xmom
            this.y += this.ymom
        }
        unmove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x -= this.xmom
            this.y -= this.ymom
        }
        frictiveMove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x += this.xmom
            this.y += this.ymom
            this.xmom *= this.friction
            this.ymom *= this.friction
        }
        frictiveunMove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.xmom /= this.friction
            this.ymom /= this.friction
            this.x -= this.xmom
            this.y -= this.ymom
        }
        isPointInside(point) {
            this.areaY = point.y - this.y
            this.areaX = point.x - this.x
            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.radius * this.radius)) {
                return true
            }
            return false
        }
        doesPerimeterTouch(point) {
            this.areaY = point.y - this.y
            this.areaX = point.x - this.x
            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= ((this.radius + point.radius) * (this.radius + point.radius))) {
                return true
            }
            return false
        }
    }
    class CircleRing {
        constructor(x, y, radius, color, xmom = 0, ymom = 0, friction = 1, reflect = 0, strokeWidth = 0, strokeColor = "transparent") {
            this.x = x
            this.y = y
            this.radius = radius
            this.color = color
            this.xmom = xmom
            this.ymom = ymom
            this.friction = friction
            this.reflect = reflect
            this.strokeWidth = 10
            this.strokeColor = strokeColor
        }
        draw() {
            canvas_context.lineWidth = this.strokeWidth
            canvas_context.strokeStyle = this.color
            canvas_context.beginPath();
            if (this.radius > 0) {
                canvas_context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
                canvas_context.fillStyle = this.color
                canvas_context.fill()
                canvas_context.stroke();
            } else {
                //////////console.log("The circle is below a radius of 0, and has not been drawn. The circle is:", this)
            }
        }
        move() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x += this.xmom
            this.y += this.ymom
        }
        unmove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x -= this.xmom
            this.y -= this.ymom
        }
        frictiveMove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.x += this.xmom
            this.y += this.ymom
            this.xmom *= this.friction
            this.ymom *= this.friction
        }
        frictiveunMove() {
            if (this.reflect == 1) {
                if (this.x + this.radius > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y + this.radius > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.x - this.radius < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.y - this.radius < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.xmom /= this.friction
            this.ymom /= this.friction
            this.x -= this.xmom
            this.y -= this.ymom
        }
        isPointInside(point) {
            this.areaY = point.y - this.y
            this.areaX = point.x - this.x
            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.radius * this.radius)) {
                return true
            }
            return false
        }
        doesPerimeterTouch(point) {
            this.areaY = point.y - this.y
            this.areaX = point.x - this.x
            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= ((this.radius + point.radius) * (this.radius + point.radius))) {
                return true
            }
            return false
        }
    } class Polygon {
        constructor(x, y, size, color, sides = 3, xmom = 0, ymom = 0, angle = 0, reflect = 0) {
            if (sides < 2) {
                sides = 2
            }
            this.reflect = reflect
            this.xmom = xmom
            this.ymom = ymom
            this.body = new Circle(x, y, size - (size * .293), "transparent")
            this.nodes = []
            this.angle = angle
            this.size = size
            this.color = color
            this.angleIncrement = (Math.PI * 2) / sides
            this.sides = sides
            for (let t = 0; t < sides; t++) {
                const node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
                this.nodes.push(node)
                this.angle += this.angleIncrement
            }
        }
        isPointInside(point) { // rough approximation
            this.body.radius = this.size - (this.size * .293)
            if (this.sides <= 2) {
                return false
            }
            this.areaY = point.y - this.body.y
            this.areaX = point.x - this.body.x
            if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.body.radius * this.body.radius)) {
                return true
            }
            return false
        }
        move() {
            if (this.reflect == 1) {
                if (this.body.x > canvas.width) {
                    if (this.xmom > 0) {
                        this.xmom *= -1
                    }
                }
                if (this.body.y > canvas.height) {
                    if (this.ymom > 0) {
                        this.ymom *= -1
                    }
                }
                if (this.body.x < 0) {
                    if (this.xmom < 0) {
                        this.xmom *= -1
                    }
                }
                if (this.body.y < 0) {
                    if (this.ymom < 0) {
                        this.ymom *= -1
                    }
                }
            }
            this.body.x += this.xmom
            this.body.y += this.ymom
        }
        draw() {
            this.nodes = []
            this.angleIncrement = (Math.PI * 2) / this.sides
            this.body.radius = this.size - (this.size * .293)
            for (let t = 0; t < this.sides; t++) {
                const node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
                this.nodes.push(node)
                this.angle += this.angleIncrement
            }
            canvas_context.strokeStyle = this.color
            canvas_context.fillStyle = this.color
            canvas_context.lineWidth = 0
            canvas_context.beginPath()
            canvas_context.moveTo(this.nodes[0].x, this.nodes[0].y)
            for (let t = 1; t < this.nodes.length; t++) {
                canvas_context.lineTo(this.nodes[t].x, this.nodes[t].y)
            }
            canvas_context.lineTo(this.nodes[0].x, this.nodes[0].y)
            canvas_context.fill()
            canvas_context.stroke()
            canvas_context.closePath()
        }
    }
    class Shape {
        constructor(shapes) {
            this.shapes = shapes
        }
        draw() {
            for (let t = 0; t < this.shapes.length; t++) {
                this.shapes[t].draw()
            }
        }
        isPointInside(point) {
            for (let t = 0; t < this.shapes.length; t++) {
                if (this.shapes[t].isPointInside(point)) {
                    return true
                }
            }
            return false
        }
        doesPerimeterTouch(point) {
            for (let t = 0; t < this.shapes.length; t++) {
                if (this.shapes[t].doesPerimeterTouch(point)) {
                    return true
                }
            }
            return false
        }
        innerShape(point) {
            for (let t = 0; t < this.shapes.length; t++) {
                if (this.shapes[t].doesPerimeterTouch(point)) {
                    return this.shapes[t]
                }
            }
            return false
        }
        isInsideOf(box) {
            for (let t = 0; t < this.shapes.length; t++) {
                if (box.isPointInside(this.shapes[t])) {
                    return true
                }
            }
            return false
        }
        adjustByFromDisplacement(x, y) {
            for (let t = 0; t < this.shapes.length; t++) {
                if (typeof this.shapes[t].fromRatio == "number") {
                    this.shapes[t].x += x * this.shapes[t].fromRatio
                    this.shapes[t].y += y * this.shapes[t].fromRatio
                }
            }
        }
        adjustByToDisplacement(x, y) {
            for (let t = 0; t < this.shapes.length; t++) {
                if (typeof this.shapes[t].toRatio == "number") {
                    this.shapes[t].x += x * this.shapes[t].toRatio
                    this.shapes[t].y += y * this.shapes[t].toRatio
                }
            }
        }
        mixIn(arr) {
            for (let t = 0; t < arr.length; t++) {
                for (let k = 0; k < arr[t].shapes.length; k++) {
                    this.shapes.push(arr[t].shapes[k])
                }
            }
        }
        push(object) {
            this.shapes.push(object)
        }
    }

    class Spring {
        constructor(x, y, radius, color, body = 0, length = 1, gravity = 0, width = 1) {
            if (body == 0) {
                this.body = new Circle(x, y, radius, color)
                this.anchor = new Circle(x, y, radius, color)
                this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
                this.length = length
            } else {
                this.body = body
                this.anchor = new Circle(x, y, radius, color)
                this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
                this.length = length
            }
            this.gravity = gravity
            this.width = width
        }
        balance() {
            this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
            if (this.beam.hypotenuse() < this.length) {
                this.body.xmom += (this.body.x - this.anchor.x) / this.length
                this.body.ymom += (this.body.y - this.anchor.y) / this.length
                this.anchor.xmom -= (this.body.x - this.anchor.x) / this.length
                this.anchor.ymom -= (this.body.y - this.anchor.y) / this.length
            } else {
                this.body.xmom -= (this.body.x - this.anchor.x) / this.length
                this.body.ymom -= (this.body.y - this.anchor.y) / this.length
                this.anchor.xmom += (this.body.x - this.anchor.x) / this.length
                this.anchor.ymom += (this.body.y - this.anchor.y) / this.length
            }
            const xmomentumaverage = (this.body.xmom + this.anchor.xmom) / 2
            const ymomentumaverage = (this.body.ymom + this.anchor.ymom) / 2
            this.body.xmom = (this.body.xmom + xmomentumaverage) / 2
            this.body.ymom = (this.body.ymom + ymomentumaverage) / 2
            this.anchor.xmom = (this.anchor.xmom + xmomentumaverage) / 2
            this.anchor.ymom = (this.anchor.ymom + ymomentumaverage) / 2
        }
        draw() {
            this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
            this.beam.draw()
            this.body.draw()
            this.anchor.draw()
        }
        move() {
            this.anchor.ymom += this.gravity
            this.anchor.move()
        }

    }
    class SpringOP {
        constructor(body, anchor, length, width = 3, color = body.color) {
            this.body = body
            this.anchor = anchor
            this.beam = new LineOP(body, anchor, color, width)
            this.length = length
        }
        balance() {
            if (this.beam.hypotenuse() < this.length) {
                this.body.xmom += ((this.body.x - this.anchor.x) / this.length)
                this.body.ymom += ((this.body.y - this.anchor.y) / this.length)
                this.anchor.xmom -= ((this.body.x - this.anchor.x) / this.length)
                this.anchor.ymom -= ((this.body.y - this.anchor.y) / this.length)
            } else if (this.beam.hypotenuse() > this.length) {
                this.body.xmom -= (this.body.x - this.anchor.x) / (this.length)
                this.body.ymom -= (this.body.y - this.anchor.y) / (this.length)
                this.anchor.xmom += (this.body.x - this.anchor.x) / (this.length)
                this.anchor.ymom += (this.body.y - this.anchor.y) / (this.length)
            }

            const xmomentumaverage = (this.body.xmom + this.anchor.xmom) / 2
            const ymomentumaverage = (this.body.ymom + this.anchor.ymom) / 2
            this.body.xmom = (this.body.xmom + xmomentumaverage) / 2
            this.body.ymom = (this.body.ymom + ymomentumaverage) / 2
            this.anchor.xmom = (this.anchor.xmom + xmomentumaverage) / 2
            this.anchor.ymom = (this.anchor.ymom + ymomentumaverage) / 2
        }
        draw() {
            this.beam.draw()
        }
        move() {
            //movement of SpringOP objects should be handled separate from their linkage, to allow for many connections, balance here with this object, move nodes independently
        }
    }

    class Color {
        constructor(baseColor, red = -1, green = -1, blue = -1, alpha = 1) {
            this.hue = baseColor
            if (red != -1 && green != -1 && blue != -1) {
                this.r = red
                this.g = green
                this.b = blue
                if (alpha != 1) {
                    if (alpha < 1) {
                        this.alpha = alpha
                    } else {
                        this.alpha = alpha / 255
                        if (this.alpha > 1) {
                            this.alpha = 1
                        }
                    }
                }
                if (this.r > 255) {
                    this.r = 255
                }
                if (this.g > 255) {
                    this.g = 255
                }
                if (this.b > 255) {
                    this.b = 255
                }
                if (this.r < 0) {
                    this.r = 0
                }
                if (this.g < 0) {
                    this.g = 0
                }
                if (this.b < 0) {
                    this.b = 0
                }
            } else {
                this.r = 0
                this.g = 0
                this.b = 0
            }
        }
        normalize() {
            if (this.r > 255) {
                this.r = 255
            }
            if (this.g > 255) {
                this.g = 255
            }
            if (this.b > 255) {
                this.b = 255
            }
            if (this.r < 0) {
                this.r = 0
            }
            if (this.g < 0) {
                this.g = 0
            }
            if (this.b < 0) {
                this.b = 0
            }
        }
        randomLight() {
            var letters = '0123456789ABCDEF';
            var hash = '#';
            for (var i = 0; i < 6; i++) {
                hash += letters[(Math.floor(Math.random() * 12) + 4)];
            }
            var color = new Color(hash, 55 + Math.random() * 200, 55 + Math.random() * 200, 55 + Math.random() * 200)
            return color;
        }
        randomDark() {
            var letters = '0123456789ABCDEF';
            var hash = '#';
            for (var i = 0; i < 6; i++) {
                hash += letters[(Math.floor(Math.random() * 12))];
            }
            var color = new Color(hash, Math.random() * 200, Math.random() * 200, Math.random() * 200)
            return color;
        }
        random() {
            var letters = '0123456789ABCDEF';
            var hash = '#';
            for (var i = 0; i < 6; i++) {
                hash += letters[(Math.floor(Math.random() * 16))];
            }
            var color = new Color(hash, Math.random() * 255, Math.random() * 255, Math.random() * 255)
            return color;
        }
    }
    class Softbody { //buggy, spins in place
        constructor(x, y, radius, color, size, members = 10, memberLength = 5, force = 10, gravity = 0) {
            this.springs = []
            this.pin = new Circle(x, y, radius, color)
            this.points = []
            this.flop = 0
            const angle = 0
            this.size = size
            const line = new Line((Math.cos(angle) * size), (Math.sin(angle) * size), (Math.cos(angle + ((Math.PI * 2) / members)) * size), (Math.sin(angle + ((Math.PI * 2) / members)) * size))
            const distance = line.hypotenuse()
            for (let t = 0; t < members; t++) {
                const circ = new Circle(x + (Math.cos(angle) * size), y + (Math.sin(angle) * size), radius, color)
                circ.reflect = 1
                circ.bigbody = new Circle(x + (Math.cos(angle) * size), y + (Math.sin(angle) * size), distance, color)
                circ.draw()
                circ.touch = []
                this.points.push(circ)
                angle += ((Math.PI * 2) / members)
            }

            for (let t = 0; t < this.points.length; t++) {
                for (let k = 0; k < this.points.length; k++) {
                    if (t != k) {
                        if (this.points[k].bigbody.doesPerimeterTouch(this.points[t])) {
                            if (!this.points[k].touch.includes(t) && !this.points[t].touch.includes(k)) {
                                const spring = new SpringOP(this.points[k], this.points[t], (size * Math.PI) / members, 2, color)
                                this.points[k].touch.push(t)
                                this.points[t].touch.push(k)
                                this.springs.push(spring)
                                spring.beam.draw()
                            }
                        }
                    }
                }
            }

            //////////console.log(this)

            // this.spring = new Spring(x, y, radius, color, this.pin, memberLength, gravity)
            // this.springs.push(this.spring)
            // for (let  k = 0; k < members; k++) {
            //     this.spring = new Spring(x, y, radius, color, this.spring.anchor, memberLength, gravity)
            //     if (k < members - 1) {
            //         this.springs.push(this.spring)
            //     } else {
            //         this.spring.anchor = this.pin
            //         this.springs.push(this.spring)
            //     }
            // }
            this.forceConstant = force
            this.centroid = new Circle(0, 0, 10, "red")
        }
        circularize() {
            this.xpoint = 0
            this.ypoint = 0
            for (let s = 0; s < this.springs.length; s++) {
                this.xpoint += (this.springs[s].anchor.x / this.springs.length)
                this.ypoint += (this.springs[s].anchor.y / this.springs.length)
            }
            this.centroid.x = this.xpoint
            this.centroid.y = this.ypoint
            this.angle = 0
            this.angleIncrement = (Math.PI * 2) / this.springs.length
            for (let t = 0; t < this.points.length; t++) {
                this.points[t].x = this.centroid.x + (Math.cos(this.angle) * this.forceConstant)
                this.points[t].y = this.centroid.y + (Math.sin(this.angle) * this.forceConstant)
                this.angle += this.angleIncrement
            }
        }
        balance() {
            this.xpoint = 0
            this.ypoint = 0
            for (let s = 0; s < this.points.length; s++) {
                this.xpoint += (this.points[s].x / this.points.length)
                this.ypoint += (this.points[s].y / this.points.length)
            }
            this.centroid.x = this.xpoint
            this.centroid.y = this.ypoint
            // this.centroid.x += TIP_engine.x / this.points.length
            // this.centroid.y += TIP_engine.y / this.points.length
            for (let s = 0; s < this.points.length; s++) {
                this.link = new LineOP(this.points[s], this.centroid, 0, "transparent")
                if (this.link.hypotenuse() != 0) {

                    if (this.size < this.link.hypotenuse()) {
                        this.points[s].xmom -= (Math.cos(this.link.angle()) * (this.link.hypotenuse())) * this.forceConstant * .1
                        this.points[s].ymom -= (Math.sin(this.link.angle()) * (this.link.hypotenuse())) * this.forceConstant * .1
                    } else {
                        this.points[s].xmom += (Math.cos(this.link.angle()) * (this.link.hypotenuse())) * this.forceConstant * .1
                        this.points[s].ymom += (Math.sin(this.link.angle()) * (this.link.hypotenuse())) * this.forceConstant * .1
                    }

                    // this.points[s].xmom += (((this.points[s].x - this.centroid.x) / (this.link.hypotenuse()))) * this.forceConstant
                    // this.points[s].ymom += (((this.points[s].y - this.centroid.y) / (this.link.hypotenuse()))) * this.forceConstant
                }
            }
            if (this.flop % 2 == 0) {
                for (let s = 0; s < this.springs.length; s++) {
                    this.springs[s].balance()
                }
            } else {
                for (let s = this.springs.length - 1; s >= 0; s--) {
                    this.springs[s].balance()
                }
            }
            for (let s = 0; s < this.points.length; s++) {
                this.points[s].move()
                this.points[s].draw()
            }
            for (let s = 0; s < this.springs.length; s++) {
                this.springs[s].draw()
            }
            this.centroid.draw()
        }
    }
    class Observer {
        constructor(x, y, radius, color, range = 100, rays = 10, angle = (Math.PI * .125)) {
            this.body = new Circle(x, y, radius, color)
            this.color = color
            this.ray = []
            this.rayrange = range
            this.globalangle = Math.PI
            this.gapangle = angle
            this.currentangle = 0
            this.obstacles = []
            this.raymake = rays
        }
        beam() {
            this.currentangle = this.gapangle / 2
            for (let k = 0; k < this.raymake; k++) {
                this.currentangle += (this.gapangle / Math.ceil(this.raymake / 2))
                const ray = new Circle(this.body.x, this.body.y, 1, "white", (((Math.cos(this.globalangle + this.currentangle)))), (((Math.sin(this.globalangle + this.currentangle)))))
                ray.collided = 0
                ray.lifespan = this.rayrange - 1
                this.ray.push(ray)
            }
            for (let f = 0; f < this.rayrange; f++) {
                for (let t = 0; t < this.ray.length; t++) {
                    if (this.ray[t].collided < 1) {
                        this.ray[t].move()
                        for (let q = 0; q < this.obstacles.length; q++) {
                            if (this.obstacles[q].isPointInside(this.ray[t])) {
                                this.ray[t].collided = 1
                            }
                        }
                    }
                }
            }
        }
        draw() {
            this.beam()
            this.body.draw()
            canvas_context.lineWidth = 1
            canvas_context.fillStyle = this.color
            canvas_context.strokeStyle = this.color
            canvas_context.beginPath()
            canvas_context.moveTo(this.body.x, this.body.y)
            for (let y = 0; y < this.ray.length; y++) {
                canvas_context.lineTo(this.ray[y].x, this.ray[y].y)
                canvas_context.lineTo(this.body.x, this.body.y)
            }
            canvas_context.stroke()
            canvas_context.fill()
            this.ray = []
        }
    }
    const globalx = 0
    const uibox = new UiRectangle(0, 0, 1280, 720, "#888888")
    const pausebox = new UiRectangle(0, 0, 1280, 720, "#88888808")

    function roughSizeOfObject(object) {
        var objectList = [];
        var stack = [object];
        var bytes = 0;
        while (stack.length) {
            var value = stack.pop();
            if (typeof value === 'boolean') {
                bytes += 4;
            }
            else if (typeof value === 'string') {
                bytes += value.length * 2;
            }
            else if (typeof value === 'number') {
                bytes += 8;
            }
            else if
                (
                typeof value === 'object'
                && objectList.indexOf(value) === -1
            ) {
                objectList.push(value);

                for (var i in value) {
                    stack.push(value[i]);
                }
            }
        }
        totalbytes+=bytes
        frames+=1
        return bytes;
    }



let drawcount = 0

    function setUp(canvas_pass, style = "#888888") {
        canvas = canvas_pass
        canvas_context = canvas.getContext('2d');
        canvas.style.background = style

        // video_recorder = new CanvasCaptureToWEBM(canvas, 1000000);
        window.setInterval(function () {
            
            if (keysPressed['v']) {
                globalHealthDraw = true
            }
            if (keysPressed['b']) {
                globalHealthDraw = false
            }
            // if (keysPressed['-'] && recording == 0) {
            //     recording = 1
            //     video_recorder.record()
            // }
            // if (keysPressed['='] && recording == 1) {
            //     recording = 0
            //     video_recorder.stop()
            //     video_recorder.download('colddemo.webm')
            // }
            // security.fileuri.strict_origin_policy = true
            // playstart = 1
            if (playstart == 1) {
                if(paused == 1){
                    pausebox.draw()
                    canvas_context.fillStyle = "white"
                    canvas_context.font = "30px Arial"
                    if(controllerSupport==1){
                        canvas_context.fillText("Paused, Click to Unpause, or press Back on the controller", 300, 300)
                        gamepadAPI.update() //checks for button presses/stick movement on the connected controller)
                    }else{
                        canvas_context.fillText("Paused, Click to Unpause", 300, 300)
                    }


                    if(gamepadAPI.buttonPressed('Back')){
                        paused = 0
                    }
                }else{
                    globalframe = 0
                    if(globalframe%3 == 0){

                        let grid = []
                            // for(let h = 0;h<128;h++){
                            //     for(let f = 0;f<128;f++){
                            //         grid.push(0)
                            //     }
                            // }
            for(let t = 0;t<sandmap.players.length;t++){
                if(t == sandmap.turn){
                    for(let k = 0;k<sandmap.players[sandmap.turn].units.length;k++){

                                let unit = sandmap.players[sandmap.turn].units[k]
                                let type = 0

                                if(unit.nymph == 1){type = 1} //9
                                if(unit.scurrier == 1){type = 2} // 8
                                if(unit.imago == 1){type = 3} //10
                                if(unit.gamergate == 1){type = 4} //11

                                if(unit.fruiting == 1){type = 5} //16
                                if(unit.mycoknight == 1){type = 6} //17
                                if(unit.seer == 1){type = 7} //18
                                if(unit.sporevizir == 1){type = 8}

                                if(unit.infantry == 1){type = 9} //0
                                if(unit.sniper == 1){type = 10} //1
                                if(unit.harvester == 1){type = 11} //2
                                if(unit.drone == 1){type = 12} //3

                                if(unit.hamartanscout == 1){type = 13} //4
                                if(unit.hamartanworker == 1){type = 14} //5
                                if(unit.hamartaninvader == 1){type = 15} //6
                                if(unit.hamartansoldier == 1){type = 16}  //7


                                if(unit.pollinator == 1){type = 17} //12
                                if(unit.goliophyte == 1){type = 18} //13
                                if(unit.pufffellow == 1){type = 19} //14
                                if(unit.podman == 1){type = 20}

                                if(unit.buzzlet == 1){type = 21} //12
                                if(unit.flugoon == 1){type = 22} //13
                                if(unit.starbatross == 1){type = 23} //14
                                if(unit.megagnat == 1){type = 24}

                                if(unit.alagadile == 1){type = 25} //12
                                if(unit.bigalagadile == 1){type = 26} //13
                                if(unit.bighunchalagadile == 1){type = 27} //14
                                if(unit.hunchalagadile == 1){type = 28}

                                if(unit.gogonaut == 1){type = 29} //12
                                if(unit.gogonautdefender == 1){type = 30} //13
                                if(unit.gogonautchampion == 1){type = 31} //14
                                if(unit.gogonautteam == 1){type = 32}

                                if(unit.beeworker == 1){type = 33} //12
                                if(unit.beescout == 1){type = 34} //13
                                if(unit.beesoldier == 1){type = 35} //14
                                if(unit.beemega == 1){type = 36}
                                
                                if(unit.targetroid == 1){type = 37} //14
                                if(unit.schlorkupine == 1){type = 38}
                                
                            
                                let walkdeath = (0.5 * (Math.round(unit.walkcounter%26) + unit.movespeedcount) * (Math.round(unit.walkcounter%26) + unit.movespeedcount+ 1)) + unit.movespeedcount
                                let nexttile
                                if(unit.realPath.length-1 > unit.index){
                                 nexttile =  (0.5 * (Math.round(unit.realPath[unit.index+1].t) + unit.realPath[unit.index+1].k) * (Math.round(unit.realPath[unit.index+1].t) + unit.realPath[unit.index+1].k + 1)) + unit.realPath[unit.index+1].k
                                }else{
                                    nexttile =  (0.5 * (Math.round(unit.tile.t) + unit.tile.k) * (Math.round(unit.tile.t) + unit.tile.k + 1)) + unit.tile.k
                                }
                                let nextwalk =  (0.5 * (Math.round(walkdeath) + nexttile) * (Math.round(walkdeath) + nexttile+ 1)) + nexttile

                                let tk = (0.5 * (Math.round(unit.tile.t) + unit.tile.k) * (Math.round(unit.tile.t) + unit.tile.k + 1)) + unit.tile.k
                                let gridvalue = (0.5 * (Math.round(Math.max(unit.health,0)) + type) * (Math.round(Math.max(unit.health,0)) + type + 1)) + type
                                let biggo = (0.5 * (Math.round(gridvalue) + tk) * (Math.round(gridvalue) + tk + 1)) + tk
                                // let biggox = (0.5 * (Math.round(biggo) + walkdeath) * (Math.round(biggo) + walkdeath + 1)) + walkdeath
                                biggo+=unit.id    //Math.floor(unit.id*1000)/1000
                                // if(unit.sent != 1 || unit.health <= 0){
                                //////////console.log(biggo)
                                grid.push({d:biggo, w:nextwalk})
                                // }

                    }
                        //////////console.log("checking")
                    if(sandmap.players[sandmap.turn].sendBuildings >= 1){
                        //////////console.log("sending")
                    // sandmap.players[sandmap.turn].sendBuildings = -10
                    for(let k = 0;k<sandmap.players[sandmap.turn].buildings.length;k++){

                                let unit = sandmap.players[sandmap.turn].buildings[k]

                                let type = 0

                                if(unit.wall == 1){type = 0 + 1} //9
                                if(unit.barracks == 1){type = 0 + 2} // 8
                                if(unit.barracks == 2){type = 0 + 3} //10
                                if(unit.gate == 1){type = 0 + 4} //11

                                if(unit.slime == 1){type = 0 + 5} //16
                                if(unit.sporeball == 1){type = 0 + 6} //17

                                if(unit.spire == 1){type = 0 + 7} //4
                                if(unit.assembler == 1){type = 0 + 8} //5
                                if(unit.assembler == 2){type = 0 + 9} //6
                                if(unit.assembler == 3){type = 0 + 10}  //7

                                if(unit.bulbplant == 1){type = 0 + 11} //12
                                if(unit.bulbplant == 2){type = 0 + 12} //13

                                if(unit.mound == 1){type = 0 + 13} //12
                                if(unit.egg == 1){type = 0 + 14} //13

                                if(unit.pond == 1){type = 0 + 15} //12

                                if(unit.tree == 1){type = 0 + 16} //12

                                if(unit.beehive == 1){type = 0 + 17} //12
                                if(unit.teleporter == 1){type = 0 + 18} //12


                                let walkdeath = -1// (0.5 * (Math.round(unit.movespeedcount) + unit.dying) * (Math.round(unit.movespeedcount) + unit.dying+ 1)) + unit.dying
                                let tk = (0.5 * (Math.round(unit.tile.t) + unit.tile.k) * (Math.round(unit.tile.t) + unit.tile.k + 1)) + unit.tile.k
                                let gridvalue = (0.5 * (Math.round(Math.max(unit.health,0)) + type) * (Math.round(Math.max(unit.health,0)) + type + 1)) + type
                                let biggo = (0.5 * (Math.round(gridvalue) + tk) * (Math.round(gridvalue) + tk + 1)) + tk
                                //////////console.log(tk, biggo, gridvalue, unit.tile.t, unit.tile.k, walkdeath, unit.id, type)
                              // let biggox = (0.5 * (Math.round(biggo) + walkdeath) * (Math.round(biggo) + walkdeath + 1)) + walkdeath
                                // biggo+=unit.id    //Math.floor(unit.id*1000)/1000
                                //////////console.log(unit.id)
                                //////////console.log(biggo)
                                // if(unit.sent != 1 || unit.health <= 0){
                                //////////console.log(biggo)
                                //////////console.log(biggo)
                                //////////console.log({data:biggo, walk:walkdeath})
                                //////console.log({d:biggo*walkdeath, w:unit.id+unit.dying})
                                grid.push({d:biggo*walkdeath, w:unit.id+unit.dying})
                                // }

                    }
                    }else{
                        sandmap.players[sandmap.turn].sendBuildings++
                    }

                        let Json = {}
                        Json.array = [...grid]
                        Json.map = mapindex
                        Json.mapsize = worldscale
                        Json.unitcap = unitcap
                        Json.grid = 2
                        Json.player = t
                        // roughSizeOfObject(Json)
                        if(campaignController.on !== 1 && AImode != 1){
                        ws.send(JSON.stringify(Json))
                        }
                        grid = []
                }
            }



                }
                    }
                // globalx++
                // const img2 = new Image();
                // img2.src = map_canvas.toDataURL("image/png");
                // // document.body.appendChild(img2);
                // const link = document.createElement("a");
                // link.download = `coldmap${globalx}.png`
                // map_canvas.toBlob(function(blob) {
                //   link.href = URL.createObjectURL(blob);
                //     link.click();
                // }, "image/png");
                    main()
            } else {

                canvas_context.clearRect(0, 0, canvas.width, canvas.height)  // refreshes the image

                playbutton.draw()
                if (playstart == 0) {
                    canvas_context.drawImage(startupart, 0, 0)

                    playbutton.draw()
                    const invscale = 1
                    const string = "In the far flung Itzler star-system, on the sixth planet out, thought to be well beyond the habitable zone of Itzler, the planet Cold Itzler as it has come to be known is the only source of the miracle compound 'hotrock'. Hotrock makes life on Cold Itzler possible."
                    let ypointer = 50
                    let xpointer = 10
                    canvas_context.font = "50px Arial";
                    canvas_context.fillStyle = "#FFFFFF"
                    const stoarr = string.split(' ')
                    let stostring = ''
                    for (let t = 0; t < stoarr.length; t++) {
                        const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                        if (width > canvas.width * invscale * .821) {
                            canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                            ypointer += 60
                            stostring = ''
                        } else {
                            stostring = stostring + " " + stoarr[t]
                            if (t == stoarr.length - 1) {
                                canvas_context.fillText(stostring, xpointer, ypointer)
                            }
                        }
                    }
                    canvas_context.font = "40px Arial";
                    canvas_context.fillStyle = "#FFFFFF"
                    canvas_context.fillText("Continue", playbutton.x + 15, playbutton.y + 50)
                }
                if (playstart == 2) {

                    canvas_context.drawImage(startupart, 0, 0)

                    playbutton.draw()
                    const invscale = 1
                    const string = "You must choose, to defend your home planet as the Cold Itzlerians, to pillage the icy rock for all it's worth as the Earthoids, to replenish your armada on your nomadic voyage as the Hamartans, to steal the water from the soil as the Librilbians, or to spread your influence as the Plaztilites."
                    let ypointer = 50
                    let xpointer = 10
                    canvas_context.font = "50px Arial";
                    canvas_context.fillStyle = "#FFFFFF"
                    const stoarr = string.split(' ')
                    let stostring = ''
                    for (let t = 0; t < stoarr.length; t++) {
                        const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                        if (width > canvas.width * invscale * .821) {
                            canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                            ypointer += 60
                            stostring = ''
                        } else {
                            stostring = stostring + " " + stoarr[t]
                            if (t == stoarr.length - 1) {
                                canvas_context.fillText(stostring, xpointer, ypointer)
                            }
                        }
                    }

                    canvas_context.font = "40px Arial";
                    canvas_context.fillStyle = "#FFFFFF"
                    canvas_context.fillText("Continue", playbutton.x + 15, playbutton.y + 50)

                }
                if (playstart == 3) {

                    canvas_context.drawImage(startupart, 0, 0)

                    campaignController.draw()

                    if (campaignController.on == 1) {

                    } else {
                    if(onlineNow != 1 && (swap.stop != 1 &&swap2.stop != 1 &&swap3.stop != 1 &&swap4.stop != 1)){
                        mapSizer.draw()
                        unitCapper.draw()
                        mapChooser.draw()
                    }
                        controlToggle.draw()


                    if(onlineNow != 1  && (swap.stop != 1 &&swap2.stop != 1 &&swap3.stop != 1 &&swap4.stop != 1)){
                        canvas_context.font = "40px Arial";
                        canvas_context.fillStyle = "#FFFFFF"
                        canvas_context.fillText("Map: " + `${maplistnames[mapindex]}`, mapChooser.x + 30, mapChooser.y + 50)

                        canvas_context.font = "40px Arial";
                        canvas_context.fillStyle = "#FFFFFF"
                        canvas_context.fillText("Unit Cap: " + `${unitcap}`, unitCapper.x + 30, unitCapper.y + 50)

                        canvas_context.font = "40px Arial";
                        canvas_context.fillStyle = "#FFFFFF"
                        canvas_context.fillText("Map Size: " + `${worldscale}`, mapSizer.x + 25, mapSizer.y + 50)
                    }
                        canvas_context.font = "40px Arial";
                        canvas_context.fillStyle = "#FFFFFF"
                        if(controllerSupport == 0){
                            canvas_context.fillText("Controller play OFF", controlToggle.x + 25, controlToggle.y + 50)
                        }else{
                            canvas_context.fillText("Controller play ON", controlToggle.x + 25, controlToggle.y + 50)
                        }
                    if(onlineNow != 1 && (swap.stop != 1 &&swap2.stop != 1 &&swap3.stop != 1 &&swap4.stop != 1)){
                        canvas_context.font = "10px Arial";
                        canvas_context.fillStyle = "#FFFFFF"
                        canvas_context.fillText("*Adjusting Map Size will take a moment for 256", mapSizer.x + 25, mapSizer.y + 70)
                    }

                        guideplus.draw()
                        if(sandmap.turn != -1){
                        playbutton.draw()
                        canvas_context.font = "40px Arial";
                        canvas_context.fillStyle = "#FFFFFF"
                        canvas_context.fillText("Start", playbutton.x + 35, playbutton.y + 50)
                        }
                        swap.draw()
                        swap2.draw()
                        swap3.draw()
                        swap4.draw()
                        if(swap.stop == 1 || swap2.stop == 1 || swap3.stop == 1 || swap4.stop == 1){
                            
                        }else{
                            AImodeButton.draw()
                            if(AImode == 0){
                                canvas_context.font = "20px Arial";
                                canvas_context.fillStyle = "#FFFFFF"
                                canvas_context.fillText("Offline AI", AImodeButton.x + 5, AImodeButton.y + 40)
                            }else{
                                canvas_context.font = "20px Arial";
                                canvas_context.fillStyle = "#FFFFFF"
                                canvas_context.fillText("Go Online", AImodeButton.x + 5, AImodeButton.y + 40)
                            }
                        }

                        canvas_context.font = "20px Arial";
                        canvas_context.fillStyle = "#000000"
                        canvas_context.fillText(swap.text, swap.x + 5, swap.y + 25)
                        canvas_context.fillText(swap2.text, swap2.x + 5, swap2.y + 25)
                        canvas_context.fillText(swap3.text, swap3.x + 5, swap3.y + 25)
                        canvas_context.fillText(swap4.text, swap4.x + 5, swap4.y + 25)

                        const invscale = 1
                        const string = "Click the buttons to set up the match."
                        let ypointer = 50
                        let xpointer = 10
                        canvas_context.font = "50px Arial";
                        canvas_context.fillStyle = "#FFFFFF"
                        const stoarr = string.split(' ')
                        let stostring = ''
                        for (let t = 0; t < stoarr.length; t++) {
                            const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                            if (width > canvas.width * invscale * .821) {
                                canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                ypointer += 60
                                stostring = ''
                            } else {
                                stostring = stostring + " " + stoarr[t]
                                if (t == stoarr.length - 1) {
                                    canvas_context.fillText(stostring, xpointer, ypointer)
                                }
                            }
                        }
                        canvas_context.font = "40px Arial";
                        canvas_context.fillStyle = "#FFFFFF"
                        canvas_context.fillText("Guide", guideplus.x + 35, guideplus.y + 50)
                        // aitoggle1.draw()
                        // aitoggle2.draw()

                        canvas_context.fillStyle = "#FFFFFF"
                        canvas_context.font = "20px Arial";
                        canvas_context.fillText("(You)", chartoggle1.body.x +50 +(sandmap.turn*270), chartoggle1.body.y + 90)
                        // canvas_context.fillStyle = "#FFFFFF"
                        // canvas_context.fillText("(Factions)", chartoggle1.body.x -100, chartoggle1.body.y+20 )
                        // canvas_context.fillStyle = "#FFFFFF"
                        // canvas_context.fillText("(Difficulty)", chartoggle1.body.x -100, chartoggle1.body.y - 30)
                        if(sandmap.turn == 0 || AImode == 1){
                        chartoggle1.draw(0)
                        difftoggle1.draw(0)
                        }
                        if(sandmap.turn == 1 || AImode == 1){
                        chartoggle2.draw(1)
                        difftoggle2.draw(1)
                        }
                         if(sandmap.turn == 2 || AImode == 1){
                        chartoggle3.draw(2)
                        difftoggle3.draw(2)
                         }
                             if(sandmap.turn == 3 || AImode == 1){
                        chartoggle4.draw(3)
                        difftoggle4.draw(3)
                             }
                        // if (sandmap.players[1].isAI == 1) {
                            // canvas_context.font = "30px Arial";
                            // canvas_context.fillStyle = "#FFFFFF"
                            // if (dynamic2 == 1) {
                            //     canvas_context.fillText(`Power: Dynamic (?)`, difftoggle2.x + 10, difftoggle2.y + 50)
                            // } else if (sandmap.players[1].clickrate == 1) {
                            //     canvas_context.fillText(`Power: Absolute-Zero (11)`, difftoggle2.x + 10, difftoggle2.y + 50)
                            // } else if (sandmap.players[1].clickrate == 2) {
                            //     canvas_context.fillText(`Power: Bone-Chilling (10)`, difftoggle2.x + 10, difftoggle2.y + 50)
                            // } else if (sandmap.players[1].clickrate == 5) {
                            //     canvas_context.fillText(`Power: Frigid (9)`, difftoggle2.x + 10, difftoggle2.y + 50)
                            // } else if (sandmap.players[1].clickrate == 10) {
                            //     canvas_context.fillText(`Power: Frosty (8)`, difftoggle2.x + 10, difftoggle2.y + 50)
                            // } else if (sandmap.players[1].clickrate == 15) {
                            //     canvas_context.fillText(`Power: Sweater-Weather (7)`, difftoggle2.x + 10, difftoggle2.y + 50)
                            // } else if (sandmap.players[1].clickrate == 25) {
                            //     canvas_context.fillText(`Power: Cold (6)`, difftoggle2.x + 10, difftoggle2.y + 50)
                            // } else if (sandmap.players[1].clickrate == 35) {
                            //     canvas_context.fillText(`Power: Chilly (5)`, difftoggle2.x + 10, difftoggle2.y + 50)
                            // } else if (sandmap.players[1].clickrate == 50) {
                            //     canvas_context.fillText(`Power: Drafty (4)`, difftoggle2.x + 10, difftoggle2.y + 50)
                            // } else if (sandmap.players[1].clickrate == 100) {
                            //     canvas_context.fillText(`Power: Room-Temperature (3)`, difftoggle2.x + 10, difftoggle2.y + 50)
                            // } else if (sandmap.players[1].clickrate == 200) {
                            //     canvas_context.fillText(`Power: Warm (2)`, difftoggle2.x + 10, difftoggle2.y + 50)
                            // } else if (sandmap.players[1].clickrate == 400) {
                            //     canvas_context.fillText(`Power: Toasty (1)`, difftoggle2.x + 10, difftoggle2.y + 50)
                            // }
                        // }
                        // if (sandmap.players[0].isAI == 1) {
                        //     canvas_context.font = "30px Arial";
                        //     canvas_context.fillStyle = "#FFFFFF"
                        //     if (dynamic1 == 1) {
                        //         canvas_context.fillText(`Power: Dynamic (?)`, difftoggle1.x + 10, difftoggle1.y + 50)
                        //     } else if (sandmap.players[0].clickrate == 1) {
                        //         canvas_context.fillText(`Power: Absolute-Zero (11)`, difftoggle1.x + 10, difftoggle1.y + 50)
                        //     } else if (sandmap.players[0].clickrate == 2) {
                        //         canvas_context.fillText(`Power: Bone-Chilling (10)`, difftoggle1.x + 10, difftoggle1.y + 50)
                        //     } else if (sandmap.players[0].clickrate == 5) {
                        //         canvas_context.fillText(`Power: Frigid (9)`, difftoggle1.x + 10, difftoggle1.y + 50)
                        //     } else if (sandmap.players[0].clickrate == 10) {
                        //         canvas_context.fillText(`Power: Frosty (8)`, difftoggle1.x + 10, difftoggle1.y + 50)
                        //     } else if (sandmap.players[0].clickrate == 15) {
                        //         canvas_context.fillText(`Power: Sweater-Weather (7)`, difftoggle1.x + 10, difftoggle1.y + 50)
                        //     } else if (sandmap.players[0].clickrate == 25) {
                        //         canvas_context.fillText(`Power: Cold (6)`, difftoggle1.x + 10, difftoggle1.y + 50)
                        //     } else if (sandmap.players[0].clickrate == 35) {
                        //         canvas_context.fillText(`Power: Chilly (5)`, difftoggle1.x + 10, difftoggle1.y + 50)
                        //     } else if (sandmap.players[0].clickrate == 50) {
                        //         canvas_context.fillText(`Power: Drafty (4)`, difftoggle1.x + 10, difftoggle1.y + 50)
                        //     } else if (sandmap.players[0].clickrate == 100) {
                        //         canvas_context.fillText(`Power: Room-Temperature (3)`, difftoggle1.x + 10, difftoggle1.y + 50)
                        //     } else if (sandmap.players[0].clickrate == 200) {
                        //         canvas_context.fillText(`Power: Warm (2)`, difftoggle1.x + 10, difftoggle1.y + 50)
                        //     } else if (sandmap.players[0].clickrate == 400) {
                        //         canvas_context.fillText(`Power: Toasty (1)`, difftoggle1.x + 10, difftoggle1.y + 50)
                        //     }
                        // }
                        // canvas_context.font = "40px Arial";
                        // canvas_context.fillStyle = "#FFFFFF"
                        // canvas_context.fillText(sandmap.players[0].name, chartoggle1.x + 15, chartoggle1.y + 50)
                        // canvas_context.fillText(sandmap.players[1].name, chartoggle2.x + 15, chartoggle2.y + 50)
                        // canvas_context.font = "40px Arial";
                        // canvas_context.fillStyle = "#FFFFFF"
                        // canvas_context.fillText("(Enemy)", chartoggle2.x + 350, chartoggle2.y + 50)
                        // canvas_context.font = "40px Arial";
                        // canvas_context.fillStyle = "#FFFFFF"
                        // if (sandmap.players[0].isAI == 1) {
                        //     canvas_context.fillText("CPU control", aitoggle1.x + 15, aitoggle1.y + 50)
                        // } else {
                        //     canvas_context.fillText("Manual control", aitoggle1.x + 15, aitoggle1.y + 50)
                        // }
                        // if (sandmap.players[1].isAI == 1) {
                        //     canvas_context.fillText("CPU control", aitoggle2.x + 15, aitoggle1.y + 50)
                        // } else {
                        //     canvas_context.fillText("Manual control", aitoggle2.x + 15, aitoggle2.y + 50)
                        // }
                    }

                }
                if (playstart == 4) {
                    canvas_context.drawImage(startupart, 0, 0)
                    // mapSizer.draw()
                    guideplus.draw()
                    playbutton.draw()
                    canvas_context.font = "40px Arial";
                    canvas_context.fillStyle = "#FFFFFF"
                    canvas_context.fillText("Back", playbutton.x + 35, playbutton.y + 50)
                    canvas_context.font = "40px Arial";
                    canvas_context.fillStyle = "#FFFFFF"
                    if (manual < 11) {
                        canvas_context.fillText("Next", guideplus.x + 35, guideplus.y + 50)
                    } else {
                        canvas_context.fillText("Again", guideplus.x + 35, guideplus.y + 50)
                    }
                    if (manual == 0) {
                        if (true) {
                            const invscale = 1
                            const string = "Click and drag to select your units."
                            let ypointer = 50
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .821) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }

                        }
                        if (true) {
                            const invscale = 1
                            const string = "Direct selected units by right-clicking. "
                            let ypointer = 150
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .821) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }

                        }
                        if (true) {
                            const invscale = 1
                            const string = "Use the minimap to navigate the large map, or WASD."
                            let ypointer = 250
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .821) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }

                        }
                        if (true) {
                            const invscale = 1
                            const string = "Brown piles are hotrock, you can harvest them with any unit by standing on the tile."
                            let ypointer = 350
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }

                        }
                    } else if (manual == 1) {
                        canvas_context.drawImage(humanfacesintro, 0, 0, 256, 64, 1280 - 512, 720 - 128, 512, 128)

                        if (true) {
                            const invscale = 1
                            const string = "As humans. hold Q and click a tile to build a wall, hold X and click a wall to remove it."
                            let ypointer = 50
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .951) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }

                        }
                        if (true) {
                            const invscale = 1
                            const string = "Hold R and click a tile to build a gate, gates can open and closed for units to pass."
                            let ypointer = 100
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .821) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }

                        }
                        if (true) {
                            const invscale = 1
                            const string = "Hold C and click a tile to build a barracks. Click it to select it to make infantry and snipers using the UI."
                            let ypointer = 150
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .821) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }

                        }
                        if (true) {
                            const invscale = 1
                            const string = "Hold E and click a tile to build a machine lab. Click it to select it to make scout drones and harvesters using the UI."
                            let ypointer = 250
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }

                        }
                        if (true) {
                            const invscale = 1
                            const string = "Humans will freeze to death without wind barrier walls. The wind speed may increase, making survival difficult."
                            let ypointer = 350
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }

                        if (true) {
                            const invscale = 1
                            const string = "Difficulty: High."
                            let ypointer = 450
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                    } else if (manual == 2) {

                        canvas_context.drawImage(coldintro, 0, 0, 256, 64, 1280 - 512, 720 - 128, 512, 128)
                        if (true) {
                            const invscale = 1
                            const string = "As Cold Itzlerians. units can metamorphose into stronger units, this is controlled by clicking the buttons in the UI. Cold Itzlerians are immune to cold."
                            let ypointer = 50
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "Nymphs are effective gathering units, but weak in combat."
                            let ypointer = 150
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }

                        if (true) {
                            const invscale = 1
                            const string = "Difficulty: Low."
                            let ypointer = 450
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                    } else if (manual == 3) {

                        canvas_context.drawImage(hamintro, 0, 0, 256, 64, 1280 - 512, 720 - 128, 512, 128)
                        if (true) {
                            const invscale = 1
                            const string = "As the Hamartans, you must condition your air for breathing. "
                            let ypointer = 50
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "hold Q and click to build a spire to condition the air."
                            let ypointer = 120
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }

                        if (true) {
                            const invscale = 1
                            const string = "Hold C and click for a soldier assembler."
                            let ypointer = 190
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }

                        if (true) {
                            const invscale = 1
                            const string = "Hold E and click for a scout assembler."
                            let ypointer = 260
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "Hold R and click for a 'high-caste' assembler where workers and invaders are made."
                            let ypointer = 330
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "Difficulty: Medium."
                            let ypointer = 450
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                    } else if (manual == 4) {
                        canvas_context.drawImage(bibiintro, 0, 0, 256, 64, 1280 - 512, 720 - 128, 512, 128)

                        if (true) {
                            const invscale = 1
                            const string = "As the Librilbians:"
                            let ypointer = 50
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "Hold C and click to plant a bulbplant, it can seed pollinators, your core gathering unit."
                            let ypointer = 110
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "Hold E and click to plant a podmother, it can create fighting units."
                            let ypointer = 170
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "The podmother can only be planted on soil (within range of the bulbplant)."
                            let ypointer = 230
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "Difficulty: Medium."
                            let ypointer = 450
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                    } else if (manual == 5) {
                        canvas_context.drawImage(funintro, 0, 0, 256, 64, 1280 - 512, 720 - 128, 512, 128)

                        if (true) {
                            const invscale = 1
                            const string = "As the Plaztilites, your units are poor harvesters."
                            let ypointer = 50
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "Hold C and click to place a sporeball, it acts as a hub for your gathering slime pathways."
                            let ypointer = 110
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "hold Q and click/drag to create slime pathways to collect hotrock, slime can also create fighting units."
                            let ypointer = 170
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "To collect hotrock, slime pathways must cover the pile, and connect orthagonally all the way to a sporeball, diagonally is not sufficient."
                            let ypointer = 270
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "Difficulty: Intense."
                            let ypointer = 450
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                    }else if (manual == 6) {
                        canvas_context.drawImage(aveintro, 0, 0, 256, 64, 1280 - 512, 720 - 128, 512, 128)

                        if (true) {
                            const invscale = 1
                            const string = "As the Avesectians, your eggmounds produce eggs."
                            let ypointer = 50
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "hold Q and click to place a eggmound, it acts as a hub for your egg production."
                            let ypointer = 110
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "Buzzlets and Megagnats are superior harvesters."
                            let ypointer = 170
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "Eggs can hatch into any avesectian unit."
                            let ypointer = 270
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "Difficulty: Low."
                            let ypointer = 450
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                    } else if (manual == 7) {
                        canvas_context.drawImage(schlorkupineface, 0, 0, 64, 64, 1280 - 512, 720 - 128, 128, 128)

                        if (true) {
                            const invscale = 1
                            const string = "As the Schlorkupine, you are alone."
                            let ypointer = 50
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "Use QECR to upgrade the Schlorkupine."
                            let ypointer = 110
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "You reflect some incoming damage. Upgrading defense increases the damage you reflect."
                            let ypointer = 170
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "Maximizing harvesting will lead to better offense."
                            let ypointer = 270
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "Difficulty: Low."
                            let ypointer = 450
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                    } else if (manual == 8) {
                        canvas_context.drawImage(targetroidface, 0, 0, 64, 64, 1280 - 512, 720 - 128, 128, 128)

                        if (true) {
                            const invscale = 1
                            const string = "As the Targetroid, you are hunter and hunted, working alone."
                            let ypointer = 50
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "Use QECR to upgrade the Targetroid."
                            let ypointer = 110
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "You have extreme potential."
                            let ypointer = 170
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "Maximizing harvesting will lead to better offense."
                            let ypointer = 270
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "Difficulty: Very Low."
                            let ypointer = 450
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                    } else if (manual == 9) {
                        canvas_context.drawImage(gogonautfaces, 0, 0, 256, 64, 1280 - 512, 720 - 128, 512, 128)

                        if (true) {
                            const invscale = 1
                            const string = "As the Gogonauts. hold Q and click a tile to plant a Gogonaut tree."
                            let ypointer = 50
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "The Gogonaut tree can be used to make units."
                            let ypointer = 110
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "Difficulty: Very Low."
                            let ypointer = 450
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                    } else if (manual == 10) {
                        canvas_context.drawImage(alagadilefaces, 0, 0, 256, 64, 1280 - 512, 720 - 128, 512, 128)

                        if (true) {
                            const invscale = 1
                            const string = "As the Alagadiles. hold Q and click a tile to dig an Alagadile pond."
                            let ypointer = 50
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "The Alagadile pond can be used to make units."
                            let ypointer = 110
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "The Alagadile units are low-cost, strong, but very slow."
                            let ypointer = 270
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "Building a Teleporter with E, can prove to be a good investment."
                            let ypointer = 370
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "Difficulty: High."
                            let ypointer = 450
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                    } else if (manual == 11) {
                        // canvas_context.drawImage(beeplefaces, 0, 0, 256, 64, 1280 - 512, 720 - 128, 512, 128)

                        if (true) {
                            const invscale = 1
                            const string = "As the Beeple. hold Q and click a tile to make a Beeple hive."
                            let ypointer = 50
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "The Beeple hive can be used to make units."
                            let ypointer = 110
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "The Beeple hive is expensive, and very difficult for foes to destroy."
                            let ypointer = 270
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "Beeple move faster in groups, because they keep each other warm."
                            let ypointer = 320
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "The Beeple scouts are very good scouts."
                            let ypointer = 370
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                        if (true) {
                            const invscale = 1
                            const string = "Difficulty: Very Low."
                            let ypointer = 450
                            let xpointer = 10
                            canvas_context.font = "30px Arial";
                            canvas_context.fillStyle = "#FFFFFF"
                            const stoarr = string.split(' ')
                            let stostring = ''
                            for (let t = 0; t < stoarr.length; t++) {
                                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                                if (width > canvas.width * invscale * .921) {
                                    canvas_context.fillText(stostring + ' ' + stoarr[t], xpointer, ypointer)
                                    ypointer += 35
                                    stostring = ''
                                } else {
                                    stostring = stostring + " " + stoarr[t]
                                    if (t == stoarr.length - 1) {
                                        canvas_context.fillText(stostring, xpointer, ypointer)
                                    }
                                }
                            }
                        }
                    } 
                }
            }
            
        }, 25) //10 before fog nerf //17 still too fast lmao
        document.addEventListener('keydown', (event) => {
            if (typeof keysPressed[event.key] == "undefined") {
                keysPressed[event.key] = true;
            }
        });
        document.addEventListener('keyup', (event) => {
            delete keysPressed[event.key];
        });

        canvas.addEventListener('contextmenu', e => {
            //////////console.log(e)
            qflag = 0
            pflag = 0
            e.preventDefault()
            FLEX_engine = canvas.getBoundingClientRect();
            XS_engine = e.clientX - FLEX_engine.left;
            YS_engine = e.clientY - FLEX_engine.top;
            TIP_engine.x = XS_engine
            TIP_engine.y = YS_engine
            TIP_engine.body = TIP_engine
            if (TIP_engine.x <= sandmap.window.body.x + sandmap.window.body.width) {

                const structuredpoint = new Point(0, 0)
                structuredpoint.x += sandmap.window.guide.x
                structuredpoint.y += sandmap.window.guide.y
                structuredpoint.x += (TIP_engine.x * .5)
                structuredpoint.y += (TIP_engine.y * .5)
                structuredpoint.x = Math.floor(structuredpoint.x * .1)
                structuredpoint.y = Math.floor(structuredpoint.y * .1)
                sandmap.players[sandmap.turn].selected_tile = sandmap.blocks[structuredpoint.x][structuredpoint.y]
                // sandmap.turn++
                sandmap.turn %= sandmap.players.length

                const dummy = {}
                dummy.x = 0
                dummy.y = 0
                let count = 0
                for (let t = 0; t < sandmap.players[sandmap.turn].units.length; t++) {
                    if (sandmap.players[sandmap.turn].units[t].selected == 1) {
                        dummy.x += sandmap.players[sandmap.turn].units[t].tile.x
                        dummy.y += sandmap.players[sandmap.turn].units[t].tile.y
                        count++
                    }
                }
                dummy.x /= count
                dummy.y /= count

                let cout = spiral(count)
                let freespace = Math.max(Math.abs(cout[0]), Math.abs(cout[1]))
                if (structuredpoint.x - freespace < 0) {
                    structuredpoint.x += Math.abs(structuredpoint.x - freespace) - 1
                }
                if (structuredpoint.y - freespace < 0) {
                    structuredpoint.y += Math.abs(structuredpoint.y - freespace) - 1
                }
                if (structuredpoint.x - freespace > (worldscale - 1)) {
                    structuredpoint.x -= Math.abs(structuredpoint.x - freespace) - 1
                }
                if (structuredpoint.y - freespace > (worldscale - 1)) {
                    structuredpoint.y -= Math.abs(structuredpoint.y - freespace) - 1
                }
                let dist = Math.max(Math.floor(Math.sqrt(count)) - 2, 1)
                let distcap = dist
                dist = 0
                let mcount = 0

                //////////console.log("2")
                for (let t = 0; t < sandmap.players[sandmap.turn].buildings.length; t++) {
                    if (sandmap.players[sandmap.turn].buildings[t].selected == 1) {
                        // sandmap.players[sandmap.turn].buildings[t].selected = 2
                        sandmap.players[sandmap.turn].buildings[t].waypoint = (sandmap.players[sandmap.turn].selected_tile)
                    }
                }

                for (let t = 0; t < sandmap.players[sandmap.turn].units.length; t++) {
                    if (sandmap.players[sandmap.turn].units[t].selected == 1) {

                        if (e.button == 0) {
                            sandmap.players[sandmap.turn].units[t].selected = 2
                        }
                        let xdiff
                        let ydiff
                        let mout = spiral(mcount - 1)
                        if (mcount > 0) {

                            xdiff = mout[0] // Math.min(Math.max(Math.floor((dummy.x - sandmap.players[sandmap.turn].units[t].tile.x) * .1), -dist), dist)
                            ydiff = mout[1] //Math.min(Math.max(Math.floor((dummy.y - sandmap.players[sandmap.turn].units[t].tile.y) * .1), -dist), dist)

                        } else {

                            xdiff = 0//  Math.min(Math.max(Math.floor((dummy.x - sandmap.players[sandmap.turn].units[t].tile.x) * .1), -dist), dist)
                            ydiff = 0// Math.min(Math.max(Math.floor((dummy.y - sandmap.players[sandmap.turn].units[t].tile.y) * .1), -dist), dist)
                            sandmap.players[sandmap.turn].selected_tile_center = sandmap.blocks[Math.min(Math.max(structuredpoint.x - xdiff, 0), (worldscale - 1))][Math.min(Math.max(structuredpoint.y - ydiff, 0), (worldscale - 1))]
                        }

                        sandmap.players[sandmap.turn].selected_tile = sandmap.blocks[Math.min(Math.max(structuredpoint.x - xdiff, 0), (worldscale - 1))][Math.min(Math.max(structuredpoint.y - ydiff, 0), (worldscale - 1))]
                        //

                        //////////console.log(sandmap.players[sandmap.turn].selected_tile)
                        if (keysPressed['Shift'] || sandmap.players[sandmap.turn].units[t].patrolling == 1) {
                            if (sandmap.players[sandmap.turn].units[t].pathQue.length > 0) {
                                sandmap.players[sandmap.turn].units[t].emergencyTarget = (sandmap.players[sandmap.turn].selected_tile)
                                sandmap.players[sandmap.turn].units[t].selmag = count
                                sandmap.players[sandmap.turn].units[t].pathQue.push(sandmap.players[sandmap.turn].units[t].emergencyTarget)
                            } else {
                                sandmap.players[sandmap.turn].units[t].emergencyTarget = (sandmap.players[sandmap.turn].selected_tile)
                                sandmap.players[sandmap.turn].units[t].selmag = count
                                sandmap.players[sandmap.turn].units[t].pathQue.push(sandmap.players[sandmap.turn].units[t].emergencyTarget)
                                if (sandmap.players[sandmap.turn].units[t].patrolling == 1) {
                                    sandmap.players[sandmap.turn].units[t].pathQue.push(sandmap.players[sandmap.turn].units[t].tile)
                                }
                                //////////console.log(sandmap.players[sandmap.turn].units[t].pathQue)
                            }
                        } else {
                            sandmap.players[sandmap.turn].units[t].emergencyTarget = (sandmap.players[sandmap.turn].selected_tile)
                            sandmap.players[sandmap.turn].units[t].selmag = count
                            sandmap.players[sandmap.turn].units[t].pathNow = 1
                            sandmap.players[sandmap.turn].units[t].pathQue = []
                        }
                        playPathSound(sandmap.players[sandmap.turn].units[t], sandmap.players[sandmap.turn].selected_tile)

                        for (let k = 0; k < sandmap.players[Math.abs(sandmap.turn - 1)].units.length; k++) {
                            //////////console.log(sandmap.players[sandmap.turn].selected_tile_center.t == sandmap.players[Math.abs(sandmap.turn - 1)].units[k].tile.t && sandmap.players[sandmap.turn].selected_tile_center.k == sandmap.players[Math.abs(sandmap.turn - 1)].units[k].tile.k, sandmap.players[sandmap.turn].selected_tile_center.t , sandmap.players[Math.abs(sandmap.turn - 1)].units[k].tile.t , sandmap.players[sandmap.turn].selected_tile_center.k , sandmap.players[Math.abs(sandmap.turn - 1)].units[k].tile.k)
                            if (sandmap.players[sandmap.turn].selected_tile_center.t == sandmap.players[Math.abs(sandmap.turn - 1)].units[k].tile.t && sandmap.players[sandmap.turn].selected_tile_center.k == sandmap.players[Math.abs(sandmap.turn - 1)].units[k].tile.k) {
                                if (sandmap.players[sandmap.turn].units[t].isInRange(sandmap.players[sandmap.turn].units[t].attacktarget.tile)) {
                                    sandmap.players[sandmap.turn].units[t].attacktargetmover = sandmap.players[Math.abs(sandmap.turn - 1)].units[k]
                                    sandmap.players[sandmap.turn].units[t].attacktarget = sandmap.players[Math.abs(sandmap.turn - 1)].units[k]
                                    sandmap.players[sandmap.turn].units[t].pathToRange = 1
                                    //////////console.log(sandmap.players[sandmap.turn].units[t].attacktargetmover)
                                } else {
                                    //////////console.log(sandmap.players[sandmap.turn].units[t].attacktargetmover, 2)
                                    sandmap.players[sandmap.turn].units[t].attacktargetmover = sandmap.players[Math.abs(sandmap.turn - 1)].units[k]
                                    sandmap.players[sandmap.turn].units[t].attacktarget = sandmap.players[Math.abs(sandmap.turn - 1)].units[k]
                                    sandmap.players[sandmap.turn].units[t].pathToRange = 1
                                }
                            }
                        }

                        mcount += 1
                    }
                }

            } else {
                if (sandmap.window.minibody.isPointInside(TIP_engine)) {
                    const structuredpoint = new Point(0, 0)

                    let inverter = ((.28125) / worldscale) * 128
                    const inv = 1 / inverter
                    structuredpoint.x += (TIP_engine.x - sandmap.window.minibody.x) * inv
                    structuredpoint.y += (TIP_engine.y - sandmap.window.minibody.y) * inv
                    sandmap.window.guide.x = structuredpoint.x - (sandmap.window.body.width * .25)
                    sandmap.window.guide.y = structuredpoint.y - (sandmap.window.body.height * .25)

                    structuredpoint.x = Math.floor((sandmap.window.guide.x + (sandmap.window.body.width * .25)) * .1)
                    structuredpoint.y = Math.floor(((sandmap.window.guide.y + (sandmap.window.body.height * .25)) * .1))
                    sandmap.players[sandmap.turn].selected_tile = sandmap.blocks[Math.min(Math.max(structuredpoint.x, 0), (worldscale - 1))][Math.min(Math.max(structuredpoint.y, 0), (worldscale - 1))]

                    const dummy = {}
                    dummy.x = 0
                    dummy.y = 0
                    let count = 0
                    for (let t = 0; t < sandmap.players[sandmap.turn].units.length; t++) {
                        if (sandmap.players[sandmap.turn].units[t].selected == 1) {
                            dummy.x += sandmap.players[sandmap.turn].units[t].tile.x
                            dummy.y += sandmap.players[sandmap.turn].units[t].tile.y
                            count++
                        }
                    }
                    dummy.x /= count
                    dummy.y /= count

                    let cout = spiral(count)
                    let freespace = Math.max(Math.abs(cout[0]), Math.abs(cout[1]))
                    if (structuredpoint.x - freespace < 0) {
                        structuredpoint.x += Math.abs(structuredpoint.x - freespace) - 1
                    }
                    if (structuredpoint.y - freespace < 0) {
                        structuredpoint.y += Math.abs(structuredpoint.y - freespace) - 1
                    }
                    if (structuredpoint.x - freespace > (worldscale - 1)) {
                        structuredpoint.x -= Math.abs(structuredpoint.x - freespace) - 1
                    }
                    if (structuredpoint.y - freespace > (worldscale - 1)) {
                        structuredpoint.y -= Math.abs(structuredpoint.y - freespace) - 1
                    }
                    let dist = Math.max(Math.floor(Math.sqrt(count)) - 2, 1)
                    let distcap = dist
                    dist = 0
                    let mcount = 0
                    for (let t = 0; t < sandmap.players[sandmap.turn].units.length; t++) {
                        if (sandmap.players[sandmap.turn].units[t].selected == 1) {
                            if (typeof sandmap.players[sandmap.turn].units[t].realPath[sandmap.players[sandmap.turn].units[t].index + 1] != "undefined") {
                                if (sandmap.players[sandmap.turn].units[t].realPath[sandmap.players[sandmap.turn].units[t].index + 1] == sandmap.players[sandmap.turn].selected_tile) {
                                    continue
                                }
                            }
                            // const xdiff = Math.floor((dummy.x-sandmap.players[sandmap.turn].units[t].tile.x)*.1)
                            // const ydiff = Math.floor((dummy.y-sandmap.players[sandmap.turn].units[t].tile.y)*.1)
                            let xdiff
                            let ydiff
                            let mout = spiral(mcount - 1)
                            if (mcount > 0) {

                                xdiff = mout[0] // Math.min(Math.max(Math.floor((dummy.x - sandmap.players[sandmap.turn].units[t].tile.x) * .1), -dist), dist)
                                ydiff = mout[1] //Math.min(Math.max(Math.floor((dummy.y - sandmap.players[sandmap.turn].units[t].tile.y) * .1), -dist), dist)

                            } else {

                                xdiff = 0//  Math.min(Math.max(Math.floor((dummy.x - sandmap.players[sandmap.turn].units[t].tile.x) * .1), -dist), dist)
                                ydiff = 0// Math.min(Math.max(Math.floor((dummy.y - sandmap.players[sandmap.turn].units[t].tile.y) * .1), -dist), dist)
                                sandmap.players[sandmap.turn].selected_tile_center = sandmap.blocks[Math.min(Math.max(structuredpoint.x - xdiff, 0), (worldscale - 1))][Math.min(Math.max(structuredpoint.y - ydiff, 0), (worldscale - 1))]

                            }
                            mcount++
                            sandmap.players[sandmap.turn].selected_tile = sandmap.blocks[Math.min(Math.max(structuredpoint.x - xdiff, 0), (worldscale - 1))][Math.min(Math.max(structuredpoint.y - ydiff, 0), (worldscale - 1))]
                            //

                            //////////console.log(sandmap.players[sandmap.turn].selected_tile)
                            if (keysPressed['Shift'] || sandmap.players[sandmap.turn].units[t].patrolling == 1) {
                                if (sandmap.players[sandmap.turn].units[t].pathQue.length > 0) {
                                    sandmap.players[sandmap.turn].units[t].emergencyTarget = (sandmap.players[sandmap.turn].selected_tile)
                                    sandmap.players[sandmap.turn].units[t].selmag = count
                                    sandmap.players[sandmap.turn].units[t].pathQue.push(sandmap.players[sandmap.turn].units[t].emergencyTarget)
                                } else {
                                    sandmap.players[sandmap.turn].units[t].emergencyTarget = (sandmap.players[sandmap.turn].selected_tile)
                                    sandmap.players[sandmap.turn].units[t].selmag = count
                                    sandmap.players[sandmap.turn].units[t].pathQue.push(sandmap.players[sandmap.turn].units[t].emergencyTarget)
                                    if (sandmap.players[sandmap.turn].units[t].patrolling == 1) {
                                        sandmap.players[sandmap.turn].units[t].pathQue.push(sandmap.players[sandmap.turn].units[t].tile)
                                    }
                                    //////////console.log(sandmap.players[sandmap.turn].units[t].pathQue)
                                }
                            } else {
                                sandmap.players[sandmap.turn].units[t].emergencyTarget = (sandmap.players[sandmap.turn].selected_tile)
                                sandmap.players[sandmap.turn].units[t].selmag = count
                                if (sandmap.players[sandmap.turn].units[t].awaiting == 0) {
                                    sandmap.players[sandmap.turn].units[t].pathNow = 1
                                }
                                sandmap.players[sandmap.turn].units[t].pathQue = []
                            }


                            if (sandmap.players[sandmap.turn].selected_tile.hotrock > 0) {
                                // soundCancel()
                                // if( sandmap.players[sandmap.turn].units[t].drone == 1){
                                //     collect.play()
                                // }
                            }
                        }
                    }
                }
            }



            // example usage: if(object.isPointInside(TIP_engine)){ take action }
            // window.addEventListener('pointermove', continued_stimuli);

        });
            window.addEventListener('pointerdown', e => {

                paused = 0
                //////////console.log(e)
                if (e.ctrlKey == true) {
                    return
                }
                pflag = 1
                qflag = 0
                if (e.button == 0) {
                    FLEX_engine = canvas.getBoundingClientRect();
                    XS_engine = e.clientX - FLEX_engine.left;
                    YS_engine = e.clientY - FLEX_engine.top;
                    TIP_engine.x = XS_engine
                    TIP_engine.y = YS_engine
                    TIP_engine.x1 = XS_engine
                    TIP_engine.y1 = YS_engine
                    TIP_engine.body = TIP_engine


                    if (playstart == 3) {
                        if(AImodeButton.isPointInside(TIP_engine)){
                            if(AImode == 0){
                                sandmap.turn = 0
                            sandmap.players[0].isAI = 0
                            sandmap.players[1].isAI = 1
                            sandmap.players[2].isAI = 1
                            sandmap.players[3].isAI = 1
                            sandmap.players[1].clickrate = 400
                            sandmap.players[2].clickrate = 400
                            sandmap.players[3].clickrate = 400
                                AImode = 1
                                onlineNow = 0
                                swap.draw = empty
                                // swap.stop = 1
                                swap2.draw = empty
                                // swap2.stop = 1
                                swap3.draw = empty
                                // swap3.stop = 1
                                swap4.draw = empty
                                // swap4.stop = 1
                                // controlking = 1
                            }else{
                                sandmap.turn = -1
                                AImode = 0
                                swap1.stop = 0
                                swap2.stop = 0
                                swap3.stop = 0
                                swap4.stop = 0
                                swap.draw = uibox.draw
                                swap2.draw = uibox.draw
                                swap3.draw = uibox.draw
                                swap4.draw = uibox.draw
                            }
                        }
                    }


                    if (playstart == 3 && swap.stop != 1) {
                        if (swap.isPointInside(TIP_engine)) {

                            sandmap.turn = 1
                            if(AImode == 1){
                                return
                            }
                            sandmap.players[0].isAI = 0
                            sandmap.players[1].isAI = 0
                            sandmap.players[2].isAI = 0
                            sandmap.players[3].isAI = 0
                            let Json = {}
                            Json.array = []
                            Json.grid = 1
                            Json.map = mapindex
                            Json.mapsize = worldscale
                            Json.unitcap = unitcap
                            Json.player = sandmap.turn
                            // roughSizeOfObject(Json)
                        if(campaignController.on !== 1 && AImode != 1){
                            ws.send(JSON.stringify(Json))
                        }
                            // swap.draw = empty
                            // swap.stop = 1
                            // swap2.draw =  uibox.draw
                            // swap2.stop = 0
                            // swap3.draw =  uibox.draw
                            // swap3.stop = 0
                            // swap4.draw =  uibox.draw
                            // swap4.stop = 0
                            swap.draw = empty
                            swap.stop = 1
                            swap2.draw = empty
                            swap2.stop = 1
                            swap3.draw = empty
                            swap3.stop = 1
                            swap4.draw = empty
                            swap4.stop = 1
                            controlking = 1
                        }
                    }
                    if (playstart == 3 && swap2.stop != 1) {
                        if (swap2.isPointInside(TIP_engine)) {
                            sandmap.turn = 2
                            if(AImode == 1){
                                return
                            }
                            sandmap.players[0].isAI = 0
                            sandmap.players[1].isAI = 0
                            sandmap.players[2].isAI = 0
                            sandmap.players[3].isAI = 0
                            let Json = {}
                            Json.array = []
                            Json.grid = 1
                            Json.map = mapindex
                            Json.mapsize = worldscale
                            Json.unitcap = unitcap
                            Json.player = sandmap.turn
                            // roughSizeOfObject(Json)
                        if(campaignController.on !== 1 && AImode != 1){
                            ws.send(JSON.stringify(Json))
                        }
                            // swap.draw =  uibox.draw
                            // swap.stop = 0
                            // swap2.draw = empty
                            // swap2.stop = 1
                            // swap3.draw =  uibox.draw
                            // swap3.stop = 0
                            // swap4.draw =  uibox.draw
                            // swap4.stop = 0
                            swap.draw = empty
                            swap.stop = 1
                            swap2.draw = empty
                            swap2.stop = 1
                            swap3.draw = empty
                            swap3.stop = 1
                            swap4.draw = empty
                            swap4.stop = 1
                            controlking = 1
                        }
                    }
                    if (playstart == 3 && swap3.stop != 1) {
                        if (swap3.isPointInside(TIP_engine)) {
                            sandmap.turn = 3
                            if(AImode == 1){
                                return
                            }
                            sandmap.players[0].isAI = 0
                            sandmap.players[1].isAI = 0
                            sandmap.players[2].isAI = 0
                            sandmap.players[3].isAI = 0
                            let Json = {}
                            Json.array = []
                            Json.grid = 1
                            Json.map = mapindex
                            Json.mapsize = worldscale
                            Json.unitcap = unitcap
                            Json.player = sandmap.turn
                            // roughSizeOfObject(Json)
                        if(campaignController.on !== 1 && AImode != 1){
                            ws.send(JSON.stringify(Json))
                        }

                            swap.draw = empty
                            swap.stop = 1
                            swap2.draw = empty
                            swap2.stop = 1
                            swap3.draw = empty
                            swap3.stop = 1
                            swap4.draw = empty
                            swap4.stop = 1
                            // swap.draw =  uibox.draw
                            // swap.stop = 0
                            // swap2.draw =  uibox.draw
                            // swap2.stop = 0
                            // swap3.draw =  empty
                            // swap3.stop = 1
                            // swap4.draw =  uibox.draw
                            // swap4.stop = 0
                            controlking = 1
                        }
                    }
                    if (playstart == 3 && swap4.stop != 1) {
                        if (swap4.isPointInside(TIP_engine)) {
                            sandmap.turn = 0
                            if(AImode == 1){
                                return
                            }
                            sandmap.players[0].isAI = 0
                            sandmap.players[1].isAI = 0
                            sandmap.players[2].isAI = 0
                            sandmap.players[3].isAI = 0
                            let Json = {}
                            Json.array = []
                            Json.grid = 1
                            Json.map = mapindex
                            Json.mapsize = worldscale
                            Json.unitcap = unitcap
                            Json.player = sandmap.turn
                            // roughSizeOfObject(Json)
                        if(campaignController.on !== 1 && AImode != 1){
                            ws.send(JSON.stringify(Json))
                        }
                            // swap.draw =  uibox.draw
                            // swap.stop = 0
                            // swap2.draw =  uibox.draw
                            // swap2.stop = 0
                            // swap3.draw =  uibox.draw
                            // swap3.stop = 0
                            swap.draw = empty
                            swap.stop = 1
                            swap2.draw = empty
                            swap2.stop = 1
                            swap3.draw = empty
                            swap3.stop = 1
                            swap4.draw = empty
                            swap4.stop = 1
                            controlking = 1
                        }
                    }

                    let endmark = 0
                    for (let t = 0; t < sandmap.players.length; t++) {
                        if (sandmap.players[t].units.length > 0) {
                            endmark++
                        }
                    }


                    if (endmark <= 1) {
                        if (endbutton.isPointInside(TIP_engine)) {
                            endgame = 1
                        }
                    }
                    if (playstart == 4) {
                        if (guideplus.isPointInside(TIP_engine)) {
                            manual += 1
                            manual %= 12
                        }
                        if (playbutton.isPointInside(TIP_engine)) {
                            manual = 0
                            playstart = 3
                            return
                        }
                    }

                    if (playstart != 1 && playstart != 4) {

                        if (playstart == 3) {

                            if (campaignController.on != 1) {

                                if (controlToggle.isPointInside(TIP_engine)) {
                                    if (controllerSupport == 0) {
                                        controllerSupport = 1
                                    } else {
                                        controllerSupport = 0
                                    }
                                    return
                                }

                                if (onlineNow != 1 && (swap.stop != 1 && swap2.stop != 1 && swap3.stop != 1 && swap4.stop != 1)) {
                                    if (mapChooser.isPointInside(TIP_engine)) {
                                        mapindex++
                                        mapindex %= maplist.length
                                        let mapfix = new Mapskinner(maplist[mapindex])
                                        // break
                                        return
                                    }


                                    if (unitCapper.isPointInside(TIP_engine)) {
                                        if (unitcap < 100) {
                                            unitcap += 10
                                        } else {
                                            unitcap = 10
                                        }
                                        return
                                    }

                                    if (mapSizer.isPointInside(TIP_engine)) {
                                        if (worldscale < 256) {
                                            worldscale *= 2
                                            let resizeMap = new MapResizer(worldscale)
                                            let mapfix = new Mapskinner(maplist[mapindex])
                                        } else {
                                            worldscale = 64
                                            let resizeMap = new MapResizer(worldscale)
                                            let mapfix = new Mapskinner(maplist[mapindex])
                                        }
                                        return
                                    }
                                }
                            }


                            if (campaignController.on == 1) {
                                if (campaignController.check(TIP_engine)) {
                                    return
                                }
                            }


                            if (campaignController.starter.isPointInside(TIP_engine)) {
                                if (campaignController.on == 1) {

                                    campaignController.on = 0
                                } else {
                                    campaignController.on = 1
                                    worldscale = 128
                                    let resizeMap = new MapResizer(worldscale, 1)
                                    let mapfix = new Mapskinner({})
                                }
                            }





                            if (guideplus.isPointInside(TIP_engine)) {
                                playstart = 4
                            }
                        }
                        if (sandmap.turn != -1 || playstart != 3  || AImode == 1) {
                            if (playbutton.isPointInside(TIP_engine)) {
                                if (campaignController.on != 1) {
                                    if (playstart == 3) {
                                        playstart = 1
                                    }
                                    if (playstart == 2) {
                                        playstart = 3
                                    }
                                    if (playstart == 0) {
                                        playstart = 2
                                    }
                                }
                            }
                        }
                        if (sandmap.turn == 0 || AImode == 1) {
                            if (difftoggle1.isPointInside(TIP_engine)) {
                                return
                            }
                        }
                        if (sandmap.turn == 1 || AImode == 1) {
                            if (difftoggle2.isPointInside(TIP_engine)) {
                                return
                            }
                        }
                        if (sandmap.turn == 2 || AImode == 1) {
                            if (difftoggle3.isPointInside(TIP_engine)) {
                                return
                            }
                        }
                        if (sandmap.turn == 3 || AImode == 1) {
                            if (difftoggle4.isPointInside(TIP_engine)) {
                                return
                            }
                        }
                        if (sandmap.turn == 0 || AImode == 1) {
                            if (chartoggle1.isPointInside(TIP_engine)) {
                                return
                            }
                        }
                        if (sandmap.turn == 1 || AImode == 1) {
                            if (chartoggle2.isPointInside(TIP_engine)) {
                                return
                            }
                        }
                        if (sandmap.turn == 2 || AImode == 1) {
                            if (chartoggle3.isPointInside(TIP_engine)) {
                                return
                            }
                        }
                        if (sandmap.turn == 3 || AImode == 1) {
                            if (chartoggle4.isPointInside(TIP_engine)) {
                                return
                            }
                        }
                        //all pre game logic clicks should be above here

                        if (playstart !== 1) {
                            return
                        }

                        if (endgame == 1) {
                            if (score.button.isPointInside(TIP_engine)) {
                                if (score.mode == 0) {
                                    score.mode = 1
                                    uibox.draw()
                                    score.draw()
                                } else if (score.mode == 1) {
                                    score.mode = 2
                                    uibox.draw()
                                    score.draw()
                                } else if (score.mode == 2) {
                                    score.mode = 3
                                    uibox.draw()
                                    score.draw()
                                } else if (score.mode == 3) {
                                    score.mode = 0
                                    uibox.draw()
                                    score.draw()
                                }
                            }
                            if (score.return.isPointInside(TIP_engine)) {
                                score.initialize() // = new ScoreGraph()
                                campaignController.initialize() // = new Campaign()
                                sandmap.initialize(CANVAS_WIDTH, CANVAS_HEIGHT, 0, 0, []) // = new Sandmap(CANVAS_WIDTH, CANVAS_HEIGHT, 0, 0, []);
                                start = 0
                                playstart = 0
                                endgame = 0
                                // score = new ScoreGraph()
                                score.initialize()
                                sandmap.players[0].units = []
                                sandmap.players[1].units = []
                                start = 0
                                for (let t = 0; t < campaignsounds.length; t++) {
                                    campaignsounds[t].pause()
                                    campaignsounds[t].currentTime = 0
                                }
                                for (let t = 0; t < 3; t++) {
                                    const agent1 = new Agent(sandmap.blocks[5][t + 5], sandmap.players[0])
                                }
                                for (let t = 0; t < 3; t++) {
                                    const agent2 = new Agent(sandmap.blocks[(worldscale - 6)][(worldscale - 6) - t], sandmap.players[1])
                                }

                                let mapfix = new Mapskinner(maplist[mapindex])
                                start = 0
                                return
                            }
                        }
                    }
                    if(playstart == 1){

                        if (sandmap.players[sandmap.turn].flopped == 1 && sandmap.players[sandmap.turn].playerUI.state == 0) {
                            if (sandmap.players[sandmap.turn].commandPanel.commandButtons[1].isPointInside(TIP_engine)) {

                                    if(sandmap.players[sandmap.turn].type == 7){
                                if (sandmap.players[sandmap.turn].Mflag == 0) {
                                    sandmap.players[sandmap.turn].Bflag = 0
                                    sandmap.players[sandmap.turn].Nflag = 0
                                    sandmap.players[sandmap.turn].Mflag = 1
                                    sandmap.players[sandmap.turn].Gflag = 0
                                } else if (sandmap.players[sandmap.turn].Mflag == 1) {
                                    sandmap.players[sandmap.turn].Mflag = 0
                                }
                                    }else{
                                if (sandmap.players[sandmap.turn].Nflag == 0) {
                                    sandmap.players[sandmap.turn].Bflag = 0
                                    sandmap.players[sandmap.turn].Nflag = 1
                                    sandmap.players[sandmap.turn].Mflag = 0
                                    sandmap.players[sandmap.turn].Gflag = 0
                                } else if (sandmap.players[sandmap.turn].Nflag == 1) {
                                    sandmap.players[sandmap.turn].Nflag = 0
                                }
                                    }
                            }
                        }

                        if (sandmap.players[sandmap.turn].flopped == 1 && sandmap.players[sandmap.turn].playerUI.state == 0) {
                            if (sandmap.players[sandmap.turn].commandPanel.commandButtons[2].isPointInside(TIP_engine)) {
                                    if(sandmap.players[sandmap.turn].type == 7){
                                    }else{

                                if (sandmap.players[sandmap.turn].Mflag == 0) {
                                    sandmap.players[sandmap.turn].Bflag = 0
                                    sandmap.players[sandmap.turn].Nflag = 0
                                    sandmap.players[sandmap.turn].Mflag = 1
                                    sandmap.players[sandmap.turn].Gflag = 0
                                } else if (sandmap.players[sandmap.turn].Mflag == 1) {
                                    sandmap.players[sandmap.turn].Mflag = 0
                                }
                                    }
                            }
                        }
                        if (sandmap.players[sandmap.turn].flopped == 1 && sandmap.players[sandmap.turn].playerUI.state == 0) {
                            if (sandmap.players[sandmap.turn].commandPanel.commandButtons[3].isPointInside(TIP_engine)) {
                                if (sandmap.players[sandmap.turn].Gflag == 0) {
                                    sandmap.players[sandmap.turn].Bflag = 0
                                    sandmap.players[sandmap.turn].Nflag = 0
                                    sandmap.players[sandmap.turn].Mflag = 0
                                    sandmap.players[sandmap.turn].Gflag = 1
                                } else if (sandmap.players[sandmap.turn].Gflag == 1) {
                                    sandmap.players[sandmap.turn].Gflag = 0
                                }
                            }
                        }
                        if (sandmap.players[sandmap.turn].flopped == 1 && sandmap.players[sandmap.turn].playerUI.state == 0) {
                            if (sandmap.players[sandmap.turn].commandPanel.commandButtons[0].isPointInside(TIP_engine)) {
                                if (sandmap.players[sandmap.turn].Bflag == 0) {
                                    sandmap.players[sandmap.turn].Bflag = 1
                                    sandmap.players[sandmap.turn].Nflag = 0
                                    sandmap.players[sandmap.turn].Mflag = 0
                                    sandmap.players[sandmap.turn].Gflag = 0
                                } else if (sandmap.players[sandmap.turn].Bflag == 1) {
                                    sandmap.players[sandmap.turn].Bflag = 0
                                }
                            }
                        }

                    // } else {

                        if (TIP_engine.x <= sandmap.window.body.x + sandmap.window.body.width) {
                            if (keysPressed['q'] || sandmap.players[sandmap.turn].Bflag == 1) {
                                const structuredpoint = new Point(0, 0)
                                structuredpoint.x += sandmap.window.guide.x
                                structuredpoint.y += sandmap.window.guide.y
                                structuredpoint.x += (TIP_engine.x * .5)
                                structuredpoint.y += (TIP_engine.y * .5)
                                structuredpoint.x = Math.floor(structuredpoint.x * .1)
                                structuredpoint.y = Math.floor(structuredpoint.y * .1)
                                sandmap.players[sandmap.turn].selected_tile = sandmap.blocks[structuredpoint.x][structuredpoint.y]

                                let wet = 0
                                for (let t = 0; t < sandmap.players[sandmap.turn].buildings.length; t++) {
                                    if (sandmap.players[sandmap.turn].selected_tile == sandmap.players[sandmap.turn].buildings[t].tile) {
                                        wet = 1
                                    }
                                }
                                if (sandmap.players[sandmap.turn].blocks[sandmap.players[sandmap.turn].selected_tile.t][sandmap.players[sandmap.turn].selected_tile.k].markdraw !== 1) {
                                    wet = 1
                                }
                                // if (sandmap.players[sandmap.turn].hotrock < 10) {
                                //     wet = 1
                                // }

                                if (sandmap.players[sandmap.turn].blocks[sandmap.players[sandmap.turn].selected_tile.t][sandmap.players[sandmap.turn].selected_tile.k].markdraw !== 1) {
                                    wet = 1
                                }
                                //////////console.log("-4")
                                if (wet == 0) {
                                    //////////console.log("-3")
                                    if (sandmap.players[sandmap.turn].type == 5) {
                                        sandmap.players[sandmap.turn].buildMound(sandmap.players[sandmap.turn].selected_tile, 0)

                                    } else if (sandmap.players[sandmap.turn].type == 7) {
                                        sandmap.players[sandmap.turn].buildPond(sandmap.players[sandmap.turn].selected_tile, 0)

                                    } else if (sandmap.players[sandmap.turn].type == 9) {
                                        sandmap.players[sandmap.turn].buildTree(sandmap.players[sandmap.turn].selected_tile, 0)

                                    } else if (sandmap.players[sandmap.turn].type == 10) {
                                        sandmap.players[sandmap.turn].buildHive(sandmap.players[sandmap.turn].selected_tile, 0)

                                    } else {
                                        sandmap.players[sandmap.turn].buildWall(sandmap.players[sandmap.turn].selected_tile, 0)

                                    }
                                }

                                selectrect = new Tile(0, 0, 0, 0, "transparent")
                                rectstart.x = structuredpoint.x
                                rectstart.y = structuredpoint.y
                            } else if (keysPressed['r'] || sandmap.players[sandmap.turn].Gflag == 1) {
                                const structuredpoint = new Point(0, 0)
                                structuredpoint.x += sandmap.window.guide.x
                                structuredpoint.y += sandmap.window.guide.y
                                structuredpoint.x += (TIP_engine.x * .5)
                                structuredpoint.y += (TIP_engine.y * .5)
                                structuredpoint.x = Math.floor(structuredpoint.x * .1)
                                structuredpoint.y = Math.floor(structuredpoint.y * .1)
                                sandmap.players[sandmap.turn].selected_tile = sandmap.blocks[structuredpoint.x][structuredpoint.y]

                                let wet = 0
                                for (let t = 0; t < sandmap.players[sandmap.turn].buildings.length; t++) {
                                    if (sandmap.players[sandmap.turn].selected_tile == sandmap.players[sandmap.turn].buildings[t].tile) {
                                        wet = 1
                                    }
                                }
                                if (sandmap.players[sandmap.turn].blocks[sandmap.players[sandmap.turn].selected_tile.t][sandmap.players[sandmap.turn].selected_tile.k].markdraw !== 1) {
                                    wet = 1
                                }
                                // if (sandmap.players[sandmap.turn].hotrock < 10) {
                                //     wet = 1
                                // }

                                if (sandmap.players[sandmap.turn].blocks[sandmap.players[sandmap.turn].selected_tile.t][sandmap.players[sandmap.turn].selected_tile.k].markdraw !== 1) {
                                    wet = 1
                                }
                                if (wet == 0) {
                                    sandmap.players[sandmap.turn].buildGate(sandmap.players[sandmap.turn].selected_tile, 0)
                                }

                                selectrect = new Tile(0, 0, 0, 0, "transparent")
                                rectstart.x = structuredpoint.x
                                rectstart.y = structuredpoint.y
                            } else if (keysPressed['x']) {
                                const structuredpoint = new Point(0, 0)
                                structuredpoint.x += sandmap.window.guide.x
                                structuredpoint.y += sandmap.window.guide.y
                                structuredpoint.x += (TIP_engine.x * .5)
                                structuredpoint.y += (TIP_engine.y * .5)
                                structuredpoint.x = Math.floor(structuredpoint.x * .1)
                                structuredpoint.y = Math.floor(structuredpoint.y * .1)
                                sandmap.players[sandmap.turn].selected_tile = sandmap.blocks[structuredpoint.x][structuredpoint.y]
                                for (let t = 0; t < sandmap.players[sandmap.turn].buildings.length; t++) {
                                    if (sandmap.players[sandmap.turn].buildings[t].tiles.includes(sandmap.players[sandmap.turn].selected_tile)) {
                                        for (let k = 0; k < sandmap.players[sandmap.turn].buildings[t].tiles.length; k++) {
                                            sandmap.players[sandmap.turn].buildings[t].tiles[k].walkable = true
                                            sandmap.players[sandmap.turn].buildings[t].tiles[k].builtOn = 0
                                            sandmap.players[sandmap.turn].buildings[t].tiles[k].color = "#AACCFF"
                                            delete sandmap.players[sandmap.turn].buildings[t].tiles[k].wallcolor
                                        }

                                        if (sandmap.players[sandmap.turn].buildings[t].slime == true || sandmap.players[sandmap.turn].buildings[t].sporeball == 1) {
                                            sandmap.players[sandmap.turn].slimeflag = 1
                                        }
                                        sandmap.players[sandmap.turn].buildings[t].tile.spiretile = 0
                                        sandmap.players[sandmap.turn].buildings[t].tile.builtOn = 0
                                        sandmap.players[sandmap.turn].buildings[t].tile.slime = false
                                        sandmap.players[sandmap.turn].buildings[t].tile.dirt = 0
                                        sandmap.players[sandmap.turn].buildings[t].tile.faction = -1
                                        sandmap.players[sandmap.turn].buildings[t].tile.wallflag = 0
                                        sandmap.players[sandmap.turn].buildings[t].tile.aura = 0
                                        sandmap.backgroundcheck = 1

                                        sandmap.buildingCanvas_context.clearRect(sandmap.players[sandmap.turn].buildings[t].tile.x, sandmap.players[sandmap.turn].buildings[t].tile.y, sandmap.players[sandmap.turn].buildings[t].tile.width + (sandmap.players[sandmap.turn].buildings[t].size * 1 * sandmap.players[sandmap.turn].buildings[t].tile.width), sandmap.players[sandmap.turn].buildings[t].tile.height + (sandmap.players[sandmap.turn].buildings[t].size * 1 * sandmap.players[sandmap.turn].buildings[t].tile.height))
                                        sandmap.players[sandmap.turn].buildings.splice(t, 1)
                                        for (let k = 0; k < sandmap.players[sandmap.turn].units.length; k++) {
                                            sandmap.players[sandmap.turn].units[k].heatmoved = 1
                                        }
                                        break
                                    }
                                }

                                selectrect = new Tile(0, 0, 0, 0, "transparent")
                                rectstart.x = structuredpoint.x
                                rectstart.y = structuredpoint.y
                            } else if (keysPressed['c'] || sandmap.players[sandmap.turn].Nflag == 1) {
                                const structuredpoint = new Point(0, 0)
                                structuredpoint.x += sandmap.window.guide.x
                                structuredpoint.y += sandmap.window.guide.y
                                structuredpoint.x += (TIP_engine.x * .5)
                                structuredpoint.y += (TIP_engine.y * .5)
                                structuredpoint.x = Math.floor(structuredpoint.x * .1)
                                structuredpoint.y = Math.floor(structuredpoint.y * .1)
                                sandmap.players[sandmap.turn].selected_tile = sandmap.blocks[structuredpoint.x][structuredpoint.y]

                                let wet = 0
                                for (let t = 0; t < sandmap.players[sandmap.turn].buildings.length; t++) {
                                    if (sandmap.players[sandmap.turn].selected_tile == sandmap.players[sandmap.turn].buildings[t].tile) {
                                        wet = 1
                                    }
                                }
                                // if (sandmap.players[sandmap.turn].hotrock < 70) {
                                //     wet = 1
                                // }
                                if (sandmap.players[sandmap.turn].blocks[sandmap.players[sandmap.turn].selected_tile.t][sandmap.players[sandmap.turn].selected_tile.k].markdraw !== 1) {
                                    wet = 1
                                }
                                if (wet == 0) {
                                    sandmap.players[sandmap.turn].buildBarracks(sandmap.players[sandmap.turn].selected_tile, 0)
                                    // const building = new Building(sandmap.players[sandmap.turn].selected_tile, sandmap.players[sandmap.turn], 0)

                                }

                                selectrect = new Tile(0, 0, 0, 0, "transparent")
                                rectstart.x = structuredpoint.x
                                rectstart.y = structuredpoint.y
                            } else if (keysPressed['e'] || sandmap.players[sandmap.turn].Mflag == 1) {
                                const structuredpoint = new Point(0, 0)
                                structuredpoint.x += sandmap.window.guide.x
                                structuredpoint.y += sandmap.window.guide.y
                                structuredpoint.x += (TIP_engine.x * .5)
                                structuredpoint.y += (TIP_engine.y * .5)
                                structuredpoint.x = Math.floor(structuredpoint.x * .1)
                                structuredpoint.y = Math.floor(structuredpoint.y * .1)
                                sandmap.players[sandmap.turn].selected_tile = sandmap.blocks[structuredpoint.x][structuredpoint.y]

                                let wet = 0
                                for (let t = 0; t < sandmap.players[sandmap.turn].buildings.length; t++) {
                                    if (sandmap.players[sandmap.turn].selected_tile == sandmap.players[sandmap.turn].buildings[t].tile) {
                                        wet = 1
                                    }
                                }
                                // if (sandmap.players[sandmap.turn].hotrock < 70) {
                                //     wet = 1
                                // }
                                if (sandmap.players[sandmap.turn].blocks[sandmap.players[sandmap.turn].selected_tile.t][sandmap.players[sandmap.turn].selected_tile.k].markdraw !== 1) {
                                    wet = 1
                                }
                                if (wet == 0) {
                                    if(sandmap.players[sandmap.turn].type == 7){
                                        sandmap.players[sandmap.turn].buildTeleporter(sandmap.players[sandmap.turn].selected_tile, 0)
                                    }else{
                                        sandmap.players[sandmap.turn].buildMachineLab(sandmap.players[sandmap.turn].selected_tile, 0)
                                    }
                                    // const building = new Building(sandmap.players[sandmap.turn].selected_tile, sandmap.players[sandmap.turn], 0)

                                }

                                selectrect = new Tile(0, 0, 0, 0, "transparent")
                                rectstart.x = structuredpoint.x
                                rectstart.y = structuredpoint.y
                            } else {
                                const structuredpoint = new Point(0, 0)
                                structuredpoint.x += sandmap.window.guide.x
                                structuredpoint.y += sandmap.window.guide.y
                                structuredpoint.x += (TIP_engine.x * .5)
                                structuredpoint.y += (TIP_engine.y * .5)
                                structuredpoint.xp = structuredpoint.x
                                structuredpoint.yp = structuredpoint.y
                                structuredpoint.x = Math.floor(structuredpoint.x * .1)
                                structuredpoint.y = Math.floor(structuredpoint.y * .1)
                                if (structuredpoint.x < 0) {
                                    structuredpoint.x = 0
                                }
                                if (structuredpoint.y < 0) {
                                    structuredpoint.y = 0
                                }
                                sandmap.players[sandmap.turn].selected_tile = sandmap.blocks[structuredpoint.x][structuredpoint.y]

                                for (let t = 0; t < sandmap.players[sandmap.turn].buildings.length; t++) {
                                    if (sandmap.players[sandmap.turn].buildings[t].wayfinding == 1) {
                                        sandmap.players[sandmap.turn].buildings[t].waypoint = (sandmap.players[sandmap.turn].selected_tile)
                                    }
                                }
                                //////////console.log("1")
                                for (let t = 0; t < sandmap.players[sandmap.turn].buildings.length; t++) {
                                    if (sandmap.players[sandmap.turn].buildings[t].tiles.includes(sandmap.players[sandmap.turn].selected_tile)) {
                                        sandmap.players[sandmap.turn].buildings[t].selected = 1
                                    } else {
                                        if (!keysPressed['Shift']) {
                                            if ((sandmap.players[sandmap.turn].buildings[t].wayfinding != 1)) {
                                                sandmap.players[sandmap.turn].buildings[t].selected = 0
                                            } else {
                                                sandmap.players[sandmap.turn].buildings[t].wayfinding = -1
                                                sandmap.players[sandmap.turn].buildings[t].selected = 1
                                                if (sandmap.players[sandmap.turn].buildings[t].wayfinding == 1) {
                                                    sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[4].color = "#094909"
                                                } else {
                                                    sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[4].color = "#090909"
                                                }
                                            }
                                        }
                                    }
                                }

                                // sandmap.turn++
                                sandmap.turn %= sandmap.players.length
                                rectstart.x = structuredpoint.x
                                rectstart.y = structuredpoint.y


                                let wet = 0
                                let index = -1

                                for (let k = 0; k < sandmap.players[sandmap.turn].units.length; k++) {
                                    if (sandmap.players[sandmap.turn].units[k].selected == 1) {
                                        wet++
                                        index = k
                                    }
                                    if (sandmap.players[sandmap.turn].units[k].selected == 2) {
                                        wet++
                                        index = k
                                    }
                                }



                                let link = new LinePO(structuredpoint, {})
                                for (let t = 0; t < sandmap.players[sandmap.turn].units.length; t++) {
                                    link.target = sandmap.players[sandmap.turn].units[t].body
                                    const dis = link.hypotenuse()
                                    if (sandmap.players[sandmap.turn].selected_tile == sandmap.players[sandmap.turn].units[t].tile || dis <= 5) {

                                        selectionSound(sandmap.players[sandmap.turn].units[t])

                                        sandmap.players[sandmap.turn].units[t].selected = 2

                                        if (wet == 1 && index == t) {
                                            for (let k = 0; k < sandmap.players[sandmap.turn].units.length; k++) {
                                                // if(sandmap.window.body.isPointInside(sandmap.players[sandmap.turn].units[t].body)){
                                                if (sandmap.players[sandmap.turn].units[t].maxhealth == sandmap.players[sandmap.turn].units[k].maxhealth) {
                                                    sandmap.players[sandmap.turn].units[k].selected = 2
                                                }
                                                // }
                                            }
                                        }
                                    } else {
                                        // sandmap.players[sandmap.turn].units[t].selected = 0
                                    }
                                }
                            }
                        } else {
                            for (let t = 0; t < sandmap.players[sandmap.turn].units.length; t++) {
                                if (sandmap.players[sandmap.turn].units[t].selected == 1 || sandmap.players[sandmap.turn].units[t].selected == 2) {
                                    if (sandmap.players[sandmap.turn].units[t].agentTile.isPointInside(TIP_engine)) {
                                        for (let k = 0; k < sandmap.players[sandmap.turn].units.length; k++) {
                                            if (k != t) {
                                                sandmap.players[sandmap.turn].units[k].selected = 0
                                            }
                                        }
                                    }
                                }

                            }

                            for (let t = 0; t < sandmap.players[sandmap.turn].buildings.length; t++) {
                                if (sandmap.players[sandmap.turn].buildings[t].selected == 1) {

                                    if (sandmap.players[sandmap.turn].buildings[t].barracks == 1) {
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[0].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeInfantry()
                                        }
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[2].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeSniper()
                                        }
                                    }

                                    if (sandmap.players[sandmap.turn].buildings[t].gate == 1) {
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[0].isPointInside(TIP_engine)) {
                                            // if (sandmap.players[sandmap.turn].buildings[t].tile.occupied !== true) {
                                            sandmap.players[sandmap.turn].buildings[t].open *= -1
                                            sandmap.players[sandmap.turn].buildings[t].tile.wallflag *= -1
                                            if (sandmap.players[sandmap.turn].buildings[t].tile.spiretile != true) {
                                                sandmap.players[sandmap.turn].buildings[t].tile.spiretile = true
                                            } else {
                                                sandmap.players[sandmap.turn].buildings[t].tile.spiretile = false
                                            }

                                            if (sandmap.players[sandmap.turn].buildings[t].open == 1) {
                                                if (Math.random() < soundspamdrop * 2) {
                                                    soundCancel()
                                                    if (Math.random() < .5) {
                                                        opening1.play()
                                                    } else {
                                                        opening2.play()
                                                    }
                                                }
                                            }
                                            if (sandmap.players[sandmap.turn].buildings[t].open == -1) {
                                                if (Math.random() < soundspamdrop * 2) {
                                                    soundCancel()
                                                    if (Math.random() < .3) {
                                                        closing1.play()
                                                    } else if (Math.random() < .3) {
                                                        closing2.play()
                                                    } else {
                                                        closing3.play()
                                                    }
                                                }
                                            }
                                            // }
                                        }
                                    }

                                    if (sandmap.players[sandmap.turn].buildings[t].slime == 1) {
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[0].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeFruitingbuddy()
                                        }
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[1].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeSporeseer()
                                        }
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[2].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeVizier()
                                        }
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[3].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeMycoknight()
                                        }

                                    }
                                    if (sandmap.players[sandmap.turn].buildings[t].egg == 1) {
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[0].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].hatchBuzzlet()
                                        }
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[1].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].hatchMegagnat()
                                        }
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[2].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].hatchFlugoon()
                                        }
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[3].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].hatchStarbatross()
                                        }

                                    }
                                    if (sandmap.players[sandmap.turn].buildings[t].teleporter == 1) {
                                        sandmap.players[sandmap.turn].buildings[t].teleport
                                    }
                                    if (sandmap.players[sandmap.turn].buildings[t].pond == 1) {
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[0].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeAlagadile()
                                        }
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[1].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeBigHunchAlagadile()
                                        }
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[2].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeBigAlagadile()
                                        }
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[3].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeHunchAlagadile()
                                        }

                                    }
                                    if (sandmap.players[sandmap.turn].buildings[t].tree == 1) {
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[0].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeGogonaut()
                                        }
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[1].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeGogonautTeam()
                                        }
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[2].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeGogonautChampion()
                                        }
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[3].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeGogonautDefender()
                                        }

                                    }
                                    if (sandmap.players[sandmap.turn].buildings[t].beehive == 1) {
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[0].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeBeeWorker()
                                        }
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[1].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeBeeScout()
                                        }
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[2].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeBeeSoldier()
                                        }
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[3].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeBeeMega()
                                        }

                                    }
                                    if (sandmap.players[sandmap.turn].buildings[t].barracks == 2) {
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[0].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeScout()
                                        }
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[2].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeHarvester()
                                        }
                                    }
                                    if (sandmap.players[sandmap.turn].buildings[t].assembler == 1) {
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[0].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeHamartansoldier()
                                        }
                                        // if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[2].isPointInside(TIP_engine)) {
                                        //     sandmap.players[sandmap.turn].buildings[t].makeHarvester()
                                        // }
                                    }
                                    if (sandmap.players[sandmap.turn].buildings[t].assembler == 2) {
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[0].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeHamartanscout()
                                        }
                                        // if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[2].isPointInside(TIP_engine)) {
                                        //     sandmap.players[sandmap.turn].buildings[t].makeHarvester()
                                        // }
                                    }
                                    if (sandmap.players[sandmap.turn].buildings[t].assembler == 3) {
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[0].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeHamartanworker()
                                        }
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[2].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeHamartaninvader()
                                        }
                                    }
                                    if (sandmap.players[sandmap.turn].buildings[t].bulbplant == 1) {
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[0].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeLibrilbianpollinator()
                                        }
                                    }
                                    if (sandmap.players[sandmap.turn].buildings[t].bulbplant == 2) {
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[0].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeLibrilbianpufffellow()
                                        }
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[1].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeLibrilbianpodman()
                                        }
                                        if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[2].isPointInside(TIP_engine)) {
                                            sandmap.players[sandmap.turn].buildings[t].makeLibrilbiangoliophyte()
                                        }
                                    }
                                }
                            }

                            for (let t = 0; t < sandmap.players[sandmap.turn].buildings.length; t++) {
                                if (sandmap.players[sandmap.turn].buildings[t].selected == 1 || sandmap.players[sandmap.turn].buildings[t].selected == 2) {
                                    if (sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[4].isPointInside(TIP_engine)) {
                                        sandmap.players[sandmap.turn].buildings[t].wayfinding *= -1
                                        if (sandmap.players[sandmap.turn].buildings[t].wayfinding == 1) {
                                            sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[4].color = "#094909"
                                        } else {
                                            sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[4].color = "#090909"
                                        }
                                    }
                                }
                            }
                            for (let t = 0; t < sandmap.players[sandmap.turn].units.length; t++) {
                                if (sandmap.players[sandmap.turn].units[t].selected == 1 || sandmap.players[sandmap.turn].units[t].selected == 2) {

                                    if (sandmap.players[sandmap.turn].units[t].commandPanel.commandButtons[4].isPointInside(TIP_engine)) {
                                        sandmap.players[sandmap.turn].units[t].patrolling *= -1
                                        if (sandmap.players[sandmap.turn].units[t].patrolling == 1) {
                                            sandmap.players[sandmap.turn].units[t].commandPanel.commandButtons[4].color = "#094909"
                                        } else {
                                            sandmap.players[sandmap.turn].units[t].commandPanel.commandButtons[4].color = "#090909"
                                        }
                                    }
                                }
                                if (sandmap.players[sandmap.turn].type == 8) {
                                    if (sandmap.players[sandmap.turn].units[t].commandPanel.commandButtons[0].isPointInside(TIP_engine)) {
                                        sandmap.players[sandmap.turn].units[t].upgradeAttack()
                                    }
                                    if (sandmap.players[sandmap.turn].units[t].commandPanel.commandButtons[1].isPointInside(TIP_engine)) {
                                        sandmap.players[sandmap.turn].units[t].upgradeSpeed()
                                    }
                                    if (sandmap.players[sandmap.turn].units[t].commandPanel.commandButtons[2].isPointInside(TIP_engine)) {
                                        sandmap.players[sandmap.turn].units[t].upgradeDefense()
                                    }
                                    if (sandmap.players[sandmap.turn].units[t].commandPanel.commandButtons[3].isPointInside(TIP_engine)) {
                                        sandmap.players[sandmap.turn].units[t].upgradeIncome()
                                    }
                                }
                                if (sandmap.players[sandmap.turn].type == 6) {
                                    if (sandmap.players[sandmap.turn].units[t].commandPanel.commandButtons[0].isPointInside(TIP_engine)) {
                                        sandmap.players[sandmap.turn].units[t].upgradeAttack()
                                    }
                                    if (sandmap.players[sandmap.turn].units[t].commandPanel.commandButtons[1].isPointInside(TIP_engine)) {
                                        sandmap.players[sandmap.turn].units[t].upgradeSpeedSchlorkupine()
                                    }
                                    if (sandmap.players[sandmap.turn].units[t].commandPanel.commandButtons[2].isPointInside(TIP_engine)) {
                                        sandmap.players[sandmap.turn].units[t].upgradeDefenseSchlorkupine()
                                    }
                                    if (sandmap.players[sandmap.turn].units[t].commandPanel.commandButtons[3].isPointInside(TIP_engine)) {
                                        sandmap.players[sandmap.turn].units[t].upgradeIncome()
                                    }
                                }



                                if (sandmap.players[sandmap.turn].units[t].commandPanel.commandButtons[0].isPointInside(TIP_engine)) {

                                    // for (let k = 0; k < sandmap.players[sandmap.turn].units.length; k++) {
                                    if (sandmap.players[sandmap.turn].units[t].imago == 1 || sandmap.players[sandmap.turn].units[t].imago == 2) {
                                        if (sandmap.players[sandmap.turn].units[t].selected == 1 || sandmap.players[sandmap.turn].units[t].selected == 2) {
                                            sandmap.players[sandmap.turn].units[t].makeNymph()
                                        }
                                    }
                                    // }
                                }
                                if (sandmap.players[sandmap.turn].units[t].commandPanel.commandButtons[0].isPointInside(TIP_engine)) {
                                    if (sandmap.players[sandmap.turn].units[t].nymph == 1) {

                                        for (let k = 0; k < sandmap.players[sandmap.turn].units.length; k++) {
                                            if (sandmap.players[sandmap.turn].units[k].nymph == 1) {
                                                if (sandmap.players[sandmap.turn].units[k].selected == 1 || sandmap.players[sandmap.turn].units[k].selected == 2) {
                                                    sandmap.players[sandmap.turn].units[k].metamorph1()
                                                    if (Math.random() < soundspamdrop) {
                                                        soundCancel()
                                                        whoarewetomolt.play()
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    if (sandmap.players[sandmap.turn].units[t].pollinator == 1) {

                                        for (let k = 0; k < sandmap.players[sandmap.turn].units.length; k++) {
                                            if (sandmap.players[sandmap.turn].units[k].pollinator == 1) {
                                                if (sandmap.players[sandmap.turn].units[k].selected == 1 || sandmap.players[sandmap.turn].units[k].selected == 2) {
                                                    sandmap.players[sandmap.turn].units[k].metamorphpufffellow()
                                                    if (Math.random() < soundspamdrop) {
                                                        soundCancel()
                                                        pollinatoraudio.play()
                                                    }
                                                }
                                            }
                                        }
                                    }

                                }


                                // for (let k = 0; k < sandmap.players[sandmap.turn].units.length; k++) {
                                //     if (sandmap.players[sandmap.turn].units[k].selected == 1 || sandmap.players[sandmap.turn].units[k].selected == 2) {
                                //         for (let c = 0; c < sandmap.players[sandmap.turn].units[k].commandPanel.commandButtons.length; c++) {
                                //             if (sandmap.players[sandmap.turn].units[k].commandPanel.commandButtons[c].isPointInside(TIP_engine)) {
                                //                 // sandmap.players[sandmap.turn].units[k].commandPanel.commandButtons[c].color = "#555555"
                                //             }
                                //         }
                                //     }
                                // }


                                if (sandmap.players[sandmap.turn].units[t].commandPanel.commandButtons[1].isPointInside(TIP_engine)) {
                                    // sandmap.players[sandmap.turn].units[t].metacommandPanel.commandButtons[1]()
                                    if (sandmap.players[sandmap.turn].units[t].nymph == 2) {
                                        for (let k = 0; k < sandmap.players[sandmap.turn].units.length; k++) {
                                            if (sandmap.players[sandmap.turn].units[k].nymph == 2) {
                                                if (sandmap.players[sandmap.turn].units[k].selected == 1 || sandmap.players[sandmap.turn].units[k].selected == 2) {
                                                    sandmap.players[sandmap.turn].units[k].metamorph2()
                                                    if (Math.random() < soundspamdrop) {
                                                        soundCancel()
                                                        whoelsezagtheoystergush.play()
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }

                                if (sandmap.players[sandmap.turn].units[t].commandPanel.commandButtons[2].isPointInside(TIP_engine)) {
                                    //////////console.log("i")
                                    if (sandmap.players[sandmap.turn].units[t].nymph == 2) {
                                        // sandmap.players[sandmap.turn].units[t].metacommandPanel.commandButtons[2]()

                                        for (let k = 0; k < sandmap.players[sandmap.turn].units.length; k++) {
                                            if (sandmap.players[sandmap.turn].units[k].nymph == 2) {
                                                if (sandmap.players[sandmap.turn].units[k].selected == 1 || sandmap.players[sandmap.turn].units[k].selected == 2) {
                                                    sandmap.players[sandmap.turn].units[k].metamorph3()
                                                    if (Math.random() < soundspamdrop) {
                                                        soundCancel()
                                                        stallusyourworth.play()

                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        //////////console.log("i2")
                                        // for (let k = 0; k < sandmap.players[sandmap.turn].units.length; k++) {
                                        if (sandmap.players[sandmap.turn].units[t].submerged == 0) {
                                            if (sandmap.players[sandmap.turn].units[t].imago == 2) {
                                                if (sandmap.players[sandmap.turn].units[t].selected == 1 || sandmap.players[sandmap.turn].units[t].selected == 2) {
                                                    sandmap.players[sandmap.turn].units[t].submerged = 1

                                                    //////////console.log("i6")
                                                    if (Math.random() < soundspamdrop) {
                                                        soundCancel()
                                                        slurpslurp.play()
                                                    }
                                                }
                                            }

                                        } else {
                                            //////////console.log("i2")
                                            if (sandmap.players[sandmap.turn].units[t].imago == 2) {
                                                if (sandmap.players[sandmap.turn].units[t].selected == 1 || sandmap.players[sandmap.turn].units[t].selected == 2) {

                                                    //////////console.log("i3")
                                                    if (sandmap.players[sandmap.turn].units[t].tile.ice == 1 || sandmap.players[sandmap.turn].units[t].tile.builtOn == 1) { //sandmap.players[sandmap.turn].units[t].tile.walkable == false || 

                                                        //////////console.log("i5")
                                                    } else {

                                                        //////////console.log("i4")
                                                        sandmap.players[sandmap.turn].units[t].submerged = 0
                                                        if (Math.random() < soundspamdrop) {
                                                            soundCancel()
                                                            gooutside.play()
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        // }
                                    }
                                }
                            }
                            if (sandmap.window.minibody.isPointInside(TIP_engine)) {
                                const structuredpoint = new Point(0, 0)

                                let inverter = ((.28125) / worldscale) * 128
                                const inv = 1 / inverter
                                structuredpoint.x += (TIP_engine.x - sandmap.window.minibody.x) * inv
                                structuredpoint.y += (TIP_engine.y - sandmap.window.minibody.y) * inv
                                sandmap.window.guide.x = structuredpoint.x - (sandmap.window.body.width * .25)
                                sandmap.window.guide.y = structuredpoint.y - (sandmap.window.body.height * .25)
                            }
                        }



                        // example usage: if(object.isPointInside(TIP_engine)){ take action }
                        window.addEventListener('pointermove', continued_stimuli);
                        // }
                    }
                }
        });

        window.addEventListener('pointermove', continued_stimuliMenu);
        window.addEventListener('pointerup', e => {
            pflag = 0
            FLEX_engine = canvas.getBoundingClientRect();
            XS_engine = e.clientX - FLEX_engine.left;
            YS_engine = e.clientY - FLEX_engine.top;
            TIP_engine.x = XS_engine
            TIP_engine.y = YS_engine
            TIP_engine.body = TIP_engine
            let wet = 0
            if(playstart != 1){
                return
            }
            // if (e.button == 0) {
            window.removeEventListener("pointermove", continued_stimuli);
            if (TIP_engine.x <= sandmap.window.body.x + sandmap.window.body.width) {
                for (let t = 0; t < sandmap.players[sandmap.turn].units.length; t++) {
                    if (selectrect.isPointInside(sandmap.players[sandmap.turn].units[t].body)) {

                        if (e.button == 0) {
                            sandmap.players[sandmap.turn].units[t].selected = 1


                        }

                    } else {
                        if (sandmap.players[sandmap.turn].units[t].selected == 2) {
                            if (e.button == 0) {
                                sandmap.players[sandmap.turn].units[t].selected = 1

                            }
                        } else {

                            if (e.button == 0) {
                                if (!keysPressed['Shift']) {
                                    if (e.button == 0) {
                                        sandmap.players[sandmap.turn].units[t].selected = 0
                                    }
                                }
                            }
                        }
                    }
                }
                // for (let t = 0; t < sandmap.players[Math.abs(sandmap.turn-1)].units.length; t++) {
                //     if (selectrect.isPointInside(sandmap.players[Math.abs(sandmap.turn-1)].units[t].body)) {

                //         if (e.button == 0) {
                //             sandmap.players[Math.abs(sandmap.turn-1)].units[t].selected = 1


                //         }

                //     } else {
                //         if (sandmap.players[Math.abs(sandmap.turn-1)].units[t].selected == 2) {
                //             if (e.button == 0) {
                //                 sandmap.players[Math.abs(sandmap.turn-1)].units[t].selected = 1

                //             }
                //         } else {

                //             if (e.button == 0) {
                //                 if (!keysPressed['Shift']) {
                //                     if (e.button == 0) {
                //                         sandmap.players[Math.abs(sandmap.turn-1)].units[t].selected = 0
                //                     }
                //                 }
                //             }
                //         }
                //     }
                // }
            }
            selectrect = new Tile(0, 0, 0, 0, "transparent")
            // }
        })
        function continued_stimuliMenu(e) {
            // if(e.button == 0){
            FLEX_engine = canvas.getBoundingClientRect();
            XS_engine = e.clientX - FLEX_engine.left;
            YS_engine = e.clientY - FLEX_engine.top;
            TIP_engine.x = XS_engine
            TIP_engine.y = YS_engine
            TIP_engine.body = TIP_engine

        }
        function continued_stimuli(e) {
            // if(e.button == 0){
            FLEX_engine = canvas.getBoundingClientRect();
            XS_engine = e.clientX - FLEX_engine.left;
            YS_engine = e.clientY - FLEX_engine.top;
            TIP_engine.x = XS_engine
            TIP_engine.y = YS_engine
            TIP_engine.body = TIP_engine

            if (TIP_engine.x <= sandmap.window.body.x + sandmap.window.body.width) {

                if (keysPressed['q'] || sandmap.players[sandmap.turn].Bflag == 1) {
                    const structuredpoint = new Point(0, 0)
                    structuredpoint.x += sandmap.window.guide.x
                    structuredpoint.y += sandmap.window.guide.y
                    structuredpoint.x += (TIP_engine.x * .5)
                    structuredpoint.y += (TIP_engine.y * .5)
                    structuredpoint.x = Math.min(Math.max(0,Math.floor(structuredpoint.x * .1)),worldscale)
                    structuredpoint.y = Math.min(Math.max(0,Math.floor(structuredpoint.y * .1)),worldscale)
                    sandmap.players[sandmap.turn].selected_tile = sandmap.blocks[structuredpoint.x][structuredpoint.y]

                    let wet = 0
                    for (let t = 0; t < sandmap.players[sandmap.turn].buildings.length; t++) {
                        if (sandmap.players[sandmap.turn].selected_tile == sandmap.players[sandmap.turn].buildings[t].tile) {
                            wet = 1
                        }
                    }
                    // if (sandmap.players[sandmap.turn].hotrock < 10) {
                    //     wet = 1
                    // }

                    if (sandmap.players[sandmap.turn].blocks[sandmap.players[sandmap.turn].selected_tile.t][sandmap.players[sandmap.turn].selected_tile.k].markdraw !== 1) {
                        wet = 1
                    }

                    //////////console.log("-2")
                    if (wet == 0) {
                        // const building = new Building(sandmap.players[sandmap.turn].selected_tile, sandmap.players[sandmap.turn], 0)

                        //////////console.log("-1")
                        if (sandmap.players[sandmap.turn].type == 5) {
                            sandmap.players[sandmap.turn].buildMound(sandmap.players[sandmap.turn].selected_tile, 0)

                        } else if (sandmap.players[sandmap.turn].type == 7) {
                            sandmap.players[sandmap.turn].buildPond(sandmap.players[sandmap.turn].selected_tile, 0)

                        } else if (sandmap.players[sandmap.turn].type == 9) {
                            sandmap.players[sandmap.turn].buildTree(sandmap.players[sandmap.turn].selected_tile, 0)

                        } else if (sandmap.players[sandmap.turn].type == 10) {
                            sandmap.players[sandmap.turn].buildHive(sandmap.players[sandmap.turn].selected_tile, 0)

                        } else {
                            sandmap.players[sandmap.turn].buildWall(sandmap.players[sandmap.turn].selected_tile, 0)

                        }


                    }

                    selectrect = new Tile(0, 0, 0, 0, "transparent")
                } else if (keysPressed['c'] || sandmap.players[sandmap.turn].Nflag == 1) {
                    selectrect = new Tile(0, 0, 0, 0, "transparent")
                } else if (keysPressed['e'] || sandmap.players[sandmap.turn].Mflag == 1) {
                    selectrect = new Tile(0, 0, 0, 0, "transparent")
                } else if (keysPressed['r'] || sandmap.players[sandmap.turn].Gflag == 1) {
                    const structuredpoint = new Point(0, 0)
                    structuredpoint.x += sandmap.window.guide.x
                    structuredpoint.y += sandmap.window.guide.y
                    structuredpoint.x += (TIP_engine.x * .5)
                    structuredpoint.y += (TIP_engine.y * .5)
                    structuredpoint.x = Math.floor(structuredpoint.x * .1)
                    structuredpoint.y = Math.floor(structuredpoint.y * .1)
                    sandmap.players[sandmap.turn].selected_tile = sandmap.blocks[structuredpoint.x][structuredpoint.y]

                    let wet = 0
                    for (let t = 0; t < sandmap.players[sandmap.turn].buildings.length; t++) {
                        if (sandmap.players[sandmap.turn].selected_tile == sandmap.players[sandmap.turn].buildings[t].tile) {
                            wet = 1
                        }
                    }
                    // if (sandmap.players[sandmap.turn].hotrock < 10) {
                    //     wet = 1
                    // }

                    if (sandmap.players[sandmap.turn].blocks[sandmap.players[sandmap.turn].selected_tile.t][sandmap.players[sandmap.turn].selected_tile.k].markdraw !== 1) {
                        wet = 1
                    }
                    if (wet == 0) {
                        // const building = new Building(sandmap.players[sandmap.turn].selected_tile, sandmap.players[sandmap.turn], 0)

                        sandmap.players[sandmap.turn].buildGate(sandmap.players[sandmap.turn].selected_tile, 0)
                    }
                    selectrect = new Tile(0, 0, 0, 0, "transparent")
                } else {

                    const structuredpoint = new Point(0, 0)
                    structuredpoint.x += sandmap.window.guide.x
                    structuredpoint.y += sandmap.window.guide.y
                    structuredpoint.x += (TIP_engine.x * .5)
                    structuredpoint.y += (TIP_engine.y * .5)
                    structuredpoint.x1 = Math.ceil(structuredpoint.x * .1)
                    structuredpoint.y1 = Math.ceil(structuredpoint.y * .1)
                    structuredpoint.x = Math.floor(structuredpoint.x * .1)
                    structuredpoint.y = Math.floor(structuredpoint.y * .1)



                    let xshifter = 0
                    let yshifter = 0
                    if ((structuredpoint.x1 - rectstart.x) <= 0) {
                        xshifter = 10
                    }
                    if ((structuredpoint.y1 - rectstart.y) <= 0) {
                        yshifter = 10
                    }


                    if (keysPressed['r'] || sandmap.players[sandmap.turn].Gflag == 1) {
                    } else if (keysPressed['c'] || sandmap.players[sandmap.turn].Nflag == 1) {
                    } else if (keysPressed['e'] || sandmap.players[sandmap.turn].Mflag == 1) {
                    } else if (keysPressed['q'] || sandmap.players[sandmap.turn].Bflag == 1) {
                    } else {

                        selectrect = new Tilex((rectstart.x * 10) + xshifter, (rectstart.y * 10) + yshifter, ((structuredpoint.x1 - rectstart.x) * 10) - xshifter, ((structuredpoint.y1 - rectstart.y) * 10) - yshifter, sandmap.players[sandmap.turn].color + "22")
                        if (selectrect.width < 0) {
                            selectrect.x += selectrect.width
                            selectrect.width = Math.abs(selectrect.width)
                        }
                        if (selectrect.height < 0) {
                            selectrect.y += selectrect.height
                            selectrect.height = Math.abs(selectrect.height)
                        }
                    }



                    // //////////console.log(selectrect)
                    // selectrect.draw()
                    // sandmap.players[sandmap.turn].selected_tile = sandmap.blocks[structuredpoint.x][structuredpoint.y]
                    // sandmap.turn++
                    // sandmap.turn%=sandmap.players.length


                }


            } else {
                if (sandmap.window.minibody.isPointInside(TIP_engine)) {
                    const structuredpoint = new Point(0, 0)

                    let inverter = ((.28125) / worldscale) * 128
                    const inv = 1 / inverter
                    structuredpoint.x += (TIP_engine.x - sandmap.window.minibody.x) * inv
                    structuredpoint.y += (TIP_engine.y - sandmap.window.minibody.y) * inv
                    sandmap.window.guide.x = structuredpoint.x - (sandmap.window.body.width * .25)
                    sandmap.window.guide.y = structuredpoint.y - (sandmap.window.body.height * .25)
                }
            }
            // }
        }
    }
    function gamepad_control(object, speed = 1) { // basic control for objects using the controler
//         //////////console.log(gamepadAPI.axesStatus[1]*gamepadAPI.axesStatus[0]) //debugging
        if (typeof object.body != 'undefined') {
            if(typeof (gamepadAPI.axesStatus[1]) != 'undefined'){
                if(typeof (gamepadAPI.axesStatus[0]) != 'undefined'){
                object.body.x += (gamepadAPI.axesStatus[0] * speed)
                object.body.y += (gamepadAPI.axesStatus[1] * speed)
                }
            }
        } else if (typeof object != 'undefined') {
            if(typeof (gamepadAPI.axesStatus[1]) != 'undefined'){
                if(typeof (gamepadAPI.axesStatus[0]) != 'undefined'){
                object.x += (gamepadAPI.axesStatus[0] * speed)
                object.y += (gamepadAPI.axesStatus[1] * speed)
                }
            }
        }
    }
        function gamepad_control2(object, speed = 1) { // basic control for objects using the controler
    //         //////////console.log(gamepadAPI.axesStatus[1]*gamepadAPI.axesStatus[0]) //debugging
            if (typeof object.body != 'undefined') {
                if(typeof (gamepadAPI.axesStatus[3]) != 'undefined'){
                    if(typeof (gamepadAPI.axesStatus[2]) != 'undefined'){
                    object.body.x += (gamepadAPI.axesStatus[2] * speed)
                    object.body.y += (gamepadAPI.axesStatus[3] * speed)
                    }
                }
            } else if (typeof object != 'undefined') {
                if(typeof (gamepadAPI.axesStatus[3]) != 'undefined'){
                    if(typeof (gamepadAPI.axesStatus[2]) != 'undefined'){
                    object.x += (gamepadAPI.axesStatus[2] * speed)
                    object.y += (gamepadAPI.axesStatus[3] * speed)
                    }
                }
            }
        }
    function freem(mcount) {
        let mdif = {}
        mdif.x = 0
        mdif.y = 0
        mdif.dx = 0
        mdif.dy = 1
        let sqrt = Math.floor(Math.sqrt(mcount))
        for (let t = 0; t < mcount; t++) {

            if (mdif.y + mdif.y == sqrt || mdif.x + mdif.dx == sqrt || mdif.y + mdif.dy == -1) {
                let tempmdifdx = mdif.dx
                mdif.dx += mdif.dx
                mdif.dx = mdif.dy
            }
            mdif.y += mdif.dy
            mdif.x += mdif.dx

        }
        //////////console.log(mdif)
        return mdif
    }
    function control(object, speed = 1) { // basic control for objects
        if (typeof object.body != 'undefined') {
            if (keysPressed['w']) {
                object.body.y -= speed
            }
            if (keysPressed['d']) {
                object.body.x += speed
            }
            if (keysPressed['s']) {
                object.body.y += speed
            }
            if (keysPressed['a']) {
                object.body.x -= speed
            }
        } else if (typeof object != 'undefined') {
            if (keysPressed['w']) {
                object.y -= speed
            }
            if (keysPressed['d']) {
                object.x += speed
            }
            if (keysPressed['s']) {
                object.y += speed
            }
            if (keysPressed['a']) {
                object.x -= speed
            }
        }
    }

    function playDeathSound(unit) {

        let wet = 1
        if (Math.random() > deathspam) {
            wet = 0
        }
        for (let t = 0; t < sounds.length; t++) {
            if (!sounds[t].paused) {
                // //////////console.log("gh")
                wet = 0
                break
            }
        }

        if (wet == 1) {
            soundCancel()
            deathspam = .1

            if (this.bee == 1) {
                soundCancel()
                beeaudio1.play()
            }else if (unit.goliophyte == 1) {
                golophyteaudio.play()
            } else if (unit.fruiting == 1) {
                buddyaudio.play()
            } else if (unit.sporevizir == 1) {
                vizieraudio.play()
            } else if (unit.seer == 1) {
                seeraudio.play()
            } else if (unit.mycoknight == 1) {
                mycoknightaudio.play()
            } else if (unit.pufffellow == 1) {
                pufffellowaudio.play()
            } else if (unit.pollinator == 1) {
                pollinatoraudio.play()
            } else if (unit.podman == 1) {
                if (Math.random() < .5) {
                    walkinthesunpostskirmish.play()
                } else {
                    gushorgushnot.play()
                }
            } else if (unit.drone == 1) {
                if (Math.random() < .5) {
                    signallost.play()
                } else {
                    error.play()
                }
            } else if (unit.infantry == 1) {
                if (Math.random() < .5) {
                    tellmywife.play()
                } else {
                    deathrattle.play()
                }
            } else if (unit.hamartaninvader == 1) {
                ohgeezyouvehurtme.play()
            } else if (unit.infantry == 2) {
                if (Math.random() < .5) {
                    ahgeez.play()
                } else {
                    goingdown.play()
                }
            } else if (unit.harvester == 1) {
                if (Math.random() < .5) {
                    feelcold.play()
                } else {
                    redlight.play()
                }
            } else if (unit.imago == 1) {
                if (Math.random() < .5) {
                    boh.play()
                } else {
                    die.play()
                }
            } else if (unit.imago == 2) {
                if (Math.random() < .3) {
                    ggd1.play()
                } else if (Math.random() < .3) {
                    ggd3.play()
                } else {
                    ggd2.play()
                }
            } else if (unit.nymph == 2) {
                if (Math.random() < .3) {
                    scuttlerdeath.play()
                } else if (Math.random() < .3) {
                    guessillgothen.play()
                } else {
                    illness.play()
                }
            }
        }
    }
    function playPathSound(unit, tile) {


        let wet = 1
        if (Math.random() > pathspamdrop) {
            wet = 0
        }
        for (let t = 0; t < sounds.length; t++) {
            if (!sounds[t].paused) {
                // //////////console.log("gh")
                wet = 0
                // sounds[t].pause()
                // sounds[t].currentTime = 0
                break
            }
        }

        if (wet == 1) {
            if (tile.hotrock > 0) {

                soundCancel()

                if(unit.beescout == 1){
                    if (Math.random() < .5) {
                        beeaudio5.play()
                    } else   if (Math.random() < .5) {
                        beeaudio2.play()
                    } else {
                        beeaudio4.play()
                    }
                }else  if(unit.beemega == 1){
                    if (Math.random() < .95) {
                        beeaudio6.play()
                    } else {
                        beeaudio9.play()
                    }
                }else if(unit.beeworker == 1){
                    if (Math.random() < .8) {
                        beeaudio8.play()
                    } else {
                        beeaudio3.play()
                    }
                }else  if(unit.beesoldier == 1){
                    if (Math.random() < .5) {
                        beeaudio7.play()
                    } else {
                        beeaudio1.play()
                    }
                }else if (unit.ave == 1) {
                    avesounds[Math.floor(Math.random() * (avesounds.length - 2))].play()
                } else if (unit.imago == 1) {
                    if (Math.random() < .5) {
                        sieveseejunior.play()
                    } else {
                        sieveceaselessly.play()
                    }
                } else if (unit.fruiting == 1) {
                    buddyaudio.play()
                } else if (unit.sporevizir == 1) {
                    vizieraudio.play()
                } else if (unit.seer == 1) {
                    seeraudio.play()
                } else if (unit.mycoknight == 1) {
                    mycoknightaudio.play()
                } else if (unit.podman == 1) {
                    if (Math.random() < .5) {
                        whatdoweneed.play()
                    } else {
                        hotmore.play()
                    }
                } else if (unit.hamartaninvader == 1) {
                    incroiable.play()
                } else if (unit.hamartansoldier == 1) {
                    pagetti.play()
                } else if (unit.imago == 2) {
                    if (Math.random() < .5) {
                        dontstopeating.play()
                    } else {
                        buyburbon.play()
                    }
                } else if (unit.nymph == 2) {
                    if (Math.random() < .5) {
                        whatareyoufreesievingoutput.play()
                    } else {
                        slowworkingsite.play()
                    }
                } else if (unit.drone == 1) {
                    collect.play()
                } else if (unit.nymph == 1) {
                    sureilike.play()
                } else if (unit.infantry == 2) {
                    if (Math.random() < .5) {
                        wealthstatusandpower.play()
                    } else if (Math.random() < .5) {
                        oratleastone.play()
                    } else {
                        jobsthejob.play()
                    }
                } else if (unit.infantry == 1) {
                    righton.play()
                } else if (unit.pollinator == 1) {
                    pollinatoraudio.play()
                } else if (unit.pufffellow == 1) {
                    pufffellowaudio.play()
                } else if (unit.goliophyte == 1) {
                    golophyteaudio.play()
                }


                if (unit.harvester == 1) {
                    if(Math.random() < .98){
                        overtime.play()
                    }else{
                        let playback = Math.floor(Math.random()*5)
                        if(playback == 0){
                            undertime1.play()
                        }else if(playback == 1){
                            undertime2.play()
                        }else if(playback == 2){
                            undertime3.play()
                        }else if(playback == 3){
                            undertime4.play()
                        }else if(playback == 4){
                            undertime5.play()
                        }
                    }
                }


            } else {

                soundCancel()

               
                if(unit.beescout == 1){
                    if (Math.random() < .5) {
                        beeaudio5.play()
                    } else   if (Math.random() < .5) {
                        beeaudio2.play()
                    } else {
                        beeaudio4.play()
                    }
                }else  if(unit.beemega == 1){
                    if (Math.random() < .95) {
                        beeaudio6.play()
                    } else {
                        beeaudio9.play()
                    }
                }else if(unit.beeworker == 1){
                    if (Math.random() < .8) {
                        beeaudio8.play()
                    } else {
                        beeaudio3.play()
                    }
                }else  if(unit.beesoldier == 1){
                    if (Math.random() < .5) {
                        beeaudio7.play()
                    } else {
                        beeaudio1.play()
                    }
                }else if (unit.ave == 1) {
                    avesounds[Math.floor(Math.random() * (avesounds.length - 2))].play()
                } else if (unit.hamartaninvader == 1) {
                    gentlemen.play()
                } else if (unit.hamartansoldier == 1) {
                    if (Math.random() < .5) {
                        seearoundme.play()
                    } else {
                        torus.play()
                    }
                } else if (unit.goliophyte == 1) {
                    golophyteaudio.play()
                } else if (unit.fruiting == 1) {
                    buddyaudio.play()
                } else if (unit.sporevizir == 1) {
                    vizieraudio.play()
                } else if (unit.seer == 1) {
                    seeraudio.play()
                } else if (unit.mycoknight == 1) {
                    mycoknightaudio.play()
                } else if (unit.pufffellow == 1) {
                    pufffellowaudio.play()
                } else if (unit.pollinator == 1) {
                    pollinatoraudio.play()
                } else if (unit.imago == 1) {
                    go.play()
                } else if (unit.imago == 2) {
                    if (Math.random() < .5) {
                        letemseeit.play()
                    } else {
                        hovness.play()
                    }
                } else if (unit.harvester == 1) {
                        let playback = Math.floor(Math.random()*3)
                        if(playback == 0){
                            movin.play()
                        }else if(playback == 1){
                            movin1.play()
                        }else if(playback == 2){
                            movin2.play()
                        }
                } else if (unit.podman == 1) {
                    if (Math.random() < .5) {
                        nahimgood.play()
                    } else if (Math.random() < .5) {
                        whatdoesthisdo.play()
                    } else {
                        maybegofishing.play()
                    }
                } else if (unit.drone == 1) {
                    if (Math.random() < .5) {
                        pathfound.play()
                    } else {
                        pathing.play()
                    }
                } else if (unit.infantry == 2) {
                    if (tile.builtOn == 1) {
                        ivoryeh.play()
                    } else {
                        ivegotanhour.play()
                    }
                } else if (unit.nymph == 1) {
                    spreadoutseemult.play()
                } else if (unit.nymph == 2) {
                    if (Math.random() < .3) {
                        amiaringer.play()  //scuttaud
                    } else if (Math.random() < .3) {
                        yeahimfamiliarsee.play()  //scuttaud
                    } else {
                        hangintheremanlol.play()
                    }
                } else if (unit.infantry == 1) {
                    if (Math.random() < .3) {
                        lesgo.play()
                    } else if (Math.random() < .3) {
                        onmyway.play()
                    } else {
                        donttellme.play()
                    }
                }
            }
        }
    }

    function selectionSound(unit) {

        let wet = 1
        if (Math.random() > selectionspam) {
            wet = 0
        }
        for (let t = 0; t < sounds.length; t++) {
            if (!sounds[t].paused) {
                // //////////console.log("gh")
                wet = 0
                break
            }
        }

        if (wet == 1) {
            selectionspam = .1
            if (unit.selected == 0) {
                // if(Math.random()<soundspamdrop){
                soundCancel()
                if (unit.ave == 1) {
                    avesounds[Math.floor(Math.random() * (avesounds.length - 2))].play()
                }

                if (unit.drone == 1) {
                    if (Math.random() < .5) {
                        hello.play()
                    } else {
                        scanning.play()
                    }
                }
                if (unit.gamergate == 1) {
                    if (Math.random() < .5) {
                        solutionnotobey.play()
                    } else {
                        whatisthis.play()
                    }
                }
                if (unit.nymph == 2) {
                    if (Math.random() < .3) {
                        sureiwillstandup.play()
                    } else if (Math.random() < .3) {
                        suresauna.play()
                    } else {
                        getinthebathsootheyourson.play()
                    }
                }
                if (unit.nymph == 1) {
                    seeasvillaneh.play()
                }
                if (unit.imago == 1) {
                    yeahiminthisroom.play()
                }

                if (unit.pollinator == 1) {
                    pollinatoraudio.play()
                }
                if (unit.pufffellow == 1) {
                    pufffellowaudio.play()
                }
                if (unit.goliophyte == 1) {
                    golophyteaudio.play()
                }
                if (unit.fruiting == 1) {
                    buddyaudio.play()
                }
                if (unit.sporevizir == 1) {
                    vizieraudio.play()
                }
                if (unit.seer == 1) {
                    seeraudio.play()
                }
                if (unit.mycoknight == 1) {
                    mycoknightaudio.play()
                }

                if(unit.beescout == 1){
                    if (Math.random() < .5) {
                        beeaudio5.play()
                    } else   if (Math.random() < .5) {
                        beeaudio2.play()
                    } else {
                        beeaudio4.play()
                    }
                }
                if(unit.beemega == 1){
                    if (Math.random() < .95) {
                        beeaudio6.play()
                    } else {
                        beeaudio9.play()
                    }
                }
                if(unit.beeworker == 1){
                    if (Math.random() < .8) {
                        beeaudio8.play()
                    } else {
                        beeaudio3.play()
                    }
                }
                if(unit.beesoldier == 1){
                    if (Math.random() < .5) {
                        beeaudio7.play()
                    } else {
                        beeaudio1.play()
                    }
                }




                if (unit.infantry == 1) {
                    if (Math.random() < .8) {
                        let playback = Math.floor(Math.random()*5)
                        if(playback == 0){
                            orders.play()
                        }else if(playback == 1){
                            orders1.play()
                        }else if(playback == 2){
                            orders2.play()
                        }else if(playback == 3){
                            orders3.play()
                        }else if(playback == 4){
                            orders4.play()
                        }
                    } else {
                        let playback = Math.floor(Math.random()*5)
                        if(playback == 0){
                            freezin.play()
                        }else if(playback == 1){
                            freezin1.play()
                        }else if(playback == 2){
                            freezin2.play()
                        }else if(playback == 3){
                            freezin3.play()
                        }else if(playback == 4){
                            freezin4.play()
                        }
                        
                    }
                }
                if (unit.hamartaninvader == 1) {
                    if (Math.random() < .5) {
                        zero.play()
                    } else {
                        ritual.play()
                    }
                }
                if (unit.hamartansoldier == 1) {
                    if (Math.random() < .3) {
                        saytome.play()
                    } else if (Math.random() < .3) {
                        snazzyroom.play()
                    } else {
                        snnazzyroom.play()
                    }
                }
                if (unit.infantry == 2) {
                    if (Math.random() < .3) {
                        jobsthejob.play()
                    } else if (Math.random() < .3) {
                        likecontrolling.play()
                    } else if (Math.random() < .3) {
                        veryprecise.play()
                    } else {
                        veryprecise2.play()
                    }
                }
                if (unit.harvester == 1) {
                    if (Math.random() < .9) {
                        rollout.play()
                    } else {
                        hitsomething.play()
                    }
                }
                if (unit.podman == 1) {
                    if (Math.random() < .5) {
                        backwithclass.play()
                    } else {
                        whosthegas.play()
                    }
                }
                // }
            }
        }


    }
    function manageOddAudio() {

        // pollinatortick--
        if (pollinatoraudio.currentTime >= pollinatornotch + pollinatortick) {
            pollinatoraudio.volume *= .93
            // pollinatoraudio.pause()
        } else {
            let volhold = pollinatoraudio.volume
            volhold *= 1.1
            if (volhold <= 1) {
                pollinatoraudio.volume = volhold
            }
        }

        if (pufffellowaudio.currentTime >= puffnotch + pufftick) {
            pufffellowaudio.volume *= .93
            // pollinatoraudio.pause()
        } else {
            let volhold = pufffellowaudio.volume
            volhold *= 1.1
            if (volhold <= 1) {
                pufffellowaudio.volume = volhold
            }
        }


        if (golophyteaudio.currentTime >= golonotch + golotick) {
            golophyteaudio.volume *= .93
            // pollinatoraudio.pause()
        } else {
            let volhold = golophyteaudio.volume
            volhold *= 1.1
            if (volhold <= 1) {
                golophyteaudio.volume = volhold
            }
        }

        if (buddyaudio.currentTime >= buddynotch + buddytick) {
            buddyaudio.volume *= .93
            // pollinatoraudio.pause()
        } else {
            let volhold = buddyaudio.volume
            volhold *= 1.1
            if (volhold <= 1) {
                buddyaudio.volume = volhold
            }
        }

        if (vizieraudio.currentTime >= viznotch + viztick) {
            vizieraudio.volume *= .93
            // pollinatoraudio.pause()
        } else {
            let volhold = vizieraudio.volume
            volhold *= 1.1
            if (volhold <= 1) {
                vizieraudio.volume = volhold
            }
        }

        if (seeraudio.currentTime >= seernotch + seertick) {
            seeraudio.volume *= .93
            // pollinatoraudio.pause()
        } else {
            let volhold = seeraudio.volume
            volhold *= 1.1
            if (volhold <= 1) {
                seeraudio.volume = volhold
            }
        }

        if (mycoknightaudio.currentTime >= myconotch + mycotick) {
            mycoknightaudio.volume *= .93
            // pollinatoraudio.pause()
        } else {
            let volhold = mycoknightaudio.volume
            volhold *= 1.1
            if (volhold <= 1) {
                mycoknightaudio.volume = volhold
            }
        }

        soundspamdrop *= 1.018
        selectionspam *= 1.025
        pathspamdrop *= 1.021
        deathspam *= 1.02489
        if (deathspam > 1) {
            deathspam = 1
        }
        if (pathspamdrop > .25) {
            pathspamdrop = .25
        }
        if (soundspamdrop > .35) {
            soundspamdrop = .35
        }
        if (selectionspam > .4) {
            selectionspam = .4
        }

        // soundspamdrop *= 1.0089

        // if (keysPressed[' ']) {
        //     sandmap.players[sandmap.turn].isAI = 0
        // }

        // sandmap.players[1].units = []
        postwind.play()
        // if(Math.random()<.2){
        //     debreak = 0
        // }
    }
    function getRandomLightColor() { // random color that will be visible on  black background
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++) {
            color += letters[(Math.floor(Math.random() * 12) + 4)];
        }
        return color;
    }
    function getRandomColor() { // random color
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++) {
            color += letters[(Math.floor(Math.random() * 16) + 0)];
        }
        return color;
    }
    function getRandomDarkColor() {// color that will be visible on a black background
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++) {
            color += letters[(Math.floor(Math.random() * 12))];
        }
        return color;
    }
    function castBetween(from, to, granularity = 10, radius = 1) { //creates a sort of beam hitbox between two points, with a granularity (number of members over distance), with a radius defined as well
        const limit = granularity
        const shape_array = []
        for (let t = 0; t < limit; t++) {
            const circ = new Circle((from.x * (t / limit)) + (to.x * ((limit - t) / limit)), (from.y * (t / limit)) + (to.y * ((limit - t) / limit)), radius, "red")
            circ.toRatio = t / limit
            circ.fromRatio = (limit - t) / limit
            shape_array.push(circ)
        }
        return (new Shape(shape_array))
    }

    const setup_canvas = document.getElementById('canvas') //getting canvas from document


    const map_canvas = document.getElementById('map') //getting canvas from document
    map_canvas.width = worldscale * 10
    map_canvas.height = worldscale * 10

    map_context = map_canvas.getContext('2d');
    map_context.imageSmoothingEnabled = false;
    map_canvas.style.background = "tan"

    let swap = new UiRectangle(470, 360, 150, 30, "#FF00aa")
    swap.text = "Take Play Slot 2"
    let swap2 = new UiRectangle(670, 360, 150, 30, "#00FFAA")
    swap2.text = "Take Play Slot 3"
    let swap3 = new UiRectangle(870, 360, 150, 30, "#AAFF00")
    swap3.text = "Take Play Slot 4"
    let swap4 = new UiRectangle(270, 360, 150, 30, "#AA00FF")
    swap4.text = "Take Play Slot 1"


    setUp(setup_canvas)
    canvas_context.imageSmoothingEnabled = false;
    // object instantiation and creation happens here 

    Socketize(ws)
    let onlineNow = 0
    function Socketize(ws) {

        // //////////console.log("0hit")

        // //////////console.log("hit")
        ws.addEventListener("message", ({
            data
        }) => {
            if(campaignController.on == 1 || AImode == 1){
                return
            }

            connectedlight.draw()
            //////////console.log(data)
            if (JSON.parse(data).dot >= 0) {
                if(sandmap.turn > -1){
                let datax = JSON.parse(data).array[0].c
                //console.log(JSON.parse(data).array[0].c)
                let id = datax%1
                ////////console.log(id)
                datax = Math.floor(datax)
                //console.log(datax)
                let pair = invert_cantor(datax)
                //console.log(pair)
                const dot = new UnitCircle(pair.x*10, pair.y*10, 2, sandmap.players[JSON.parse(data).player].color)
                dot.startx = (pair.x*10) + 5
                dot.starty = (pair.y*10) + 5
                dot.track = id
                dot.life = 8
                

                let target = {}
                let min = 100
                let index = -1
                let dindex = -1
                let buildingflag = 0



                               ////console.log(this.shots[t].refhealth.factionNum)
                                const indexer = JSON.parse(data).player /////// sandmap.players.indexOf(this.attacktarget.faction)   // Math.abs((sandmap.players.indexOf(this.faction) + d)%sandmap.players.length)


                    if (JSON.parse(data).dot == 1) {
                                                for(let k = 0;k<sandmap.players[indexer].units.length;k++){
                                                    if(Math.abs(dot.track-sandmap.players[sandmap.turn].units[k].id) < min){
                                                        min = Math.abs(dot.track-sandmap.players[sandmap.turn].units[k].id)
                                                        index = k
                                                        dindex = indexer
                                                        buildingflag = 0
                                                    }
                                                }
                    }else  if (JSON.parse(data).dot == 2) {
                                                for(let k = 0;k<sandmap.players[indexer].buildings.length;k++){
                                                    if(Math.abs(dot.track-sandmap.players[sandmap.turn].buildings[k].id) < min){
                                                        min = Math.abs(dot.track-sandmap.players[sandmap.turn].buildings[k].id)
                                                        index = k
                                                        buildingflag = 1
                                                        dindex = indexer
                                                    }
                                                }
                    }
                                        if(index != -1){

                if(buildingflag == 1){
                ////////console.log(index)
                dot.chase = sandmap.players[sandmap.turn].buildings[index]
                //console.log(dot)
                }else if(buildingflag == 0){
                ////////console.log(index)
                dot.chase = sandmap.players[sandmap.turn].units[index]
                }else{
                ////////console.log(index)
                    let obj = {}
                    obj.x = 0
                    obj.y = 0
                    obj.body = {}
                    obj.body.x = 0
                    obj.body.y = 0
                    dot.chase = obj
                }
                                        }else{
                    let obj = {}
                    obj.x = 0
                    obj.y = 0
                    obj.body = {}
                    obj.body.x = 0
                    obj.body.y = 0
                    dot.chase = obj
                }

                sandmap.players[sandmap.turn].enemyBullets.push(dot)
                }
            } 
            if (JSON.parse(data).grid >= 0) {
                let playertaker = JSON.parse(data).player
                //////////console.log(playertaker)
                if(playertaker == 1){
                swap.draw = empty
                swap.stop = 1
                }else   if(playertaker == 2){
                swap2.draw = empty
                swap2.stop = 1
                }else   if(playertaker == 3){
                swap3.draw = empty
                swap3.stop = 1
                }else   if(playertaker == 0){
                swap4.draw = empty
                swap4.stop = 1
                }
                //////////console.log(data)
                //     //////////console.log(JSON.parse(data))
                // if (gameIDs.includes(JSON.parse(data).id)) {
                //     sandmap.players[Math.abs(sandmap.turn-1)] = new Player(JSON.parse(data))


                // for (let t = 0; t < sandmap.blocks.length; t++) {
                //     for (let k = 0; k < sandmap.blocks[t].length; k++) {
                //         sandmap.blocks[t][k].builtOn = 0
                //         sandmap.blocks[t][k].dirt = 0
                //         sandmap.blocks[t][k].spiretile = 0
                //     }
                // }

                //spliceout

                                for(let d = 1;d<sandmap.players.length;d++){
                                const indexer = Math.abs((sandmap.turn + d)%sandmap.players.length)
                                    for (let t = 0; t < sandmap.players[indexer].units.length; t++) {
                                        sandmap.players[indexer].units[t].tile.walkable = true
                                        sandmap.players[indexer].units[t].tile.occupied = false
                                    }
                                }


                //needs lobby
            if (JSON.parse(data).grid == 1) {
                onlineNow = 1
                if((controlking != 1 && playstart != 1) && takenMap != 1){
                takenMap = 1
                unitcap = JSON.parse(data).unitcap
                mapindex = JSON.parse(data).map
                worldscale = JSON.parse(data).mapsize
                let resizeMap = new MapResizer(worldscale, 0)
                let mapfix  = new  Mapskinner(maplist[mapindex])
                }


                sandmap.players[JSON.parse(data).player] = new Player("Connected guy", "Red", 0, 0, JSON.parse(data).array)
            }else{
                onlineNow = 1
                if((controlking != 1 && playstart != 1) && takenMap != 1){
                takenMap = 1
                unitcap = JSON.parse(data).unitcap
                mapindex = JSON.parse(data).map
                worldscale = JSON.parse(data).mapsize
                let resizeMap = new MapResizer(worldscale, 0)
                let mapfix  = new  Mapskinner(maplist[mapindex])
                }
                sandmap.players[JSON.parse(data).player].unitize(JSON.parse(data).array, JSON.parse(data).player)

                                for(let d = 1;d<sandmap.players.length;d++){
                                const indexer = Math.abs((sandmap.turn + d)%sandmap.players.length)
                                    for (let t = 0; t < sandmap.players[indexer].units.length; t++) {
                                        sandmap.players[indexer].units[t].tile.walkable = false
                                        sandmap.players[indexer].units[t].tile.occupied = true
                                    }
                                }
                                for(let d = 1;d<sandmap.players.length;d++){
                                const indexer = Math.abs((sandmap.turn + d)%sandmap.players.length)
                                    for (let t = 0; t < sandmap.players[indexer].buildings.length; t++) {
                                        sandmap.players[indexer].buildings[t].tile.walkable = false
                                        sandmap.players[indexer].buildings[t].tile.builtOn = 1
                                    }
                                }

            }
            } else if (JSON.parse(data).d != 0) {

            onlineNow = 1
            if(JSON.parse(data).p != sandmap.turn){
                return
            }
                //////////console.log(data)
                // let idvariance = .0019
                //////////console.log(JSON.parse(data))
                //////////console.log(data)
                //////////console.log(sandmap.players[sandmap.turn].units)
                //////////console.log(data)
                //////////console.log(sandmap.players[Math.abs(sandmap.turn-1)].units[JSON.parse(data).index].health )
            if (JSON.parse(data).b == 0) {
                for (let t = 0; t < sandmap.players[Math.abs(sandmap.turn)].units.length; t++) {
                let idvariance = .0019
                    // //////////console.log(sandmap.players[Math.abs(sandmap.turn)].units[t].id,JSON.parse(data).index)
                    if (sandmap.players[Math.abs(sandmap.turn)].units[t].id >= JSON.parse(data).i - idvariance && sandmap.players[Math.abs(sandmap.turn)].units[t].id <= JSON.parse(data).i + idvariance) {
                        sandmap.players[Math.abs(sandmap.turn)].units[t].health -= JSON.parse(data).d
                        if(sandmap.players[Math.abs(sandmap.turn)].units[t].health < 0){
                            sandmap.players[Math.abs(sandmap.turn)].units[t].health = -1
                        }
                    }
                }
            }else{
                for (let t = 0; t < sandmap.players[Math.abs(sandmap.turn)].buildings.length; t++) {
                let idvariance = .001
                    //////////console.log(sandmap.players[Math.abs(sandmap.turn)].buildings[t].id,JSON.parse(data).index)
                    if (sandmap.players[Math.abs(sandmap.turn)].buildings[t].id >= JSON.parse(data).i - idvariance && sandmap.players[Math.abs(sandmap.turn)].buildings[t].id <= JSON.parse(data).i + idvariance) {
                        sandmap.players[Math.abs(sandmap.turn)].buildings[t].health -= JSON.parse(data).d
                        if(sandmap.players[Math.abs(sandmap.turn)].buildings[t].health < 0){
                            sandmap.players[Math.abs(sandmap.turn)].buildings[t].health = -1
                        }
                    }
                }
            }
                //////////console.log(sandmap.players[Math.abs(sandmap.turn-1)].units[JSON.parse(data).index].health )
                //     gameIDs.push(JSON.parse(data).id)
            } 
            // } else {
            //     // if (booter.running == 0) {
            //     //     return
            //     // }
            //     // textcanvas_context.clearRect(0, 320 + textscroll, 1000, 40)
            //     // textcanvas_context.font = "12px arial"
            //     // textcanvas_context.fillStyle = JSON.parse(data).color
            //     // if (typeof JSON.parse(data).name != "undefined") {


            //     //     let ypointer = 300 + textscroll
            //     //     let stoarr = (`(${JSON.parse(data).name}) ` + ' ' + JSON.parse(data).text).split('')
            //     //     let stostring = ''
            //     //     for (let t = 0; t < stoarr.length; t++) {
            //     //         const width = textcanvas_context.measureText(stostring + '' + stoarr[t]).width
            //     //         if (width > textcanvas.width - 12) {
            //     //             textcanvas_context.fillText(stostring + '' + stoarr[t], 0, ypointer)
            //     //             ypointer += 12
            //     //             textscroll += 12
            //     //             stostring = ''
            //     //         } else {
            //     //             stostring = stostring + "" + stoarr[t]
            //     //             if (t == stoarr.length - 1) {
            //     //                 textscroll += 12
            //     //                 textcanvas_context.fillText(stostring, 0, ypointer)
            //     //             }
            //     //         }
            //     //     }
            //     //     //////////console.log(JSON.parse(data).measure)
            //     // }
            // }
        })
    }





    class Tile {
        constructor(x, y, width, height, color, id, size, posx, posy, walkable) {

            this.occupant = {}
            this.occupant.moving = false
            this.occupant.faction = {}
            this.occupant.faction.id = -1
            this.occupant.id = -1
            this.faction = -1
            this.factionsrock = []
            this.factions = []
            this.counterset = 0
            this.slime = false
            this.counter = 0
            this.x = x
            this.builtOn = 0
            this.y = y
            this.height = height
            this.width = width
            this.color = color
            this.xmom = 0
            this.ymom = 0
            this.koffset = 0
            this.toffset = 0
            this.occupied = false
            // this.markdraw = 1 //remove for fog
            this.breaker = []
            var F;

            var parent;
            // this.inPath = false;
            this.getGCost = this.getValueG;
            this.getHCost = this.getValueH;
            this.g = 0
            this.weight = 1
            this.size = size;
            this.posx = posx;
            this.posy = posy;
            this.walkable = walkable;
            // if (Math.random() < .01) {
            //     if (this.hotrock != 1 && this.hotrock != 2) {
            //         this.walkable = false
            //         this.ice = 1
            //         this.color = "#AAFFFF"
            //     }
            // }

            // if((this.x+this.y) > 2400 && (this.x+this.y) < 2700 ){
            //     this.walkable = false
            //     this.occupied = true
            //     this.occupant = {}
            //     this.occupant.moving = false
            //     this.occupant.faction = {}
            //     this.occupant.faction.id = -1
            //     this.pit = 1
            //     this.color = "#000000"
            // }

            //icebar
            // if(this.x > 20){
            //     if(this.x < 1260){
            //         if(this.y > 500){
            //             if(this.y < 780){
            //                 this.walkable = false
            //                 this.ice = 1
            //                 this.color = "#AAFFFF"
            //             }
            //         }
            //     }
            // }

            this.id = id;
        }
        isWall(agent) {
            let pass = false
            if (this.walkable == false) {
                pass = true
            }
            if (this.ice == 1) {
                pass = true
            }
            if (this.occupied == true && agent.id != this.occupant.id) {
                pass = true
            }
            return pass
        }


        getCost(fromNeighbor) {
            if (sandmap.diagonal == false && sandmap.slimeflag != 1) { //edit???
                //////////console.log("dd")
                if (fromNeighbor.slime == true) {
                    if (this.slime == true) {
                        if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {
                            return -(1.1 * 1.4) * this.weight
                        } else {
                            return -1.1 * this.weight
                        }
                    } else {

                        if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {
                            return 1405.1 * this.weight
                        } else {
                            return 1005.1 * this.weight
                        }
                    }
                } else {

                    if (this.slime == true) {
                        if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {
                            return -(6.1 * 1.4) * this.weight
                        } else {
                            return -6.1 * this.weight
                        }
                    } else {
                        if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {
                            return this.weight * 14.11421; //oh shit was this supposed to be 17?
                        }
                        return this.weight * 10;
                    }
                }
            } else {
                if (fromNeighbor && fromNeighbor.x != this.x && fromNeighbor.y != this.y) {
                    return this.weight * 1.41421;
                }
                return this.weight;
            }
        }
        toString() {
            return "[" + this.x + " " + this.y + "]";
        }
        createStartNode() {
            // nodeDrawer(gctx, this, 2, "black", "#00FFFF88");

        }
        createEndNode() {
            // nodeDrawer(gctx, this, 2, "black", "#FFFF0088");

        }
        toggleWalkable() {
            this.walkable = !this.walkable;
        }
        getValueF() {
            //this is a problem
            var fValue = (this.getValueH()) + (this.getValueG());

            return (fValue);
        }
        getValueH() {
            var endNodePosition = {
                posx: endPoint.x,
                posy: endPoint.y
            };

            return (getDistance(this, endNodePosition));

        }
        getValueG() {
            var startPointPosition = {
                posx: endPoint.x,
                posy: endPoint.y
            };
            return (getDistance(this, startPointPosition));
        }
        createWall() {
            // nodeDrawer(gctx, this, 2, "transparent", "black");

        }
        drawOpenNode() {
            // nodeDrawer(gctx, this, 2, "transparent", "transparent");

        }
        drawClosedNode() {
            // nodeDrawer(gctx, this, 2, "transparent", "transparent");
        }
        drawPath() {
            // nodeDrawer(gctx, this, 2, "transparent", "#FF000033");
        }
        drawNode() {

            //gctx.beginPath();
            //gctx.lineWidth = ".1";
            //gctx.strokeStyle = "black";
            //gctx.fillStyle = "transparent";

            // const link = new Line(this.posx, this.posy, bottle.crew[bottle.selectedcrew].body.x-100, bottle.crew[bottle.selectedcrew].body.y-300, "red", 1)
            // if (link.hypotenuse() < 108) {
            // //////////console.log(link)
            // //////////console.log(bottle)
            // }
            // const roundedx = (Math.round((startPoint.x) / 10))
            // const roundedy = (Math.round((startPoint.y) / 10))
            // if (this.walkable !== false) {
            //     //gctx.fillRect(this.posx, this.posy, this.size, this.size);
            //     //gctx.rect(this.posx, this.posy, this.size, this.size);
            //     //gctx.closePath();
            //     //gctx.stroke();
            // }
            // if (this.inPath === true) {
            //     // this.drawPath();
            // } else if (this.walkable === false) {
            //     // //////////console.log(this)

            //     // this.createWall();
            //     return;
            //     // }else if (link.hypotenuse() < 11) {
            // } else if (this.posx == roundedx && this.posy == roundedy) {
            //     //   //////////console.log("hit the startNode");
            //     //   this.createStartNode();
            //     return;
            // } else if (this.posx == endPoint.x && this.posy == endPoint.y) {
            //     //   this.createEndNode();

            // }

        }
        hotdraw() {
            if (this.sourcerock <= 0 && this.hotrock != 0) {
                this.hotrock = 0
                // this.color = "#AACCFF"
                sandmap.hotrocks.splice(sandmap.hotrocks.indexOf(this), 1)
            }
        }
        dirtdraw() {
            if (this.dirt == 1) {
                map_context.drawImage(rawdirt, 0, 0, rawdirt.width, rawdirt.height, (this.x + 5) - 100, (this.y + 5) - 100, 200, 200)
            }
        }
        iceDraw(context) {
            if (this.ice == 1) {
                this.walkable = false
                if(typeof this.icetype == "undefined"){
                    this.icetype = Math.floor(Math.random()*15)
                }

                context.drawImage(nowalksheet, 0 + ((this.icetype * 10) % 150), 0, 10, 10, Math.floor(this.x), Math.floor(this.y), 10, 10)
                // context.drawImage(nowalk, this.x, this.y)
            }
            if (this.pit == 1) {
                this.walkable = false
                context.drawImage(occupiedpit, this.x, this.y)
            }
        }
        draw() {
            this.counterset++
            if (this.counterset % 3 == 0) {
                this.counter++
            }
            if (this.sourcerock <= 0 && this.hotrock != 0) {
                this.hotrock = 0
                // this.color = "#AACCFF"
                sandmap.hotrocks.splice(sandmap.hotrocks.indexOf(this), 1)
            }



            if (this.ice == 1) {
                this.walkable = false
            } else if (this.hotrock == 1) { // || this.builtOn == 1
                sandmap.hotrockCanvas_context.drawImage(hotrock1, this.x, this.y)
            } else if (this.hotrock == 2) {
                sandmap.hotrockCanvas_context.drawImage(hotrock2, (this.counter % 7) * 14, 0, 14, 14, this.x - 2, this.y - 2, 14, 14) // real 14
            }

        }
        move() {
            this.x += this.xmom
            this.y += this.ymom
        }
        isPointInside(point) {
            if (point.x >= this.x) {
                if (point.y >= this.y) {
                    if (point.x <= this.x + this.width) {
                        if (point.y <= this.y + this.height) {
                            return true
                        }
                    }
                }
            }
            return false
        }
        doesPerimeterTouch(point) {
            if (point.x + point.radius >= this.x) {
                if (point.y + point.radius >= this.y) {
                    if (point.x - point.radius <= this.x + this.width) {
                        if (point.y - point.radius <= this.y + this.height) {
                            return true
                        }
                    }
                }
            }
            return false
        }
    }

    class Tilex {
        constructor(x, y, width, height, color, id, size, posx, posy, walkable) {
            this.x = x
            this.y = y
            this.height = height
            this.width = width
            this.color = color
            this.xmom = 0
            this.ymom = 0
            this.koffset = 0
            this.toffset = 0

            var F;

            var parent;
            // this.inPath = false;
            this.getGCost = this.getValueG;
            this.getHCost = this.getValueH;

            this.size = size;
            this.posx = posx;
            this.posy = posy;
            this.walkable = walkable;
            // if (Math.random() < .01) {
            //     if (this.hotrock != 1 && this.hotrock != 2) {
            //         this.walkable = false
            //         this.ice = 1
            //         this.color = "#AAFFFF"
            //     }
            // }

            this.id = id;
        }

        createStartNode() {
            // nodeDrawer(gctx, this, 2, "black", "#00FFFF88");

        }
        createEndNode() {
            // nodeDrawer(gctx, this, 2, "black", "#FFFF0088");

        }
        toggleWalkable() {
            this.walkable = !this.walkable;
        }
        getValueF() {
            //this is a problem
            var fValue = (this.getValueH()) + (this.getValueG());

            return (fValue);
        }
        getValueH() {
            var endNodePosition = {
                posx: endPoint.x,
                posy: endPoint.y
            };

            return (getDistance(this, endNodePosition));

        }
        getValueG() {
            var startPointPosition = {
                posx: endPoint.x,
                posy: endPoint.y
            };
            return (getDistance(this, startPointPosition));
        }
        createWall() {
            // nodeDrawer(gctx, this, 2, "transparent", "black");

        }
        drawOpenNode() {
            // nodeDrawer(gctx, this, 2, "transparent", "transparent");

        }
        drawClosedNode() {
            // nodeDrawer(gctx, this, 2, "transparent", "transparent");
        }
        drawPath() {
            // nodeDrawer(gctx, this, 2, "transparent", "#FF000033");
        }
        drawNode() {

            //gctx.beginPath();
            //gctx.lineWidth = ".1";
            //gctx.strokeStyle = "black";
            //gctx.fillStyle = "transparent";

            // const link = new Line(this.posx, this.posy, bottle.crew[bottle.selectedcrew].body.x-100, bottle.crew[bottle.selectedcrew].body.y-300, "red", 1)
            // if (link.hypotenuse() < 108) {
            // //////////console.log(link)
            // //////////console.log(bottle)
            // }
            // const roundedx = (Math.round((startPoint.x) / 10))
            // const roundedy = (Math.round((startPoint.y) / 10))
            // if (this.walkable !== false) {
            //     //gctx.fillRect(this.posx, this.posy, this.size, this.size);
            //     //gctx.rect(this.posx, this.posy, this.size, this.size);
            //     //gctx.closePath();
            //     //gctx.stroke();
            // }
            // if (this.inPath === true) {
            //     // this.drawPath();
            // } else if (this.walkable === false) {
            //     // //////////console.log(this)

            //     // this.createWall();
            //     return;
            //     // }else if (link.hypotenuse() < 11) {
            // } else if (this.posx == roundedx && this.posy == roundedy) {
            //     //   //////////console.log("hit the startNode");
            //     //   this.createStartNode();
            //     return;
            // } else if (this.posx == endPoint.x && this.posy == endPoint.y) {
            //     //   this.createEndNode();

            // }

        }
        draw() {
            map_context.fillStyle = this.color
            map_context.fillRect(this.x, this.y, this.width, this.height)

        }
        move() {
            this.x += this.xmom
            this.y += this.ymom
        }
        isPointInside(point) {
            if (point.x >= this.x) {
                if (point.y >= this.y) {
                    if (point.x <= this.x + this.width) {
                        if (point.y <= this.y + this.height) {
                            return true
                        }
                    }
                }
            }
            return false
        }
        doesPerimeterTouch(point) {
            if (point.x + point.radius >= this.x) {
                if (point.y + point.radius >= this.y) {
                    if (point.x - point.radius <= this.x + this.width) {
                        if (point.y - point.radius <= this.y + this.height) {
                            return true
                        }
                    }
                }
            }
            return false
        }
    }


    class FogTile {
        constructor(x, y) {
            this.timer = 100
            this.x = x
            this.y = y
            this.height = 10
            this.width = 10
            this.color = "black"
        }
        draw() {
            map_context.fillStyle = this.color
            map_context.fillRect(this.x, this.y, this.width, this.height)
        }
        isPointInside(point) {
            if (point.x >= this.x) {
                if (point.y >= this.y) {
                    if (point.x <= this.x + this.width) {
                        if (point.y <= this.y + this.height) {
                            return true
                        }
                    }
                }
            }
            return false
        }
        doesPerimeterTouch(point) {
            if (point.x + point.radius >= this.x) {
                if (point.y + point.radius >= this.y) {
                    if (point.x - point.radius <= this.x + this.width) {
                        if (point.y - point.radius <= this.y + this.height) {
                            return true
                        }
                    }
                }
            }
            return false
        }
    }

    class FactionScores {
        constructor(){
            this.firepower = []
            this.collection = [0]
            this.money = [250]
        }

    }


    class ScoreGraph {
        constructor() {
            this.factions = []
            for(let t = 0;t<sandmap.players.length;t++){
                this.factions.push(new FactionScores())
            }
            this.wind = []
            this.granularityLimit = 100
            this.granularity = 1
            this.count = 0
            this.mode = 0
        }
        initialize() {
            this.factions = []
            for(let t = 0;t<sandmap.players.length;t++){
                this.factions.push(new FactionScores())
            }
            this.wind = []
            this.granularityLimit = 100
            this.granularity = 1
            this.count = 0
            this.mode = 0
        }
        add() {
            if (this.count % this.granularity == 0) {

                for(let k = 0;k<sandmap.players.length;k++){
                    let force = 0
                    for (let t = 0; t < sandmap.players[k].units.length; t++) {
                    force += ((Math.sqrt(Math.sqrt(Math.abs(sandmap.players[k].units[t].health))) * Math.sqrt(sandmap.players[k].units[t].defense)) * (Math.sqrt(sandmap.players[k].units[t].damage) * (Math.sqrt(sandmap.players[k].units[t].firerate / ten46))) * (Math.sqrt(sandmap.players[k].units[t].attackrange) * (120 / Math.sqrt(sandmap.players[k].units[t].movespeed)))) / 1000
                    }
                    this.factions[k].firepower.push(force)
                    this.factions[k].money.push(sandmap.players[k].hotrock)
                    this.factions[k].collection.push(sandmap.players[k].income)

                if (this.factions[k].money.length > this.granularityLimit) {
                    this.granularity *= 2
                    this.granularityLimit *= 2
                    for (let t = this.factions[k].money.length - 1; t > 0; t--) {
                        if (t % 2 == 0) {
                            this.factions[k].money.splice(t, 1)
                        }
                    }

                    for (let t = this.factions[k].firepower.length - 1; t > 0; t--) {
                        if (t % 2 == 0) {
                            this.factions[k].firepower.splice(t, 1)
                        }
                    }

                    for (let t = this.factions[k].collection.length - 1; t > 0; t--) {
                        if (t % 2 == 0) {
                            this.factions[k].collection.splice(t, 1)
                        }
                    }

                }

                }
                this.wind.push(sandmap.windspeed)
            }
            this.count++
        }
        draw() {
            this.box = new UiRectangle(0, 0, 1000, 720, "#090909")
            this.button = new UiRectangle(1010, 40, 270, 75, "#333333")
            this.return = new UiRectangle(1010, 140, 270, 75, "#886633")
            this.button.draw()
            this.return.draw()
            canvas_context.fillStyle = "white"
            canvas_context.font = "30px arial"
            canvas_context.fillText("Return", this.return.x + 15, this.return.y + 52)
            this.box.draw()
            if (this.mode == 0) {
                canvas_context.fillStyle = "white"
                canvas_context.font = "30px arial"
                canvas_context.fillText("Mode: Firepower", this.button.x + 15, this.button.y + 52)
                let maxima = []
                for(let k = 0;k<sandmap.players.length;k++){    
                    maxima.push( Math.max(...this.factions[k].firepower))
                }
                const truemax = Math.max(...maxima)
                for(let k = 0;k<sandmap.players.length;k++){    
                this.factions[k].firepowerx = [...this.factions[k].firepower]
                }
                
                for(let k = 0;k<sandmap.players.length;k++){    
                    for (let t = 0; t < this.factions[k].firepower.length; t++) {
                        this.factions[k].firepowerx[t] /= truemax
                    }
                }
                for(let k = 0;k<sandmap.players.length;k++){   
                for (let t = 0; t < this.factions[k].firepower.length; t++) {
                    const x = (1000 / this.factions[k].firepower.length) * t
                    const y = (720 - (this.factions[k].firepowerx[t] * 720))
                    if (t % 2 == 0) {
                        const point = new Circle(x, y, 3, sandmap.players[k].color)
                        point.draw()
                    } else {
                        const point = new Circle(x, y, 3, sandmap.players[k].secondColor)
                        point.draw()
                    }
                }
            }

            } else if (this.mode == 1) {
                canvas_context.fillStyle = "white"
                canvas_context.font = "30px arial"
                canvas_context.fillText("Mode: Hotrock", this.button.x + 15, this.button.y + 52)
                


                let maxima = []
                for(let k = 0;k<sandmap.players.length;k++){    
                    maxima.push( Math.max(...this.factions[k].money))
                }
                const truemax = Math.max(...maxima)
                for(let k = 0;k<sandmap.players.length;k++){    
                this.factions[k].moneyx = [...this.factions[k].money]
                }
                
                for(let k = 0;k<sandmap.players.length;k++){    
                    for (let t = 0; t < this.factions[k].money.length; t++) {
                        this.factions[k].moneyx[t] /= truemax
                    }
                }
                for(let k = 0;k<sandmap.players.length;k++){   
                for (let t = 0; t < this.factions[k].money.length; t++) {
                    const x = (1000 / this.factions[k].money.length) * t
                    const y = (720 - (this.factions[k].moneyx[t] * 720))
                    if (t % 2 == 0) {
                        const point = new Circle(x, y, 1, sandmap.players[k].color)
                        point.draw()
                    } else {
                        const point = new Circle(x, y, 1, sandmap.players[k].secondColor)
                        point.draw()
                    }
                }
            }


            } else if (this.mode == 3) {
                canvas_context.fillStyle = "white"
                canvas_context.font = "30px arial"
                canvas_context.fillText("Mode: Income", this.button.x + 15, this.button.y + 52)
                let maxima = []
                for(let k = 0;k<sandmap.players.length;k++){    
                    maxima.push( Math.max(...this.factions[k].collection))
                }
                const truemax = Math.max(...maxima)
                for(let k = 0;k<sandmap.players.length;k++){    
                this.factions[k].collectionx = [...this.factions[k].collection]
                }
                
                for(let k = 0;k<sandmap.players.length;k++){    
                    for (let t = 0; t < this.factions[k].collection.length; t++) {
                        this.factions[k].collectionx[t] /= truemax
                    }
                }
                for(let k = 0;k<sandmap.players.length;k++){   
                for (let t = 0; t < this.factions[k].collection.length; t++) {
                    const x = (1000 / this.factions[k].collection.length) * t
                    const y = (720 - (this.factions[k].collectionx[t] * 720))
                    if (t % 2 == 0) {
                        const point = new Circle(x, y, 1, sandmap.players[k].color)
                        point.draw()
                    } else {
                        const point = new Circle(x, y, 1, sandmap.players[k].secondColor)
                        point.draw()
                    }
                }
            }
            } else if (this.mode == 2) {
                canvas_context.fillStyle = "white"
                canvas_context.font = "30px arial"
                canvas_context.fillText("Mode: Windspeed", this.button.x + 15, this.button.y + 52)
                const max0 = Math.max(...this.wind)
                const truemax = Math.max(max0, 0)
                this.windx = [...this.wind]
                for (let t = 0; t < this.wind.length; t++) {
                    this.windx[t] /= truemax
                }
                for (let t = 0; t < this.wind.length; t++) {
                    const x = (1000 / this.wind.length) * t
                    const y = (720 - (this.windx[t] * 720))
                    const point = new Circle(x, y, 1, "red")
                    point.draw()
                }
            }
        }
    }


    class MapResizer {
        constructor(size, campaigncase = 0) {
            worldscale = size
            map_canvas.width = worldscale * 10
            map_canvas.height = worldscale * 10

            CANVAS_WIDTH = worldscale * 10;
            CANVAS_HEIGHT = worldscale * 10;
            score.initialize() // = new ScoreGraph()
            campaignController.initialize() // = new Campaign()
            sandmap.initialize(CANVAS_WIDTH, CANVAS_HEIGHT, 0, 0, []) // = new Sandmap(CANVAS_WIDTH, CANVAS_HEIGHT, 0, 0, []);
            start = 0
            playstart = 0
            endgame = 0
            // score = new ScoreGraph()
            score.initialize()
            start = 0
            for (let t = 0; t < campaignsounds.length; t++) {
                campaignsounds[t].pause()
                campaignsounds[t].currentTime = 0
            }
         
            startGame()

            if (campaigncase == 1) {
                campaignController.on = 1
            } else {
                let mapfix = new Mapskinner(maplist[mapindex])
            }
            playstart = 3
            start = 0
        }
    }

    class Sandmap {
        constructor(width, height, posx, posy, gridPoints) {

            this.canvas = document.createElement('canvas');
            this.canvas.width = worldscale * 10
            this.canvas.height = worldscale * 10
            this.context = this.canvas.getContext('2d');
            this.buildingCanvas = document.createElement('canvas');
            this.buildingCanvas.width = worldscale * 10
            this.buildingCanvas.height = worldscale * 10
            this.buildingCanvas_context = this.buildingCanvas.getContext('2d');
            this.buildingCanvas_context.imageSmoothingEnabled = false
            this.hotrockCanvas = document.createElement('canvas');
            this.hotrockCanvas.width = worldscale * 10
            this.hotrockCanvas.height = worldscale * 10
            this.hotrockCanvas_context = this.hotrockCanvas.getContext('2d');
            this.windspeed = 1
            this.winddiry = 1
            this.winddirx = 0
            this.width = width;
            this.height = height;
            this.posx = posx;
            this.posy = posy;
            this.gridPoints = gridPoints;
            this.turn = -1
            this.blocks = []
            this.fog = []
            let id = 0
            this.diagonal = true
            this.hotrocks = []
            this.players = []
            this.seed = 256 + (Math.floor(Math.random() * 256))

            const f1 = Math.floor(Math.random() * 5)
            const f2 = Math.floor(Math.random() * 5)


            this.players.push(new Player('Earthoids', "#0000FF", 1, 0))
            this.players[0].isAI = 0
            this.players[0].clickrate = -2
            this.players.push(new Player('Earthoids', "#FFFF00", 1, 0))
            this.players[1].isAI = 0
            this.players[1].clickrate = -2
            this.players.push(new Player('Earthoids', "#FF0000", 1, 0))
            this.players[2].isAI = 0
            this.players[2].clickrate = -2
            this.players.push(new Player('Earthoids', "#00FF00", 1, 0))
            this.players[3].isAI = 0
            this.players[3].clickrate = -2
            this.players[1].units = []
            for (let g = 0; g < this.players.length + 1; g++) {
                for (let t = 0; t < worldscale; t++) {
                    const rects = []
                    // const fogs = []
                    for (let k = 0; k < worldscale; k++) {
                        const rect = new Tile(t * 10, k * 10, 10, 10, "#AACCFF", id, 10, t * 10, k * 10, true)
                        // const fogtile = new FogTile(t * 10, k * 10, 10, 10, "#090909", id, 10, t * 10, k * 10, true)

                        rect.t = t
                        rect.k = k
                        if (g == this.players.length) {
                            if (t > 2 && k > 2) {
                                if (t < (worldscale - 3) && k < (worldscale - 3)) {
                                    let bump = 0
                                    // const link = new LineOP(rect, {})
                                    for (let p = 0; p < this.hotrocks.length; p++) {
                                        // link.target = this.hotrocks[p]
                                        if (((Math.abs(rect.t - this.hotrocks[p].t) + Math.abs(rect.k - this.hotrocks[p].k)) * 10) / 1.4 < 120 + ((Math.random() - .5) * 0)) {
                                            // //////////console.log(this.hotrocks)
                                            bump = 1
                                        }
                                    }

                                    if (rect.ice != 1) {
                                        if (bump == 0) { //.009
                                            // rect.hotrock = 1
                                            // rect.sourcerock = 200
                                            // rect.walkable = true
                                            // rect.color = "#DDAA44"
                                            // if (Math.random() < .5) {
                                            rect.hotrock = 2
                                            rect.sourcerock = 400
                                            rect.walkable = true
                                            rect.color = "#AA8822"
                                            // }
                                            if (rect.hotrock == 1 || rect.hotrock == 2) {
                                                this.hotrocks.push(rect)
                                            }
                                        }
                                    }
                                }
                            }
                        }


                        // if(k <= 120 && k >= 0){
                        //     if(t%worldscale < 32 && t%worldscale > 28){
                        //         rect.walkable = false
                        //         rect.ice = 1
                        //         rect.color = "#AAFFFF"
                        //         rect.hotrock = 0
                        //         rect.sourcerock = -1
                        //     }
                        // }
                        // if(k <= worldscale && k >= 8){
                        //     if(t%worldscale < 99 && t%worldscale > 96){
                        //         rect.walkable = false
                        //         rect.ice = 1
                        //         rect.color = "#AAFFFF"
                        //         rect.hotrock = 0
                        //         rect.sourcerock = -1
                        //     }
                        // }
                        rects.push(rect)
                        // fogs.push(fogtile)
                        id++
                    }
                    if (g == this.players.length) {
                        this.blocks.push(rects)
                        // this.fog.push(fogs)
                    } else {
                        this.players[g].blocks.push(rects)
                        // this.players[g].fog.push(fogs)
                    }
                }
            }


            this.window = new Window()
            // this.createGrid()
            this.gridPoints = []

            for (let t = 0; t < this.blocks.length; t++) {
                for (let k = 0; k < this.blocks[t].length; k++) {
                    this.gridPoints.push(this.blocks[t][k])
                }
            }
            //////////console.log(this)
            this.dirtyNodes = []
            this.firstsee = 0
        }
        initialize(width, height, posx, posy, gridPoints) {

            this.canvas = document.createElement('canvas');
            this.canvas.width = worldscale * 10
            this.canvas.height = worldscale * 10
            this.context = this.canvas.getContext('2d');
            this.buildingCanvas = document.createElement('canvas');
            this.buildingCanvas.width = worldscale * 10
            this.buildingCanvas.height = worldscale * 10
            this.buildingCanvas_context = this.buildingCanvas.getContext('2d');
            this.buildingCanvas_context.imageSmoothingEnabled = false
            this.hotrockCanvas = document.createElement('canvas');
            this.hotrockCanvas.width = worldscale * 10
            this.hotrockCanvas.height = worldscale * 10
            this.hotrockCanvas_context = this.hotrockCanvas.getContext('2d');
            this.windspeed = 1
            this.winddiry = 1
            this.winddirx = 0
            this.width = width;
            this.height = height;
            this.posx = posx;
            this.posy = posy;
            this.gridPoints = gridPoints;
            this.turn = -1
            this.blocks = []
            this.fog = []
            let id = 0
            this.diagonal = true
            this.hotrocks = []

            let stok = []
            for(let t = 0;t<this.players.length;t++){
                stok.push([this.players[t].type, this.players[t].name, this.players[t].isAI, this.players[t].clickrate])
            }
            this.players = []
            this.seed = 256 + (Math.floor(Math.random() * 256))

            const f1 = Math.floor(Math.random() * 5)
            const f2 = Math.floor(Math.random() * 5)


            this.players.push(new Player(stok[0][1], "#0000FF", 1, stok[0][0]))
            this.players.push(new Player(stok[1][1], "#FFFF00", 1, stok[1][0]))
            this.players.push(new Player(stok[2][1], "#FF0000", 1, stok[2][0]))
            this.players.push(new Player(stok[3][1], "#00FF00", 1, stok[3][0]))

            for(let t = 0;t<this.players.length;t++){
                this.players[t].isAI = stok[t][2]
                this.players[t].clickrate = stok[t][3]
            }




            for (let g = 0; g < this.players.length + 1; g++) {
                for (let t = 0; t < worldscale; t++) {
                    const rects = []
                    const fogs = []
                    for (let k = 0; k < worldscale; k++) {
                        const rect = new Tile(t * 10, k * 10, 10, 10, "#AACCFF", id, 10, t * 10, k * 10, true)
                        const fogtile = new FogTile(t * 10, k * 10, 10, 10, "#090909", id, 10, t * 10, k * 10, true)

                        rect.t = t
                        rect.k = k
                        if (g == this.players.length) {
                            if (t > 2 && k > 2) {
                                if (t < (worldscale - 3) && k < (worldscale - 3)) {
                                    let bump = 0
                                    // const link = new LineOP(rect, {})
                                    for (let p = 0; p < this.hotrocks.length; p++) {
                                        // link.target = this.hotrocks[p]
                                        if (((Math.abs(rect.t - this.hotrocks[p].t) + Math.abs(rect.k - this.hotrocks[p].k)) * 10) / 1.4 < 120 + ((Math.random() - .5) * 0)) {
                                            // //////////console.log(this.hotrocks)
                                            bump = 1
                                        }
                                    }

                                    if (rect.ice != 1) {
                                        if (bump == 0) { //.009
                                            // rect.hotrock = 1
                                            // rect.sourcerock = 200
                                            // rect.walkable = true
                                            // rect.color = "#DDAA44"
                                            // if (Math.random() < .5) {
                                            rect.hotrock = 2
                                            rect.sourcerock = 400
                                            rect.walkable = true
                                            rect.color = "#AA8822"
                                            // }
                                            if (rect.hotrock == 1 || rect.hotrock == 2) {
                                                this.hotrocks.push(rect)
                                            }
                                        }
                                    }
                                }
                            }
                        }


                        // if(k <= 120 && k >= 0){
                        //     if(t%worldscale < 32 && t%worldscale > 28){
                        //         rect.walkable = false
                        //         rect.ice = 1
                        //         rect.color = "#AAFFFF"
                        //         rect.hotrock = 0
                        //         rect.sourcerock = -1
                        //     }
                        // }
                        // if(k <= worldscale && k >= 8){
                        //     if(t%worldscale < 99 && t%worldscale > 96){
                        //         rect.walkable = false
                        //         rect.ice = 1
                        //         rect.color = "#AAFFFF"
                        //         rect.hotrock = 0
                        //         rect.sourcerock = -1
                        //     }
                        // }
                        rects.push(rect)
                        // fogs.push(fogtile)
                        id++
                    }
                    if (g == this.players.length) {
                        this.blocks.push(rects)
                        // this.fog.push(fogs)
                    } else {
                        this.players[g].blocks.push(rects)
                        // this.players[g].fog.push(fogs)
                    }
                }
            }


            this.window = new Window()
            // this.createGrid()
            this.gridPoints = []

            for (let t = 0; t < this.blocks.length; t++) {
                for (let k = 0; k < this.blocks[t].length; k++) {
                    this.gridPoints.push(this.blocks[t][k])
                }
            }
            //////////console.log(this)
            this.dirtyNodes = []
            this.firstsee = 0

     mapSizer = new UiRectangle(200, 455, 300, 75, "#777777")
     unitCapper = new UiRectangle(680, 455, 300, 75, "#777777")
     mapChooser = new UiRectangle(460, 535, 400, 75, "#777777")
     controlToggle = new UiRectangle(40, 535, 400, 75, "#777777")

     guideplus = new UiRectangle(550, 620, 200, 75, "#333333")
     playbutton = new UiRectangle(80, 620, 200, 75, "#333333")
     aitoggle1 = new UiRectangle(200, 200, 300, 75, "#333333")
    // DropDownFaction
     chartoggle1 = new DropDownFaction(sandmap.players[0])
    //  chartoggle1 = new UiRectangle(200, 300, 300, 75, "#333333")
    //  chartoggle1 = new DropDownDifficulty(sandmap.players[0])
     aitoggle2 = new UiRectangle(680, 200, 300, 75, "#333333")
    //  chartoggle2 = new UiRectangle(680, 300, 300, 75, "#333333")
     chartoggle2 = new DropDownFaction(sandmap.players[1])
     chartoggle3 = new DropDownFaction(sandmap.players[2])
     chartoggle4 = new DropDownFaction(sandmap.players[3])

    //  difftoggle1 = new UiRectangle(200, 100, 450, 75, "#333333")
     difftoggle1 = new DropDownDifficulty(sandmap.players[0])
    //  difftoggle2 = new UiRectangle(680, 100, 450, 75, "#333333")
     difftoggle2 = new DropDownDifficulty(sandmap.players[1])
     difftoggle3 = new DropDownDifficulty(sandmap.players[2])
    //  difftoggle2 = new UiRectangle(680, 100, 450, 75, "#333333")
     difftoggle4 = new DropDownDifficulty(sandmap.players[3])
        }
        cleanDirty() {
            for (var i = 0; i < this.dirtyNodes.length; i++) {
                astar.cleanNode(this.dirtyNodes[i]);
            }
            this.dirtyNodes = [];
        }
        cleanLiar() {
            for (var i = 0; i < this.dirtyNodes.length; i++) {
                liarsastar.cleanNode(this.dirtyNodes[i]);
            }
            this.dirtyNodes = [];
        }
        cleanSlimy() {
            for (var i = 0; i < this.dirtyNodes.length; i++) {
                slimyastar.cleanNode(this.dirtyNodes[i]);
            }
            this.dirtyNodes = [];
        }
        cleanSlime() {
            for (var i = 0; i < this.dirtyNodes.length; i++) {
                slimemakingastar.cleanNode(this.dirtyNodes[i]);
            }
            this.dirtyNodes = [];
        }
        markDirty(node) {
            node.dirty = true
            this.dirtyNodes.push(node);
        }
        allNeighbors(node) {

            var ret = [];
            var x = node.t;
            var y = node.k;
            var grid = this.blocks;

            // West
            if (grid[x - 1] && grid[x - 1][y]) {
                ret.push(grid[x - 1][y]);
            }

            // East
            if (grid[x + 1] && grid[x + 1][y]) {
                ret.push(grid[x + 1][y]);
            }

            // South
            if (grid[x] && grid[x][y - 1]) {
                ret.push(grid[x][y - 1]);
            }

            // North
            if (grid[x] && grid[x][y + 1]) {
                ret.push(grid[x][y + 1]);
            }

            // if (this.diagonal) {
            // Southwest
            if (grid[x - 1] && grid[x - 1][y - 1]) {
                ret.push(grid[x - 1][y - 1]);
            }

            // Southeast
            if (grid[x + 1] && grid[x + 1][y - 1]) {
                ret.push(grid[x + 1][y - 1]);
            }

            // Northwest
            if (grid[x - 1] && grid[x - 1][y + 1]) {
                ret.push(grid[x - 1][y + 1]);
            }

            // Northeast
            if (grid[x + 1] && grid[x + 1][y + 1]) {
                ret.push(grid[x + 1][y + 1]);
            }
            // }
            return ret
        }
        neighbors(node) {

            var ret = [];
            var x = node.t;
            var y = node.k;
            var grid = this.blocks;

            // West
            if (grid[x - 1] && grid[x - 1][y]) {
                ret.push(grid[x - 1][y]);
            }

            // East
            if (grid[x + 1] && grid[x + 1][y]) {
                ret.push(grid[x + 1][y]);
            }

            // South
            if (grid[x] && grid[x][y - 1]) {
                ret.push(grid[x][y - 1]);
            }

            // North
            if (grid[x] && grid[x][y + 1]) {
                ret.push(grid[x][y + 1]);
            }

            if (this.diagonal) {
                // Southwest
                if (grid[x - 1] && grid[x - 1][y - 1]) {
                    ret.push(grid[x - 1][y - 1]);
                }

                // Southeast
                if (grid[x + 1] && grid[x + 1][y - 1]) {
                    ret.push(grid[x + 1][y - 1]);
                }

                // Northwest
                if (grid[x - 1] && grid[x - 1][y + 1]) {
                    ret.push(grid[x - 1][y + 1]);
                }

                // Northeast
                if (grid[x + 1] && grid[x + 1][y + 1]) {
                    ret.push(grid[x + 1][y + 1]);
                }
            }

            return ret;
        }
        createGrid() {
            // //gctx.drawImage(shipImage, 0, 0, shipImage.width/2, shipImage.height/2)
            var tempNode;
            var countNodes = 0;
            //gctx.beginPath();
            //gctx.lineWidth =  0;
            //gctx.strokeStyle = "transparent";
            //gctx.rect(0, 0, this.width, this.height);
            //gctx.stroke();

            for (var i = 0; i < this.width; i += NODESIZE) {
                gridPointsByPos[i] = [];

                for (var j = 0; j < this.height; j += NODESIZE) {
                    gridPointsByPos[i][j] = countNodes;
                    //here's the problem , need to set the walkability of the node without always being true...
                    //////////console.log(countNodes)
                    tempNode = new Tile(i, j, 10, 10, "tan", countNodes, NODESIZE, i, j, true);

                    // const cutOut = [0,1 ,2, 3, 4, 5,6,7, 8, 9, 10, 11, 12,13, 18, 19,20, 32,33,  26, 31, 39, 44, 45, 46, 52, 57,58,59,99, 112, 108, 95, 197, 198, 199, 205, 203, 204, 236, 237, 238, 242, 243,244, 216, 212, 229, 225, 210, 211, 223, 224, 217, 218, 230, 231]
                    // for(let t = 0; t< 1000; t++){
                    //     if(t%13 == 0){
                    //         cutOut.push(t)
                    //     }
                    //     if((t-12)%13 == 0){
                    //         cutOut.push(t)
                    //     }
                    //     if((t-1)%13 == 0){
                    //         if(t>195){
                    //             cutOut.push(t)
                    //         }
                    //     }
                    //     if((t-11)%13 == 0){
                    //         if(t>195){
                    //             cutOut.push(t)
                    //         }
                    //     }
                    // }
                    // for(let t  = 0; t<bottle.crew.length; t++){
                    //     if(tempNode.isPointInside(bottle.crew[t].body)){
                    //         tempNode.walkable = false;
                    //     }
                    // }
                    // if (cutOut.includes(countNodes)){
                    //         tempNode.walkable = false;

                    // }
                    // if (wallSet.has(countNodes)) {
                    // //   //////////console.log("wallSet had countNodes!")
                    //   tempNode.walkable = false;
                    // }

                    // tempNode.drawNode();
                    tempNode.F = tempNode.getValueF();
                    this.gridPoints.push(tempNode);

                    countNodes++;

                }
            }

        }
        drawBackground() {
            // this.context.drawImage(snow, 0, 0, snow.width, snow.height, 0, 0, worldscale*10, worldscale*10)
            for (let t = 0; t < this.blocks.length; t++) {
                for (let k = 0; k < this.blocks[t].length; k++) {
                    this.blocks[t][k].iceDraw(this.context)
                }
            }
        }
        dirtAura() {
            for (let t = 0; t < this.players[this.turn].blocks.length; t++) {
                for (let k = 0; k < this.players[this.turn].blocks[t].length; k++) {
                    if (this.players[this.turn].blocks[t][k].markdraw == 1) {
                        this.blocks[t][k].dirtdraw()
                    }
                }
            }

            for (let t = 0; t < this.blocks.length; t++) {
                for (let k = 0; k < this.blocks[t].length; k++) {
                    if (this.blocks[t][k].aura == 1) {
                        this.blocks[t][k].bodyx.draw()
                        this.blocks[t][k].bodybig.draw()
                    }
                }
            }
        }
        draw() {
            
                    //////////console.log("hit")
            if (campaignController.mission > -1) {
                campaignController.puppet()
            }
            if (this.firstsee == 0) {
                this.drawBackground()
                this.firstsee = 1
                if (campaignController.mission > -1) {
                    for (let t = 0; t < this.players[1].units.length; t++) {
                        // this.players[1].units[t].moved = 1
                        this.players[1].units[t].see()
                        // this.players[1].units[t].attack()
                        // this.players[1].units[t].move()
                    }
                }
                for (let t = 0; t < this.players[0].units.length; t++) {
                    // this.players[0].units[t].moved = 1
                    this.players[0].units[t].see()
                    // this.players[0].units[t].attack()
                    // this.players[0].units[t].move()
                }
            }
            for (let t = 0; t < this.players.length; t++) {
                this.players[t].income = 0
            }

            if (Math.random() < .05) {
                const chooser = Math.floor(Math.random() * 2)
                if (chooser == 0) {
                    if (this.windspeed > .1051) {
                        this.windspeed /= 1.05
                    }
                }
                if (chooser == 1) {
                    if (this.windspeed < 2.37) {
                        this.windspeed *= 1.05
                    }
                }
                if (chooser == 2) {
                    this.winddirx *= -1
                }
                if (chooser == 3) {
                    this.winddiry *= -1
                }
                if (chooser == 4) {
                    this.winddirx = 0
                }
                if (chooser == 5) {
                    this.winddirx = 1
                }
                if (chooser == 6) {
                    this.winddiry = 0
                }
                if (chooser == 7) {
                    this.winddiry = 1
                }
                if (chooser == 8) {
                    this.winddirx = -1
                }
                if (chooser == 9) {
                    this.winddiry = -1
                }
            }

            canvas_context.fillStyle = "black"
            canvas_context.strokeStyle = sandmap.players[sandmap.turn].color
            canvas_context.lineWidth = 1.5
            canvas_context.font = "17px arial"
            // canvas_context.strokeText("Windspeed: " + Math.round(this.windspeed * 2000) + "cm/s", this.window.minibody.x, this.window.minibody.y - 16)
            canvas_context.fillText("Windspeed: " + Math.round(this.windspeed * 2000) + "cm/s", this.window.minibody.x, this.window.minibody.y - 16)
            canvas_context.drawImage(windmeter, 0, 10 * (Math.round(this.windspeed * 10)), windmeter.width, 10, this.window.minibody.x, this.window.minibody.y - 12, 250, 10)


            if (campaignController.mission == -1) {
                for (let k = 0; k < this.players.length; k++) {
                    for (let t = 0; t < this.players[k].units.length; t++) {
                        if (this.players[k].units[t].moved == 1 || ((this.players[k].units[t].seetime % 5 == 0))) {
                            this.players[k].units[t].moved = 0
                            this.players[k].units[t].see()
                        }
                        this.players[k].units[t].seetime++
                    }
                }
            } else {
                for (let k = 0; k < this.players.length; k++) {
                    for (let t = 0; t < this.players[k].units.length; t++) {
                        if (this.players[k].units[t].moved == 1 || ((this.players[k].units[t].seetime % 20 == 0))) {  // || (this.players[k].units[t].seetime % 5 == 0 && sandmap.turn == sandmap.players.indexOf(this.faction)))
                            this.players[k].units[t].moved = 0
                            this.players[k].units[t].see()
                        }
                        this.players[k].units[t].seetime++
                    }
                }
            }

            // this.dirtAura()
            for (let t = 0; t < this.players[this.turn].blocks.length; t++) {
                for (let k = 0; k < this.players[this.turn].blocks[t].length; k++) {
                    if (this.players[this.turn].blocks[t][k].markdraw == 1) {

                        this.blocks[t][k].draw()

                    } else {
                        this.blocks[t][k].hotdraw()

                    }
                }
            }
            for (let t = 0; t < this.players.length; t++) {
                if (this.players[t].isAI == 1) {
                    // if(t == 0){
                    // this.players[t].newAI()
                    this.players[t].ai()
                    // }else{
                    //     this.players[t].oldai()
                    // }

                }
            }
            for (let t = 0; t < this.players.length; t++) {
                this.players[t].draw()
            }


            // this.players[this.turn].fogdraw()
            if (campaignController.mission == -1) {

                for (let t = 0; t < this.players.length; t++) {
                    this.players[t].unitdraw()
                    this.players[t].fogdraw()
                }
                // for (let  t = 0; t < this.players.length; t++) {
                //     this.players[t].fogdraw()
                // }
            } else {
                for (let t = 0; t < this.players.length; t++) {
                    this.players[t].unitdraw()
                    this.players[t].fogdraw()
                }
            }

            for (let t = 0; t < this.players.length; t++) {
                this.players[t].uiDraw()
            }
            for (let t = 0; t < this.players.length; t++) {
                if (t == this.turn) {
                    this.players[t].playerUI.display()
                }
            }


            for (let t = 0; t < this.players.length; t++) {
                this.players[t].slimeflag = 0
            }


            //abstract fog to player teams
            // for (let  t = 0; t < this.fog.length; t++) {
            //     for (let  k = 0; k < this.fog[t].length; k++) {
            //         if (this.players[this.turn].blocks[t][k].markdraw == 1) {
            //             this.players[this.turn].fog[t][k].timer--
            //             if (this.players[this.turn].fog[t][k].timer <= 0) {
            //                 this.players[this.turn].fog[t][k].color = "#09090922"
            //                 this.players[this.turn].fog[t][k].draw()
            //             }
            //         } else {
            //             this.players[this.turn].fog[t][k].draw()
            //         }
            //     }
            // }
            //remove fog/g

            map_context.drawImage(this.players[this.turn].canvasx, 0, 0, worldscale, worldscale, 0, 0, (worldscale * 10), (worldscale * 10))
            // map_context.globalAlpha = 0
            map_context.globalAlpha = .4;
            map_context.drawImage(this.players[this.turn].canvas, 0, 0, worldscale, worldscale, 0, 0, (worldscale * 10), (worldscale * 10))

            map_context.globalAlpha = 1

            this.window.draw()
        }
    }
    class Window {
        constructor() {
            this.body = new Rectangle(0, 0, 900, 720, "transparent")
            this.minibody = new Rectangle(this.body.x + this.body.width + 10, 360, 360, 360, "transparent")
            this.first = 0
            this.guide = new Circle(0,0, 1, "transparent")
            this.seeGuide = new Circle(0, 0, 10, "transparent")
            this.offset = {}
            this.offset.x = 0
            this.offset.y = 0
        }
        draw() {
            if(this.first == 0){
                this.first = 1
                this.guide = new Circle(sandmap.players[sandmap.turn].units[0].body.x-225, sandmap.players[sandmap.turn].units[0].body.y-180, 1, "transparent")
            }
            control(this.guide, 5)
            if(gamepadAPI.buttonPressed('Left-Trigger', true)){
                
            gamepad_control2(this.guide, 5)
            gamepad_control2(this.guide, 5)
            gamepad_control2(this.guide, 5)
            gamepad_control2(this.guide, 5)
            gamepad_control2(this.guide, 5)
            }else{
            gamepad_control2(this.guide, 5)
            }
            gamepad_control(this.offset, 5)
            if(Math.abs(this.offset.x )> 220){
                this.offset.x*=.99
            }
            if(Math.abs(this.offset.y )> 160){
                this.offset.y*=.99
            }
            if(Math.abs(this.offset.x )> 225){
                this.offset.x*=.99
            }
            if(Math.abs(this.offset.y )> 170){
                this.offset.y*=.99
            }
            if(Math.abs(this.offset.x )> 230){
                this.offset.x*=.99
            }
            if(Math.abs(this.offset.y )> 175){
                this.offset.y*=.99
            }
            if (this.guide.x < 0) {
                this.guide.x = 0
            }
            if (this.guide.y < 0) {
                this.guide.y = 0
            }
            if (this.guide.x > map_canvas.width - (this.body.width * .5)) {
                this.guide.x = map_canvas.width - (this.body.width * .5)
            }
            if (this.guide.y > map_canvas.width - (this.body.height * .5)) {
                this.guide.y = map_canvas.width - (this.body.height * .5)
            }
            selectrect.color = (sandmap.players[sandmap.turn].color + "22")
            selectrect.draw()

            canvas_context.drawImage(map_canvas, this.guide.x, this.guide.y, this.body.width * .5, this.body.height * .5, this.body.x, this.body.y, this.body.width, this.body.height)
            canvas_context.drawImage(map_canvas, 0, 0, map_canvas.width, map_canvas.height, this.minibody.x, this.minibody.y, this.minibody.width, this.minibody.height)
            
            canvas_context.strokeStyle = "#FFFFFF"
            canvas_context.lineWidth = 1
            let inverter = ((.28125) / worldscale) * 128
            canvas_context.strokeRect(this.minibody.x + (this.guide.x * inverter), this.minibody.y + (this.guide.y * inverter), (this.body.width * .5) * inverter, (this.body.height * .5) * inverter)

            if(controllerSupport==1){
            this.seeGuide.x = (this.body.x + (this.body.width * .25) + this.offset.x) // inverter
            this.seeGuide.y = (this.body.y + (this.body.height * .25)+ this.offset.y) // inverter

            if(gamepadAPI.buttonPressed('Dpad-Down')){
                this.offset = {}
                this.offset.x = 0
                this.offset.y = 0
            }


            this.seeGuide.x = this.guide.x+(this.body.x + (this.body.width * .25) + this.offset.x) // inverter
            this.seeGuide.y = this.guide.y+(this.body.y + (this.body.height * .25)+ this.offset.y) // inverter


            if(gamepadAPI.buttonPressed('Right-Trigger', true)){
                this.seeGuide.radius*=1.03
                for(let t = 0;t<sandmap.players[sandmap.turn].units.length;t++){
                    if(sandmap.players[sandmap.turn].units[t].body.doesPerimeterTouch(this.seeGuide)){
                        sandmap.players[sandmap.turn].units[t].selected = 1
                    }else{
                        sandmap.players[sandmap.turn].units[t].selected = 0
                    }
                }
            }else{
                this.seeGuide.radius = 10
            }
            if(gamepadAPI.buttonPressed('Left-Trigger')){
                // this.seeGuide.radius*=1.01
                for(let t = 0;t<sandmap.players[sandmap.turn].buildings.length;t++){
                    if(sandmap.players[sandmap.turn].buildings[t].body.doesPerimeterTouch(this.seeGuide)){
                        sandmap.players[sandmap.turn].buildings[t].selected = 1
                    }else{
                    if(!gamepadAPI.buttonPressed('Dpad-Up')){
                        sandmap.players[sandmap.turn].buildings[t].selected = 0
                    }
                    }
                }
            }else{
                // this.seeGuide.radius = 10
            }

            this.seeGuide.x = (this.body.x + (this.body.width * .25) + this.offset.x) // inverter
            this.seeGuide.y = (this.body.y + (this.body.height * .25)+ this.offset.y) // inverter

            this.selcount = 0
            for(let t = 0;t<sandmap.players[sandmap.turn].units.length;t++){
                if(sandmap.players[sandmap.turn].units[t].selected == 1){
                    this.selcount++
                }
            }

            for(let t = 0;t<sandmap.players[sandmap.turn].buildings.length;t++){
                if(sandmap.players[sandmap.turn].buildings[t].selected == 1){
                    this.selcount++
                }
            }

            if(this.selcount == 0){
                //////////console.log(this)
                sandmap.players[sandmap.turn].selected_tile = sandmap.blocks[Math.max(Math.min(Math.floor((this.seeGuide.x+this.guide.x)*.1),worldscale),0)][Math.max(Math.min(Math.floor((this.seeGuide.y+this.guide.y)*.1),worldscale),0)]
                if(gamepadAPI.buttonPressed('Y', true)){

                    let wet = 0
                    for (let t = 0; t < sandmap.players[sandmap.turn].buildings.length; t++) {
                        if (sandmap.players[sandmap.turn].selected_tile == sandmap.players[sandmap.turn].buildings[t].tile) {
                            wet = 1
                        }
                    }
                    if (sandmap.players[sandmap.turn].blocks[sandmap.players[sandmap.turn].selected_tile.t][sandmap.players[sandmap.turn].selected_tile.k].markdraw !== 1) {
                        wet = 1
                    }
                    if (sandmap.players[sandmap.turn].blocks[sandmap.players[sandmap.turn].selected_tile.t][sandmap.players[sandmap.turn].selected_tile.k].markdraw !== 1) {
                        wet = 1
                    }
                    if (wet == 0) {
                        if (sandmap.players[sandmap.turn].type == 5) {
                            if(gamepadAPI.buttonPressed('Y')){
                            sandmap.players[sandmap.turn].buildMound(sandmap.players[sandmap.turn].selected_tile, 0)
                            }

                        } else if (sandmap.players[sandmap.turn].type == 7) {
                            if(gamepadAPI.buttonPressed('Y')){
                            sandmap.players[sandmap.turn].buildPond(sandmap.players[sandmap.turn].selected_tile, 0)
                            }
                            if(gamepadAPI.buttonPressed('A')){
                            sandmap.players[sandmap.turn].buildTeleporter(sandmap.players[sandmap.turn].selected_tile, 0)
                            }

                        } else if (sandmap.players[sandmap.turn].type == 9) {
                            if(gamepadAPI.buttonPressed('Y')){
                            sandmap.players[sandmap.turn].buildTree(sandmap.players[sandmap.turn].selected_tile, 0)
                            }

                        }  else if (sandmap.players[sandmap.turn].type == 10) {
                            if(gamepadAPI.buttonPressed('Y')){
                                sandmap.players[sandmap.turn].buildHive(sandmap.players[sandmap.turn].selected_tile, 0)
                            }

                        }else {
                            sandmap.players[sandmap.turn].buildWall(sandmap.players[sandmap.turn].selected_tile, 0)
                        }
                    }
                }




                if(gamepadAPI.buttonPressed('A')){

                    let wet = 0
                    for (let t = 0; t < sandmap.players[sandmap.turn].buildings.length; t++) {
                        if (sandmap.players[sandmap.turn].selected_tile == sandmap.players[sandmap.turn].buildings[t].tile) {
                            wet = 1
                        }
                    }
                    // if (sandmap.players[sandmap.turn].hotrock < 70) {
                    //     wet = 1
                    // }
                    if (sandmap.players[sandmap.turn].blocks[sandmap.players[sandmap.turn].selected_tile.t][sandmap.players[sandmap.turn].selected_tile.k].markdraw !== 1) {
                        wet = 1
                    }
                    if (wet == 0) {
                                    if(sandmap.players[sandmap.turn].type == 7){
                                        sandmap.players[sandmap.turn].buildTeleporter(sandmap.players[sandmap.turn].selected_tile, 0)
                                    }else{
                                        sandmap.players[sandmap.turn].buildMachineLab(sandmap.players[sandmap.turn].selected_tile, 0)
                                    }
                        // const building = new Building(sandmap.players[sandmap.turn].selected_tile, sandmap.players[sandmap.turn], 0)

                    }
                }
                if(gamepadAPI.buttonPressed('LB')){

                    let wet = 0
                    for (let t = 0; t < sandmap.players[sandmap.turn].buildings.length; t++) {
                        if (sandmap.players[sandmap.turn].selected_tile == sandmap.players[sandmap.turn].buildings[t].tile) {
                            wet = 1
                        }
                    }
                    // if (sandmap.players[sandmap.turn].hotrock < 70) {
                    //     wet = 1
                    // }
                    if (sandmap.players[sandmap.turn].blocks[sandmap.players[sandmap.turn].selected_tile.t][sandmap.players[sandmap.turn].selected_tile.k].markdraw !== 1) {
                        wet = 1
                    }
                    if (wet == 0) {
                        sandmap.players[sandmap.turn].buildGate(sandmap.players[sandmap.turn].selected_tile, 0)
                        // const building = new Building(sandmap.players[sandmap.turn].selected_tile, sandmap.players[sandmap.turn], 0)

                    }
                }
                if(gamepadAPI.buttonPressed('B')){

                    let wet = 0
                    for (let t = 0; t < sandmap.players[sandmap.turn].buildings.length; t++) {
                        if (sandmap.players[sandmap.turn].selected_tile == sandmap.players[sandmap.turn].buildings[t].tile) {
                            wet = 1
                        }
                    }
                    // if (sandmap.players[sandmap.turn].hotrock < 70) {
                    //     wet = 1
                    // }
                    if (sandmap.players[sandmap.turn].blocks[sandmap.players[sandmap.turn].selected_tile.t][sandmap.players[sandmap.turn].selected_tile.k].markdraw !== 1) {
                        wet = 1
                    }
                    if (wet == 0) {
                        sandmap.players[sandmap.turn].buildBarracks(sandmap.players[sandmap.turn].selected_tile, 0)
                        // const building = new Building(sandmap.players[sandmap.turn].selected_tile, sandmap.players[sandmap.turn], 0)

                    }
                }

            }else{
                if(gamepadAPI.buttonPressed('X', true)){
                    sandmap.players[sandmap.turn].selected_tile = sandmap.blocks[Math.floor((this.seeGuide.x+this.guide.x)*.1)][Math.floor((this.seeGuide.y+this.guide.y)*.1)]

                    for(let t = 0;t<sandmap.players[sandmap.turn].buildings.length;t++){
                        if(sandmap.players[sandmap.turn].buildings[t].selected == 1){
                            if(sandmap.players[sandmap.turn].buildings[t].wayfinding == 1){
                                sandmap.players[sandmap.turn].buildings[t].waypoint =   sandmap.players[sandmap.turn].selected_tile
                            }
                        }
                    }
                    for(let t = 0;t<sandmap.players[sandmap.turn].units.length;t++){
                        if(sandmap.players[sandmap.turn].units[t].selected == 1){


                    if (keysPressed['Shift'] || sandmap.players[sandmap.turn].units[t].patrolling == 1) {
                        if (sandmap.players[sandmap.turn].units[t].pathQue.length > 0) {
                            sandmap.players[sandmap.turn].units[t].emergencyTarget = (sandmap.players[sandmap.turn].selected_tile)
                            sandmap.players[sandmap.turn].units[t].pathQue.push(sandmap.players[sandmap.turn].units[t].emergencyTarget)
                        } else {
                            sandmap.players[sandmap.turn].units[t].emergencyTarget = (sandmap.players[sandmap.turn].selected_tile)
                            sandmap.players[sandmap.turn].units[t].pathQue.push(sandmap.players[sandmap.turn].units[t].emergencyTarget)
                            if (sandmap.players[sandmap.turn].units[t].patrolling == 1) {
                                sandmap.players[sandmap.turn].units[t].pathQue.push(sandmap.players[sandmap.turn].units[t].tile)
                            }
                            //////////console.log(sandmap.players[sandmap.turn].units[t].pathQue)
                        }
                    } else {
                        sandmap.players[sandmap.turn].units[t].emergencyTarget = (sandmap.players[sandmap.turn].selected_tile)
                        if (sandmap.players[sandmap.turn].units[t].awaiting == 0) {
                            sandmap.players[sandmap.turn].units[t].pathNow = 1
                        }
                        sandmap.players[sandmap.turn].units[t].pathQue = []
                    }


                    
                            sandmap.players[sandmap.turn].units[t].emergencyTarget = (sandmap.players[sandmap.turn].selected_tile)
                            sandmap.players[sandmap.turn].units[t].selmag =  1
                            sandmap.players[sandmap.turn].units[t].pathNow = 1
                            sandmap.players[sandmap.turn].units[t].shouldMove = 1
                            // sandmap.players[sandmap.turn].units[t].pathQue = []
                        }
                    }
                }
            }


            this.seeGuide.x = (this.body.x + (this.body.width * .25) + this.offset.x) *2// inverter
            this.seeGuide.y = (this.body.y + (this.body.height * .25)+ this.offset.y) *2 // inverter
            this.seeGuide.color = sandmap.players[sandmap.turn].color+"40"
            this.seeGuide.radius *=2
                
            this.seeGuide.draw()
            this.seeGuide.radius *=.50
        }
        }
    }

    class GlobalUI {
        constructor(faction) {
            this.state = 0
            this.faction = faction

        }
        hotkeys() {

            if (this.state == 0) {
            if(keysPressed['q']){
                if(this.faction.Bflag == 1){
                // this.faction.Bflag = 0
                }else{
                this.faction.Bflag = 1
                this.faction.Nflag = 0
                this.faction.Gflag = 0
                this.faction.Mflag = 0
                }
            }
            if(keysPressed['e']){
                if(this.faction.Mflag == 1){
                // this.faction.Mflag = 0
                }else{
                this.faction.Mflag = 1
                this.faction.Nflag = 0
                this.faction.Gflag = 0
                this.faction.Bflag = 0
                }
            }
            if(keysPressed['c']){
                if(this.faction.Nflag == 1){
                // this.faction.Nflag = 0
                }else{
                this.faction.Nflag = 1
                this.faction.Mflag = 0
                this.faction.Gflag = 0
                this.faction.Bflag = 0
                }
            }
            if(keysPressed['r']){
                if(this.faction.Nflag == 1){
                // this.faction.Gflag = 0
                }else{
                this.faction.Gflag = 1
                this.faction.Mflag = 0
                this.faction.Nflag = 0
                this.faction.Bflag = 0
                }
            }
            }
            
            for (let t = 0; t < sandmap.players[sandmap.turn].buildings.length; t++) {
                if (sandmap.players[sandmap.turn].buildings[t].selected == 1) {

                    if (sandmap.players[sandmap.turn].buildings[t].barracks == 1) {
                        if (gamepadAPI.buttonPressed('Y') || keysPressed['q']) {
                            sandmap.players[sandmap.turn].buildings[t].makeInfantry()
                        }
                        if (gamepadAPI.buttonPressed('A') || keysPressed['e']) {
                            sandmap.players[sandmap.turn].buildings[t].makeSniper()
                        }
                    }

                    if (sandmap.players[sandmap.turn].buildings[t].gate == 1) {
                        if (gamepadAPI.buttonPressed('Y') || keysPressed['q']) {
                            // if (sandmap.players[sandmap.turn].buildings[t].tile.occupied !== true) {
                            sandmap.players[sandmap.turn].buildings[t].open *= -1
                            sandmap.players[sandmap.turn].buildings[t].tile.wallflag *= -1
                            if (sandmap.players[sandmap.turn].buildings[t].tile.spiretile != true) {
                                sandmap.players[sandmap.turn].buildings[t].tile.spiretile = true
                            } else {
                                sandmap.players[sandmap.turn].buildings[t].tile.spiretile = false
                            }

                            if (sandmap.players[sandmap.turn].buildings[t].open == 1) {
                                if (Math.random() < soundspamdrop * 2) {
                                    soundCancel()
                                    if (Math.random() < .5) {
                                        opening1.play()
                                    } else {
                                        opening2.play()
                                    }
                                }
                            }
                            if (sandmap.players[sandmap.turn].buildings[t].open == -1) {
                                if (Math.random() < soundspamdrop * 2) {
                                    soundCancel()
                                    if (Math.random() < .3) {
                                        closing1.play()
                                    } else if (Math.random() < .3) {
                                        closing2.play()
                                    } else {
                                        closing3.play()
                                    }
                                }
                            }
                            // }
                        }
                    }

                    if (sandmap.players[sandmap.turn].buildings[t].slime == 1) {
                        if (gamepadAPI.buttonPressed('Y') || keysPressed['q']) {
                            sandmap.players[sandmap.turn].buildings[t].makeFruitingbuddy()
                        }
                        if (gamepadAPI.buttonPressed('B') || keysPressed['c']) {
                            sandmap.players[sandmap.turn].buildings[t].makeSporeseer()
                        }
                        if (gamepadAPI.buttonPressed('A') || keysPressed['e']) {
                            sandmap.players[sandmap.turn].buildings[t].makeVizier()
                        }
                        if (gamepadAPI.buttonPressed('Y') || keysPressed['r']) {
                            sandmap.players[sandmap.turn].buildings[t].makeMycoknight()
                        }

                    }
                    if (sandmap.players[sandmap.turn].buildings[t].egg == 1) {
                        if (gamepadAPI.buttonPressed('Y') || keysPressed['q']) {
                            sandmap.players[sandmap.turn].buildings[t].hatchBuzzlet()
                        }
                        if (gamepadAPI.buttonPressed('B') || keysPressed['c']) {
                            sandmap.players[sandmap.turn].buildings[t].hatchMegagnat()
                        }
                        if (gamepadAPI.buttonPressed('A') || keysPressed['e']) {
                            sandmap.players[sandmap.turn].buildings[t].hatchFlugoon()
                        }
                        if (gamepadAPI.buttonPressed('Y') || keysPressed['r']) {
                            sandmap.players[sandmap.turn].buildings[t].hatchStarbatross()
                        }

                    }
                    if (sandmap.players[sandmap.turn].buildings[t].teleporter == 1) {
                        if (gamepadAPI.buttonPressed('Y') || keysPressed['q']) {
                            sandmap.players[sandmap.turn].buildings[t].teleport()
                        }
                    }
                    if (sandmap.players[sandmap.turn].buildings[t].pond == 1) {
                        if (gamepadAPI.buttonPressed('Y') || keysPressed['q']) {
                            sandmap.players[sandmap.turn].buildings[t].makeAlagadile()
                        }
                        if (gamepadAPI.buttonPressed('B') || keysPressed['c']) {
                            sandmap.players[sandmap.turn].buildings[t].makeBigHunchAlagadile()
                        }
                        if (gamepadAPI.buttonPressed('A') || keysPressed['e']) {
                            sandmap.players[sandmap.turn].buildings[t].makeBigAlagadile()
                        }
                        if (gamepadAPI.buttonPressed('Y') || keysPressed['r']) {
                            sandmap.players[sandmap.turn].buildings[t].makeHunchAlagadile()
                        }

                    }
                    if (sandmap.players[sandmap.turn].buildings[t].beehive == 1) {
                        if (gamepadAPI.buttonPressed('Y') || keysPressed['q']) {
                            sandmap.players[sandmap.turn].buildings[t].makeBeeWorker()
                        }
                        if (gamepadAPI.buttonPressed('B') || keysPressed['c']) {
                            sandmap.players[sandmap.turn].buildings[t].makeBeeScout()
                        }
                        if (gamepadAPI.buttonPressed('A') || keysPressed['e']) {
                            sandmap.players[sandmap.turn].buildings[t].makeBeeSoldier()
                        }
                        if (gamepadAPI.buttonPressed('Y') || keysPressed['r']) {
                            sandmap.players[sandmap.turn].buildings[t].makeBeeMega()
                        }

                    }
                    if (sandmap.players[sandmap.turn].buildings[t].tree == 1) {
                        if (gamepadAPI.buttonPressed('Y') || keysPressed['q']) {
                            sandmap.players[sandmap.turn].buildings[t].makeGogonaut()
                        }
                        if (gamepadAPI.buttonPressed('B') || keysPressed['c']) {
                            sandmap.players[sandmap.turn].buildings[t].makeGogonautTeam()
                        }
                        if (gamepadAPI.buttonPressed('A') || keysPressed['e']) {
                            sandmap.players[sandmap.turn].buildings[t].makeGogonautChampion()
                        }
                        if (gamepadAPI.buttonPressed('Y') || keysPressed['r']) {
                            sandmap.players[sandmap.turn].buildings[t].makeGogonautDefender()
                        }

                    }
                    if (sandmap.players[sandmap.turn].buildings[t].barracks == 2) {
                        if (gamepadAPI.buttonPressed('Y') || keysPressed['q']) {
                            sandmap.players[sandmap.turn].buildings[t].makeScout()
                        }
                        if (gamepadAPI.buttonPressed('A') || keysPressed['e']) {
                            sandmap.players[sandmap.turn].buildings[t].makeHarvester()
                        }
                    }
                    if (sandmap.players[sandmap.turn].buildings[t].assembler == 1) {
                        if (gamepadAPI.buttonPressed('Y') || keysPressed['q']) {
                            sandmap.players[sandmap.turn].buildings[t].makeHamartansoldier()
                        }
                        // if (gamepadAPI.buttonPressed('A') || keysPressed['e']) {
                        //     sandmap.players[sandmap.turn].buildings[t].makeHarvester()
                        // }
                    }
                    if (sandmap.players[sandmap.turn].buildings[t].assembler == 2) {
                        if (gamepadAPI.buttonPressed('Y') || keysPressed['q']) {
                            sandmap.players[sandmap.turn].buildings[t].makeHamartanscout()
                        }
                        // if (gamepadAPI.buttonPressed('A') || keysPressed['e']) {
                        //     sandmap.players[sandmap.turn].buildings[t].makeHarvester()
                        // }
                    }
                    if (sandmap.players[sandmap.turn].buildings[t].assembler == 3) {
                        if (gamepadAPI.buttonPressed('Y') || keysPressed['q']) {
                            sandmap.players[sandmap.turn].buildings[t].makeHamartanworker()
                        }
                        if (gamepadAPI.buttonPressed('A') || keysPressed['e']) {
                            sandmap.players[sandmap.turn].buildings[t].makeHamartaninvader()
                        }
                    }
                    if (sandmap.players[sandmap.turn].buildings[t].bulbplant == 1) {
                        if (gamepadAPI.buttonPressed('Y') || keysPressed['q']) {
                            sandmap.players[sandmap.turn].buildings[t].makeLibrilbianpollinator()
                        }
                    }
                    if (sandmap.players[sandmap.turn].buildings[t].bulbplant == 2) {
                        if (gamepadAPI.buttonPressed('Y') || keysPressed['q']) {
                            sandmap.players[sandmap.turn].buildings[t].makeLibrilbianpufffellow()
                        }
                        if (gamepadAPI.buttonPressed('B') || keysPressed['c']) {
                            sandmap.players[sandmap.turn].buildings[t].makeLibrilbianpodman()
                        }
                        if (gamepadAPI.buttonPressed('A') || keysPressed['e']) {
                            sandmap.players[sandmap.turn].buildings[t].makeLibrilbiangoliophyte()
                        }
                    }
                }
            }
            for (let t = 0; t < sandmap.players[sandmap.turn].buildings.length; t++) {
                if (sandmap.players[sandmap.turn].buildings[t].selected == 1 || sandmap.players[sandmap.turn].buildings[t].selected == 2) {

                    if (gamepadAPI.buttonPressed('LB')|| keysPressed['t']) {
                        sandmap.players[sandmap.turn].buildings[t].wayfinding *= -1
                        if (sandmap.players[sandmap.turn].buildings[t].wayfinding == 1) {
                            sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[4].color = "#094909"
                        } else {
                            sandmap.players[sandmap.turn].buildings[t].commandPanel.commandButtons[4].color = "#090909"
                        }
                    }
                }
            }
            for (let t = 0; t < sandmap.players[sandmap.turn].units.length; t++) {
                if (sandmap.players[sandmap.turn].units[t].selected == 1 || sandmap.players[sandmap.turn].units[t].selected == 2) {

                    if (gamepadAPI.buttonPressed('LB')|| keysPressed['t']) {
                        sandmap.players[sandmap.turn].units[t].patrolling *= -1
                        if (sandmap.players[sandmap.turn].units[t].patrolling == 1) {
                            sandmap.players[sandmap.turn].units[t].commandPanel.commandButtons[4].color = "#094909"
                        } else {
                            sandmap.players[sandmap.turn].units[t].commandPanel.commandButtons[4].color = "#090909"
                        }
                    }
                }
                if (sandmap.players[sandmap.turn].type == 8) {
                    if (gamepadAPI.buttonPressed('RB') || keysPressed['q']) {
                        sandmap.players[sandmap.turn].units[t].upgradeAttack()
                    }
                    if (gamepadAPI.buttonPressed('B') || keysPressed['c']) {
                        sandmap.players[sandmap.turn].units[t].upgradeSpeed()
                    }
                    if (gamepadAPI.buttonPressed('A') || keysPressed['e']) {
                        sandmap.players[sandmap.turn].units[t].upgradeDefense()
                    }
                    if (gamepadAPI.buttonPressed('Y') || keysPressed['r']) {
                        sandmap.players[sandmap.turn].units[t].upgradeIncome()
                    }
                }
                if (sandmap.players[sandmap.turn].type == 6) {
                    if (gamepadAPI.buttonPressed('RB') || keysPressed['q']) {
                        sandmap.players[sandmap.turn].units[t].upgradeAttack()
                    }
                    if (gamepadAPI.buttonPressed('B') || keysPressed['c']) {
                        sandmap.players[sandmap.turn].units[t].upgradeSpeedSchlorkupine()
                    }
                    if (gamepadAPI.buttonPressed('A') || keysPressed['e']) {
                        sandmap.players[sandmap.turn].units[t].upgradeDefenseSchlorkupine()
                    }
                    if (gamepadAPI.buttonPressed('Y') || keysPressed['r']) {
                        sandmap.players[sandmap.turn].units[t].upgradeIncome()
                    }
                }



                if (gamepadAPI.buttonPressed('Y') || keysPressed['q']) {

                    // for (let k = 0; k < sandmap.players[sandmap.turn].units.length; k++) {
                    if (sandmap.players[sandmap.turn].units[t].imago == 1 || sandmap.players[sandmap.turn].units[t].imago == 2) {
                        if (sandmap.players[sandmap.turn].units[t].selected == 1 || sandmap.players[sandmap.turn].units[t].selected == 2) {
                            sandmap.players[sandmap.turn].units[t].makeNymph()
                        }
                    }
                    // }
                }
                if (gamepadAPI.buttonPressed('Y') || keysPressed['q']) {
                    if (sandmap.players[sandmap.turn].units[t].nymph == 1) {

                        for (let k = 0; k < sandmap.players[sandmap.turn].units.length; k++) {
                            if (sandmap.players[sandmap.turn].units[k].nymph == 1) {
                                if (sandmap.players[sandmap.turn].units[k].selected == 1 || sandmap.players[sandmap.turn].units[k].selected == 2) {
                                    sandmap.players[sandmap.turn].units[k].metamorph1()
                                    if (Math.random() < soundspamdrop) {
                                        soundCancel()
                                        whoarewetomolt.play()
                                    }
                                }
                            }
                        }
                    }
                    if (sandmap.players[sandmap.turn].units[t].pollinator == 1) {

                        for (let k = 0; k < sandmap.players[sandmap.turn].units.length; k++) {
                            if (sandmap.players[sandmap.turn].units[k].pollinator == 1) {
                                if (sandmap.players[sandmap.turn].units[k].selected == 1 || sandmap.players[sandmap.turn].units[k].selected == 2) {
                                    sandmap.players[sandmap.turn].units[k].metamorphpufffellow()
                                    if (Math.random() < soundspamdrop) {
                                        soundCancel()
                                        pollinatoraudio.play()
                                    }
                                }
                            }
                        }
                    }

                }


                // for (let k = 0; k < sandmap.players[sandmap.turn].units.length; k++) {
                //     if (sandmap.players[sandmap.turn].units[k].selected == 1 || sandmap.players[sandmap.turn].units[k].selected == 2) {
                //         for (let c = 0; c < sandmap.players[sandmap.turn].units[k].commandPanel.commandButtons.length; c++) {
                //             if (sandmap.players[sandmap.turn].units[k].commandPanel.commandButtons[c].isPointInside(TIP_engine)) {
                //                 // sandmap.players[sandmap.turn].units[k].commandPanel.commandButtons[c].color = "#555555"
                //             }
                //         }
                //     }
                // }


                if (gamepadAPI.buttonPressed('B') || keysPressed['c']) {
                    // sandmap.players[sandmap.turn].units[t].metacommandPanel.commandButtons[1]()
                    if (sandmap.players[sandmap.turn].units[t].nymph == 2) {
                        for (let k = 0; k < sandmap.players[sandmap.turn].units.length; k++) {
                            if (sandmap.players[sandmap.turn].units[k].nymph == 2) {
                                if (sandmap.players[sandmap.turn].units[k].selected == 1 || sandmap.players[sandmap.turn].units[k].selected == 2) {
                                    sandmap.players[sandmap.turn].units[k].metamorph2()
                                    if (Math.random() < soundspamdrop) {
                                        soundCancel()
                                        whoelsezagtheoystergush.play()
                                    }
                                }
                            }
                        }
                    }
                }

                if (gamepadAPI.buttonPressed('A') || keysPressed['e']) {
                    //////////console.log("i")
                    if (sandmap.players[sandmap.turn].units[t].nymph == 2) {
                        // sandmap.players[sandmap.turn].units[t].metacommandPanel.commandButtons[2]()

                        for (let k = 0; k < sandmap.players[sandmap.turn].units.length; k++) {
                            if (sandmap.players[sandmap.turn].units[k].nymph == 2) {
                                if (sandmap.players[sandmap.turn].units[k].selected == 1 || sandmap.players[sandmap.turn].units[k].selected == 2) {
                                    sandmap.players[sandmap.turn].units[k].metamorph3()
                                    if (Math.random() < soundspamdrop) {
                                        soundCancel()
                                        stallusyourworth.play()

                                    }
                                }
                            }
                        }
                    } else {
                        //////////console.log("i2")
                        // for (let k = 0; k < sandmap.players[sandmap.turn].units.length; k++) {
                        if (sandmap.players[sandmap.turn].units[t].submerged == 0) {
                            if (sandmap.players[sandmap.turn].units[t].imago == 2) {
                                if (sandmap.players[sandmap.turn].units[t].selected == 1 || sandmap.players[sandmap.turn].units[t].selected == 2) {
                                    sandmap.players[sandmap.turn].units[t].submerged = 1

                                    //////////console.log("i6")
                                    if (Math.random() < soundspamdrop) {
                                        soundCancel()
                                        slurpslurp.play()
                                    }
                                }
                            }

                        } else {
                            //////////console.log("i2")
                            if (sandmap.players[sandmap.turn].units[t].imago == 2) {
                                if (sandmap.players[sandmap.turn].units[t].selected == 1 || sandmap.players[sandmap.turn].units[t].selected == 2) {

                                    //////////console.log("i3")
                                    if (sandmap.players[sandmap.turn].units[t].tile.ice == 1 || sandmap.players[sandmap.turn].units[t].tile.builtOn == 1) { //sandmap.players[sandmap.turn].units[t].tile.walkable == false || 

                                        //////////console.log("i5")
                                    } else {

                                        //////////console.log("i4")
                                        sandmap.players[sandmap.turn].units[t].submerged = 0
                                        if (Math.random() < soundspamdrop) {
                                            soundCancel()
                                            gooutside.play()
                                        }
                                    }
                                }
                            }
                        }
                        // }
                    }
                }
            }
            if (this.state != 0) {
                if (gamepadAPI.buttonPressed('A') || keysPressed['e']) {
                   keysPressed['e'] = false
                }
                if (gamepadAPI.buttonPressed('Y') || keysPressed['r']) {
                     keysPressed['r'] = false
                }
                if (gamepadAPI.buttonPressed('B') || keysPressed['c']) {
                   keysPressed['c'] = false
                }
                if (gamepadAPI.buttonPressed('RB') || keysPressed['q']) {
                   keysPressed['q'] = false
                }
                if (gamepadAPI.buttonPressed('LB')|| keysPressed['t']) {
                     keysPressed['t'] = false
                }
            }
        }
        singleAgent() {


            const facex2 = (sandmap.window.body.x + sandmap.window.body.width + 10) - 5
            const facey2 = 5

            const faceborder = new UiRectangle(facex2, facey2, (1280 - ((sandmap.window.body.x + sandmap.window.body.width + 10) - 5)) - 10, 74, "#090909")
            faceborder.draw()
            if (this.state == 1) {
                for (let t = 0; t < this.faction.units.length; t++) {
                    if (keysPressed['q']) {

                    }

                    if (this.faction.units[t].selected == 1 || this.faction.units[t].selected == 2) {



                        const helrat = Math.max(this.faction.units[t].health, 0) / this.faction.units[t].maxhealth
                        this.healthbar = new UiRectangle(facex2 + 73, facey2 + 60, (faceborder.width - 74), 12, "#440000")
                        this.healthbar.draw()
                        if (helrat > .5) {
                            this.healthbar = new UiRectangle(facex2 + 73, facey2 + 60, (faceborder.width - 74) * helrat, 12, `rgb(${(1 - ((helrat))) * 512},${255},  0)`)
                        } else {
                            this.healthbar = new UiRectangle(facex2 + 73, facey2 + 60, (faceborder.width - 74) * helrat, 12, `rgb(${255},${(((helrat) * 1)) * 512},  0)`)
                        }
                        this.healthbar.draw()




                        this.faction.units[t].commandPanel.draw()
                        this.faction.units[t].listDraw.draw()
                        // if (dataflop == 0) {

                        canvas_context.fillStyle = "white"
                        canvas_context.font = "14px arial"
                        canvas_context.fillText("Patrol", this.faction.units[t].commandPanel.commandButtons[4].x + 25, this.faction.units[t].commandPanel.commandButtons[4].y + 36)
                        // }
                        canvas_context.fillStyle = this.faction.units[t].faction.color
                        // canvas_context.font = "18px arial"
                        //////////console.log(dataflop)
                        if (dataflop == 0) {
                            canvas_context.fillStyle = "white"
                            canvas_context.strokeStyle = "white" // sandmap.players[sandmap.turn].color
                            canvas_context.lineWidth = 1.5
                            canvas_context.font = "12px arial"
                            // canvas_context.strokeText(this.faction.units[t].name + " " + Math.round(this.faction.units[t].health) + "/" + this.faction.units[t].maxhealth, facex2+69, 25)
                            canvas_context.fillText(this.faction.units[t].name + " " + Math.round(Math.max(this.faction.units[t].health, 0)) + "/" + this.faction.units[t].maxhealth, facex2 + 72, 20)
                            if (this.faction.units[t].faction.type == 0) {
                                // canvas_context.strokeText(((1 - this.faction.units[t].decayingInTheWind) * 100) + "% Cover", facex2+69, 55)
                                canvas_context.fillText(((1 - this.faction.units[t].decayingInTheWind) * 100) + "% Cover", facex2 + 72, 32)
                            }
                            if (this.faction.units[t].faction.type == 2) {
                                // canvas_context.strokeText(((1 - this.faction.units[t].suffocating) * 100) + "%  Air Tolerance", facex2+69, 55)
                                canvas_context.fillText(((1 - this.faction.units[t].suffocating) * 100) + "%  Air Tolerance", facex2 + 72, 32)
                            }
                            if (this.faction.units[t].faction.type == 6) {
                                // canvas_context.strokeText(((1 - this.faction.units[t].suffocating) * 100) + "%  Air Tolerance", facex2+69, 55)
                                canvas_context.fillText("Reflecting: " + Math.round(this.faction.units[t].spikes * 100) + '%', facex2 + 72, 32)
                            }
                            if (this.faction.units[t].faction.type == 10) {
                                // canvas_context.strokeText(((1 - this.faction.units[t].suffocating) * 100) + "%  Air Tolerance", facex2+69, 55)
                                canvas_context.fillText("Warmth: " + Math.round(this.faction.units[t].warmth * 100) + '%', facex2 + 72, 32)
                            }


                            // canvas_context.strokeText("Attack " + Math.ceil(this.faction.units[t].damage * 3) + ", " + "Defense " + Math.ceil(this.faction.units[t].defense), sandmap.window.body.x + sandmap.window.body.width + 10, 85)
                            canvas_context.fillText("Attack " + Math.ceil(this.faction.units[t].damage * 3) + ", " + "Defense " + Math.ceil(this.faction.units[t].defense), facex2 + 72, 44)
                            // canvas_context.strokeText("Speed " + Math.floor((1 / this.faction.units[t].movespeed) * 120) + ", Vision " + this.faction.units[t].sight + ", Range " + this.faction.units[t].attackrange + ", Fire rate " + Math.floor((120 / (gargantuanNumber / this.faction.units[t].firerate))), sandmap.window.body.x + sandmap.window.body.width + 10, 115)
                            canvas_context.fillText("Speed " + Math.floor((1 / this.faction.units[t].movespeed) * 120) + ", Vision " + this.faction.units[t].sight + ", Range " + this.faction.units[t].attackrange + ", Fire rate " + Math.floor((120 / (gargantuanNumber / this.faction.units[t].firerate))), facex2 + 72, 56)
                            //     canvas_context.strokeText(this.faction.units[t].stack, sandmap.window.body.x + sandmap.window.body.width + 10, 135)
                            //     canvas_context.fillText(this.faction.units[t].stack, sandmap.window.body.x + sandmap.window.body.width + 10, 135)
                            //     for(let p = 0;p<this.faction.units[t].realPath.length;p++){

                            // map_context.fillStyle = "blue"
                            // map_context.fillRect(this.faction.units[t].realPath[p].x, this.faction.units[t].realPath[p].y, 10, 10)
                            //     }
                        }
                        if (this.faction.units[t].targetroid == 1) {
                            // this.faction.units[t].attackUI = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 10, 125, 90, 50, "black")
                            // this.faction.units[t].defenseUI = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 150, 125, 90, 50, "black")
                            // this.faction.units[t].incomeUI = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 150, 185, 90, 50, "black")
                            // this.faction.units[t].speedUI = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 290, 125, 90, 50, "black")
                            if (dataflop == 0) {
                                // this.faction.units[t].attackUI.draw()
                                // this.faction.units[t].defenseUI.draw()
                                // this.faction.units[t].speedUI.draw()
                                // this.faction.units[t].incomeUI.draw()
                                canvas_context.fillStyle = "white"
                                canvas_context.font = "14px arial"
                                canvas_context.fillText("Offense: " + this.faction.units[t].attackCost, this.faction.units[t].commandPanel.commandButtons[0].x + 1, this.faction.units[t].commandPanel.commandButtons[0].y + 66)
                                canvas_context.fillStyle = "white"
                                canvas_context.font = "14px arial"
                                canvas_context.fillText("Defense: " + this.faction.units[t].defenseCost, this.faction.units[t].commandPanel.commandButtons[2].x + 1, this.faction.units[t].commandPanel.commandButtons[2].y + 66)
                                canvas_context.fillStyle = "white"
                                canvas_context.font = "14px arial"
                                canvas_context.fillText("Range: " + this.faction.units[t].speedCost, this.faction.units[t].commandPanel.commandButtons[1].x + 1, this.faction.units[t].commandPanel.commandButtons[1].y + 66)
                                canvas_context.fillStyle = "white"
                                canvas_context.font = "14px arial"
                                canvas_context.fillText("Harvest: " + this.faction.units[t].incomeCost, this.faction.units[t].commandPanel.commandButtons[3].x + 1, this.faction.units[t].commandPanel.commandButtons[4].y + 66)
                            }

                        }
                        if (this.faction.units[t].schlorkupine == 1) {
                            // this.faction.units[t].attackUI = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 10, 125, 90, 50, "black")
                            // this.faction.units[t].defenseUI = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 150, 125, 90, 50, "black")
                            // this.faction.units[t].incomeUI = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 150, 185, 90, 50, "black")
                            // this.faction.units[t].speedUI = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 290, 125, 90, 50, "black")
                            if (dataflop == 0) {
                                // this.faction.units[t].attackUI.draw()
                                // this.faction.units[t].defenseUI.draw()
                                // this.faction.units[t].speedUI.draw()
                                // this.faction.units[t].incomeUI.draw()
                                canvas_context.fillStyle = "white"
                                canvas_context.font = "14px arial"
                                canvas_context.fillText("Offense: " + this.faction.units[t].attackCost, this.faction.units[t].commandPanel.commandButtons[0].x + 1, this.faction.units[t].commandPanel.commandButtons[0].y + 66)
                                canvas_context.fillStyle = "white"
                                canvas_context.font = "14px arial"
                                canvas_context.fillText("Defense: " + this.faction.units[t].defenseCost, this.faction.units[t].commandPanel.commandButtons[2].x + 1, this.faction.units[t].commandPanel.commandButtons[2].y + 66)
                                canvas_context.fillStyle = "white"
                                canvas_context.font = "14px arial"
                                canvas_context.fillText("Range: " + this.faction.units[t].speedCost, this.faction.units[t].commandPanel.commandButtons[1].x + 1, this.faction.units[t].commandPanel.commandButtons[1].y + 66)
                                canvas_context.fillStyle = "white"
                                canvas_context.font = "14px arial"
                                canvas_context.fillText("Harvest: " + this.faction.units[t].incomeCost, this.faction.units[t].commandPanel.commandButtons[3].x + 1, this.faction.units[t].commandPanel.commandButtons[4].y + 66)
                            }

                        }


                        if (this.faction.units[t].imago == 1 || this.faction.units[t].imago == 2) {
                            // this.faction.units[t].spawnsmall = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 10, 125, 90, 50, "black")
                            if (dataflop == 0) {
                                // this.faction.units[t].commandPanel.commandButtons[0].draw()
                                // if(this.faction.units[t].sana == 1){
                                //     canvas_context.drawImage(nymphsana, 0, 0, 10, 10, this.faction.units[t].commandPanel.commandButtons[0].x + 30, this.faction.units[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                //     }else{
                                if (sandmap.players.indexOf(this.faction.units[t].faction) == 0) {
                                    canvas_context.drawImage(nymph, 0, 0, 10, 10, this.faction.units[t].commandPanel.commandButtons[0].x + 30, this.faction.units[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(nymphinv, 0, 0, 10, 10, this.faction.units[t].commandPanel.commandButtons[0].x + 30, this.faction.units[t].commandPanel.commandButtons[0].y + 2, 50, 50)

                                }
                                // }
                                canvas_context.fillStyle = "white"
                                canvas_context.font = "14px arial"
                                canvas_context.fillText("Nymph: 109", this.faction.units[t].commandPanel.commandButtons[0].x + 1, this.faction.units[t].commandPanel.commandButtons[0].y + 66)
                            }

                        }
                        if (this.faction.units[t].pollinator == 1) {
                            // this.faction.units[t].commandPanel.commandButtons[0] = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 10, 125, 90, 50, "black")
                            if (dataflop == 0) {
                                // this.faction.units[t].commandPanel.commandButtons[0].draw()
                                if (sandmap.players.indexOf(this.faction.units[t].faction) == 0) {
                                    canvas_context.drawImage(librilbianpufffellow, 0, 0, 10, 10, this.faction.units[t].commandPanel.commandButtons[0].x + 30, this.faction.units[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(librilbianpufffellowinv, 0, 0, 10, 10, this.faction.units[t].commandPanel.commandButtons[0].x + 30, this.faction.units[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                }
                                canvas_context.fillStyle = "white"
                                canvas_context.font = "14px arial"
                                canvas_context.fillText("Puff-Fellow: 5", this.faction.units[t].commandPanel.commandButtons[0].x + 1, this.faction.units[t].commandPanel.commandButtons[0].y + 66)
                            }
                        }
                        if (this.faction.units[t].nymph == 1 || this.faction.units[t].nymph == 2) {
                            if (this.faction.units[t].nymph == 1) {
                                // this.faction.units[t].commandPanel.commandButtons[0] = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 10, 125, 90, 50, "black")
                                if (dataflop == 0) {
                                    // this.faction.units[t].commandPanel.commandButtons[0].draw()

                                    if (this.faction.units[t].sana == 1) {
                                        canvas_context.drawImage(scuttlersana, 0, 0, 10, 10, this.faction.units[t].commandPanel.commandButtons[0].x + 30, this.faction.units[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                    } else {

                                        if (sandmap.players.indexOf(this.faction.units[t].faction) == 0) {
                                            canvas_context.drawImage(scuttler, 0, 0, 10, 10, this.faction.units[t].commandPanel.commandButtons[0].x + 30, this.faction.units[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                        } else {

                                            canvas_context.drawImage(scuttlerinv, 0, 0, 10, 10, this.faction.units[t].commandPanel.commandButtons[0].x + 30, this.faction.units[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                        }
                                    }
                                    canvas_context.fillStyle = "white"
                                    canvas_context.font = "14px arial"
                                    canvas_context.fillText("Scurrier: 180", this.faction.units[t].commandPanel.commandButtons[0].x + 1, this.faction.units[t].commandPanel.commandButtons[0].y + 66)
                                }
                                // this.faction.units[t].commandPanel.commandButtons[0] = {}
                                // this.faction.units[t].commandPanel.commandButtons[0].isPointInside = empty
                            } else {
                                // this.faction.units[t].commandPanel.commandButtons[0] = {}
                                // this.faction.units[t].commandPanel.commandButtons[0].isPointInside = empty
                                // this.faction.units[t].commandPanel.commandButtons[1] = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 10, 125, 90, 50, "black")
                                if (dataflop == 0) {
                                    // this.faction.units[t].commandPanel.commandButtons[1].draw()
                                    if (this.faction.units[t].sana == 1) {
                                        canvas_context.drawImage(imagosana, 0, 0, 10, 10, this.faction.units[t].commandPanel.commandButtons[1].x + 30, this.faction.units[t].commandPanel.commandButtons[1].y + 2, 50, 50)
                                    } else {

                                        if (sandmap.players.indexOf(this.faction.units[t].faction) == 0) {
                                            canvas_context.drawImage(imago, 0, 0, 10, 10, this.faction.units[t].commandPanel.commandButtons[1].x + 30, this.faction.units[t].commandPanel.commandButtons[1].y + 2, 50, 50)
                                        } else {

                                            canvas_context.drawImage(imagoinv, 0, 0, 10, 10, this.faction.units[t].commandPanel.commandButtons[1].x + 30, this.faction.units[t].commandPanel.commandButtons[1].y + 2, 50, 50)
                                        }
                                    }
                                    canvas_context.fillStyle = "white"
                                    canvas_context.font = "14px arial"
                                    canvas_context.fillText("Imago: 240", this.faction.units[t].commandPanel.commandButtons[1].x + 1, this.faction.units[t].commandPanel.commandButtons[1].y + 66)
                                }
                                // this.faction.units[t].commandPanel.commandButtons[2] = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 150, 125, 90, 50, "black")
                                if (dataflop == 0) {
                                    // this.faction.units[t].commandPanel.commandButtons[2].draw()
                                    if (this.faction.units[t].sana == 1) {
                                        canvas_context.drawImage(gamergatesana, 0, 0, 10, 10, this.faction.units[t].commandPanel.commandButtons[2].x + 30, this.faction.units[t].commandPanel.commandButtons[2].y + 2, 50, 50)
                                    } else {
                                        if (sandmap.players.indexOf(this.faction.units[t].faction) == 0) {
                                            canvas_context.drawImage(gamergate, 0, 0, 10, 10, this.faction.units[t].commandPanel.commandButtons[2].x + 30, this.faction.units[t].commandPanel.commandButtons[2].y + 2, 50, 50)
                                        } else {
                                            canvas_context.drawImage(gamergateinv, 0, 0, 10, 10, this.faction.units[t].commandPanel.commandButtons[2].x + 30, this.faction.units[t].commandPanel.commandButtons[2].y + 2, 50, 50)

                                        }
                                    }
                                    canvas_context.fillStyle = "white"
                                    canvas_context.font = "13px arial"
                                    canvas_context.fillText("Gamergate: 350", this.faction.units[t].commandPanel.commandButtons[2].x + 1, this.faction.units[t].commandPanel.commandButtons[2].y + 66)
                                }
                            }
                        } else {
                            if (this.faction.units[t].imago == 2) {
                                // this.faction.units[t].commandPanel.commandButtons[2] = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 150, 125, 90, 50, "black")

                                if (dataflop == 0) {
                                    // this.faction.units[t].commandPanel.commandButtons[2].draw()
                                    canvas_context.fillStyle = "white"
                                    canvas_context.font = "22px arial"
                                    if (this.faction.units[t].submerged == 0) {
                                        canvas_context.fillText("Tunnel", this.faction.units[t].commandPanel.commandButtons[2].x + 10, this.faction.units[t].commandPanel.commandButtons[2].y + 32)
                                    } else {
                                        if (this.faction.units[t].tile.walkable == false || this.faction.units[t].tile.ice == 1 || this.faction.units[t].tile.builtOn == 1) {
                                            canvas_context.fillStyle = "red"
                                        }

                                        canvas_context.fillText("Emerge", this.faction.units[t].commandPanel.commandButtons[2].x + 5, this.faction.units[t].commandPanel.commandButtons[2].y + 32)
                                    }
                                }
                            }
                        }



                        const facex = sandmap.window.body.x + sandmap.window.body.width + 10
                        const facey = 10

                        this.faction.units[t].facerect = new UiRectangle(facex, facey, 64, 64, "#009999")

                        if (dataflop == 0) {
                            this.faction.units[t].facerect.draw()

                            if(this.faction.units[t].bee == 1){
                                canvas_context.drawImage(beemegaface, facex, facey)
                            }else if (this.faction.units[t].targetroid == 1) {

                                if (sandmap.players.indexOf(this.faction.units[t].faction) == 0) {
                                    canvas_context.drawImage(targetroidface, facex, facey)
                                } else {
                                    canvas_context.drawImage(targetroidfaceinv, facex, facey)

                                }



                            } else if (this.faction.units[t].schlorkupine == 1) {

                                if (sandmap.players.indexOf(this.faction.units[t].faction) == 0) {
                                    canvas_context.drawImage(schlorkupineface, facex, facey)
                                } else {
                                    canvas_context.drawImage(schlorkupinefaceinv, facex, facey)

                                }



                            } else if (this.faction.units[t].alagadile == 1) {
                                if (this.faction.units[t].babyalagadile == 1) {
                                    canvas_context.drawImage(babyalagadileface, facex, facey)
                                } else if (this.faction.units[t].bigalagadile == 1) {
                                    canvas_context.drawImage(bigalagadileface, facex, facey)
                                } else if (this.faction.units[t].hunchalagadile == 1) {
                                    canvas_context.drawImage(hunchalagadileface, facex, facey)
                                } else if (this.faction.units[t].bighunchalagadile == 1) {
                                    canvas_context.drawImage(bighunchalagadileface, facex, facey)
                                }

                            } else if (this.faction.units[t].gogo == 1) {
                                if (sandmap.players.indexOf(this.faction.units[t].faction) == 0) {
                                    if (this.faction.units[t].gogonaut == 1) {
                                        canvas_context.drawImage(gogonautface, facex, facey)
                                    } else if (this.faction.units[t].gogonautchampion == 1) {
                                        canvas_context.drawImage(gogonautchampionface, facex, facey)
                                    } else if (this.faction.units[t].gogonautdefender == 1) {
                                        canvas_context.drawImage(gogonautdefenderface, facex, facey)
                                    } else if (this.faction.units[t].gogonautteam == 1) {
                                        canvas_context.drawImage(gogonautteamface, facex, facey)
                                    }
                                } else {

                                    if (this.faction.units[t].gogonaut == 1) {
                                        canvas_context.drawImage(gogonautfaceinv, facex, facey)
                                    } else if (this.faction.units[t].gogonautchampion == 1) {
                                        canvas_context.drawImage(gogonautchampionfaceinv, facex, facey)
                                    } else if (this.faction.units[t].gogonautdefender == 1) {
                                        canvas_context.drawImage(gogonautdefenderfaceinv, facex, facey)
                                    } else if (this.faction.units[t].gogonautteam == 1) {
                                        canvas_context.drawImage(gogonautteamfaceinv, facex, facey)
                                    }
                                }

                            } else if (this.faction.units[t].ave == 1) {
                                if (this.faction.units[t].flugoon == 1) {
                                    canvas_context.drawImage(flugoonface, facex, facey)
                                } else if (this.faction.units[t].buzzlet == 1) {
                                    canvas_context.drawImage(buzzletface, facex, facey)
                                } else if (this.faction.units[t].starbatross == 1) {
                                    canvas_context.drawImage(starbatrossface, facex, facey)
                                } else if (this.faction.units[t].megagnat == 1) {
                                    canvas_context.drawImage(megagnatface, facex, facey)
                                }

                            } else {
                                if (this.faction.units[t].mycoknight == 1) {
                                    canvas_context.drawImage(knightface, facex, facey)
                                }
                                if (this.faction.units[t].sporevizir == 1) {
                                    canvas_context.drawImage(vizirface, facex, facey)
                                }
                                if (this.faction.units[t].seer == 1) {
                                    canvas_context.drawImage(seerface, facex, facey)
                                }
                                if (this.faction.units[t].fruiting == 1) {
                                    canvas_context.drawImage(buddyface, facex, facey)
                                }
                                if (this.faction.units[t].hamartaninvader == 1) {
                                    canvas_context.drawImage(hamartaninvaderface, facex, facey)
                                }
                                if (this.faction.units[t].hamartanscout == 1) {
                                    canvas_context.drawImage(hamartanscoutface, facex, facey)
                                }
                                if (this.faction.units[t].hamartansoldier == 1) {
                                    canvas_context.drawImage(hamartansoldierface, facex, facey)
                                }
                                if (this.faction.units[t].hamartanworker == 1) {
                                    canvas_context.drawImage(hamartanworkerface, facex, facey)
                                }
                                if (this.faction.units[t].infantry == 1) {
                                    if (this.faction.units[t].super == 1) {
                                        canvas_context.drawImage(superinfantryface, facex, facey)
                                    } else {
                                        canvas_context.drawImage(infantryface, facex, facey)
                                    }
                                }
                                if (this.faction.units[t].infantry == 2) {
                                    if (this.faction.units[t].super == 1) {
                                        canvas_context.drawImage(supersniperface, facex, facey)

                                    } else {
                                        canvas_context.drawImage(sniperface, facex, facey)

                                    }
                                }
                                if (this.faction.units[t].drone == 1) {
                                    if (this.faction.units[t].super == 1) {
                                        canvas_context.drawImage(superdroneface, facex, facey)
                                    } else {
                                        canvas_context.drawImage(droneface, facex, facey)
                                    }
                                }
                                if (this.faction.units[t].harvester == 1) {
                                    if (this.faction.units[t].super == 1) {
                                        canvas_context.drawImage(superharvesterface, facex, facey)
                                    } else {
                                        canvas_context.drawImage(harvesterface, facex, facey)
                                    }
                                }
                                if (this.faction.units[t].nymph == 1) {
                                    if (this.faction.units[t].sana == 1) {
                                        canvas_context.drawImage(nymphfacesana, facex, facey)
                                    } else {
                                        canvas_context.drawImage(nymphface, facex, facey)
                                    }
                                }
                                if (this.faction.units[t].pollinator == 1) {
                                    canvas_context.drawImage(librilbianpollinatorface, facex, facey)
                                }
                                if (this.faction.units[t].pufffellow == 1) {
                                    canvas_context.drawImage(pufffellowface, facex, facey)
                                }
                                if (this.faction.units[t].goliophyte == 1) {
                                    canvas_context.drawImage(golophyteface, facex, facey)
                                }
                                if (this.faction.units[t].podman == 1) {
                                    canvas_context.drawImage(podmanface, facex, facey)
                                }
                                if (this.faction.units[t].nymph == 2) {
                                    if (this.faction.units[t].sana == 1) {
                                        canvas_context.drawImage(scurrierfacesana, facex, facey)
                                    } else {
                                        canvas_context.drawImage(scurrierface, facex, facey)
                                    }
                                }
                                if (this.faction.units[t].imago == 1) {
                                    if (this.faction.units[t].sana == 1) {
                                        canvas_context.drawImage(imagofacesana, facex, facey)
                                    } else {
                                        canvas_context.drawImage(imagoface, facex, facey)
                                    }
                                }
                                if (this.faction.units[t].imago == 2) {
                                    if (this.faction.units[t].sana == 1) {
                                        canvas_context.drawImage(gamergatefacesana, facex, facey)
                                    } else {
                                        canvas_context.drawImage(gamergateface, facex, facey)
                                    }
                                }
                            }


                        }

                        if (this.faction.units[t].timer > 0) {
                            if (dataflop == 0) {
                                canvas_context.drawImage(progress, 0, (250 - (Math.round((this.faction.units[t].timer / this.faction.units[t].maxtimer) * 250))), progress.width, 10, faceborder.x, faceborder.y + faceborder.height + 2, faceborder.width, faceborder.width * .04)
                                dataflop = 1
                            }
                        } else {
                            //this.faction.units[t].commandPanel.commandButtons[0].color = "#090909"
                        }
                        if (this.faction.units[t].selected > 0) {
                            if (dataflop == 0) {
                                dataflop = 1
                            }
                        }
                    }

                }
            }
        }
        manyAgents() {
            if (this.state >= 2) {
                //////////console.log(this.state)
                let j = 0
                let m = 0
                for (let t = 0; t < this.faction.units.length; t++) {
                    if (this.faction.units[t].selected == 1 || this.faction.units[t].selected == 2) {
                        m++
                    }
                }
                for (let t = 0; t < this.faction.units.length; t++) {
                    if (this.faction.units[t].selected == 1 || this.faction.units[t].selected == 2) {
                        this.faction.units[t].agentTile.draw(j, m)
                        j++
                    }
                }
            }
        }
        building() {

            const facex2 = (sandmap.window.body.x + sandmap.window.body.width + 10) - 5
            const facey2 = 5

            const faceborder = new UiRectangle(facex2, facey2, (1280 - ((sandmap.window.body.x + sandmap.window.body.width + 10) - 5)) - 10, 74, "#090909")
            faceborder.draw()

            if (this.state == -1) {
                for (let t = 0; t < this.faction.buildings.length; t++) {

                    if (this.faction.buildings[t].selected == 1) {

                        if (dataflop == 0) {

                            this.faction.buildings[t].commandPanel.draw()
                            this.faction.buildings[t].listDraw.draw()

                            canvas_context.fillStyle = "white"
                            canvas_context.font = "12px arial"
                            canvas_context.fillText("Set Waypoint", this.faction.buildings[t].commandPanel.commandButtons[4].x + 15, this.faction.buildings[t].commandPanel.commandButtons[4].y + 36)

                        }


                        // canvas_context.fillStyle = this.faction.buildings[t].faction.color
                        // canvas_context.font = "18px arial"

                        // canvas_context.fillStyle = "white"
                        // canvas_context.strokeStyle = sandmap.players[sandmap.turn].color
                        // canvas_context.lineWidth = 1.5
                        // canvas_context.font = "18px arial"

                        if (dataflop == 0) {
                            canvas_context.fillStyle = "white"
                            canvas_context.strokeStyle = "white" // sandmap.players[sandmap.turn].color
                            canvas_context.lineWidth = 1.5
                            canvas_context.font = "12px arial"
                            if (dataflop == 0) {
                                // canvas_context.strokeText(this.faction.buildings[t].name + " " + Math.ceil(this.faction.buildings[t].health) + "/" + this.faction.buildings[t].maxhealth, sandmap.window.body.x + sandmap.window.body.width + 10, 25)
                                // canvas_context.fillText(this.faction.buildings[t].name + " " + Math.ceil(this.faction.buildings[t].health) + "/" + this.faction.buildings[t].maxhealth, sandmap.window.body.x + sandmap.window.body.width + 10, 25)
                                // canvas_context.strokeText("Attack " + Math.ceil(this.faction.buildings[t].damage), sandmap.window.body.x + sandmap.window.body.width + 10, 85)


                                canvas_context.fillText(this.faction.buildings[t].name + " " + Math.round(this.faction.buildings[t].health) + "/" + this.faction.buildings[t].maxhealth, facex2 + 72, 20)

                                canvas_context.fillText("Attack " + Math.ceil(this.faction.buildings[t].damage * 3) + ", " + "Defense " + Math.ceil(this.faction.buildings[t].defense), facex2 + 72, 44)



                                const helrat = this.faction.buildings[t].health / this.faction.buildings[t].maxhealth
                                this.healthbar = new UiRectangle(facex2 + 73, facey2 + 60, (faceborder.width - 74), 12, "#440000")
                                this.healthbar.draw()
                                if (helrat > .5) {
                                    this.healthbar = new UiRectangle(facex2 + 73, facey2 + 60, (faceborder.width - 74) * helrat, 12, `rgb(${(1 - ((helrat))) * 512},${255},  0)`)
                                } else {
                                    this.healthbar = new UiRectangle(facex2 + 73, facey2 + 60, (faceborder.width - 74) * helrat, 12, `rgb(${255},${(((helrat) * 1)) * 512},  0)`)
                                }
                                this.healthbar.draw()


                                // canvas_context.fillText("Attack " + Math.ceil(this.faction.buildings[t].damage), sandmap.window.body.x + sandmap.window.body.width + 10, 85)
                                // // canvas_context.strokeText("Defense " + Math.ceil(this.faction.buildings[t].defense), sandmap.window.body.x + sandmap.window.body.width + 10, 115)
                                // canvas_context.fillText("Defense " + Math.ceil(this.faction.buildings[t].defense), sandmap.window.body.x + sandmap.window.body.width + 10, 115)
                            }
                        }

                        if (this.faction.buildings[t].teleporter == 1) {

                        canvas_context.fillStyle = "white"
                        canvas_context.font = "14px arial"
                        canvas_context.fillText("Teleport", this.faction.units[t].commandPanel.commandButtons[0].x + 25, this.faction.units[t].commandPanel.commandButtons[0].y + 36)
                        // }
                        }

                        if (this.faction.buildings[t].pond == 1) {

                            if (dataflop == 0) {
                                //canvas_context.strokeText("Units", sandmap.window.body.x + sandmap.window.body.width + 10, 55)
                                //canvas_context.fillText("Units", sandmap.window.body.x + sandmap.window.body.width + 10, 55)
                            }
                            // this.faction.buildings[t].spawnsmall = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 10, 125, 65, 50, "black")

                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[0].draw()
                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(alagadile, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(alagadileinv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                }
                            }

                            // if (dataflop == 0) {
                            //     this.faction.buildings[t].spawnmedium = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 80, 125, 65, 50, "black")
                            //     this.faction.buildings[t].commandPanel.commandButtons[1].draw()
                            // }
                            if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                canvas_context.drawImage(bighunchalagadile, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[1].x + 30, this.faction.buildings[t].commandPanel.commandButtons[1].y + 2, 50, 50)
                            } else {
                                canvas_context.drawImage(bighunchalagadileinv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[1].x + 30, this.faction.buildings[t].commandPanel.commandButtons[1].y + 2, 50, 50)
                            }
                            this.faction.buildings[t].spawnbig = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 150, 125, 65, 50, "black")
                            this.faction.buildings[t].spawnlast = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 220, 125, 65, 50, "black")

                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[2].draw()

                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(bigalagadile, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[2].x + 30, this.faction.buildings[t].commandPanel.commandButtons[2].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(bigalagadileinv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[2].x + 30, this.faction.buildings[t].commandPanel.commandButtons[2].y + 2, 50, 50)

                                }
                            }
                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[3].draw()
                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(hunchalagadile, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[3].x + 30, this.faction.buildings[t].commandPanel.commandButtons[3].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(hunchalagadileinv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[3].x + 30, this.faction.buildings[t].commandPanel.commandButtons[3].y + 2, 50, 50)
                                }
                            }

                            if (dataflop == 0) {
                                canvas_context.fillStyle = "white"
                                canvas_context.font = "14px arial"
                                canvas_context.fillText("Adile: 50", this.faction.buildings[t].commandPanel.commandButtons[0].x + 1, this.faction.buildings[t].commandPanel.commandButtons[0].y + 66)
                                canvas_context.fillText("Croga: 200", this.faction.buildings[t].commandPanel.commandButtons[1].x + 1, this.faction.buildings[t].commandPanel.commandButtons[1].y + 66)
                                canvas_context.fillText("Caydi: 160", this.faction.buildings[t].commandPanel.commandButtons[2].x + 1, this.faction.buildings[t].commandPanel.commandButtons[2].y + 66)
                                canvas_context.fillText("Alaman: 90", this.faction.buildings[t].commandPanel.commandButtons[3].x + 1, this.faction.buildings[t].commandPanel.commandButtons[3].y + 66)
                            }
                            if (this.faction.buildings[t].timer > 0) {
                                if (dataflop == 0) {
                                    canvas_context.drawImage(progress, 0, (250 - (Math.round((this.faction.buildings[t].timer / this.faction.buildings[t].maxtimer) * 250))), progress.width, 10, faceborder.x, faceborder.y + faceborder.height + 2, faceborder.width, faceborder.width * .04)
                                    // dataflop = 1
                                }
                            } else {
                                //this.faction.units[t].commandPanel.commandButtons[0].color = "#090909"
                            }


                        }

                        if (this.faction.buildings[t].beehive == 1) {

                            if (dataflop == 0) {
                                //canvas_context.strokeText("Units", sandmap.window.body.x + sandmap.window.body.width + 10, 55)
                                //canvas_context.fillText("Units", sandmap.window.body.x + sandmap.window.body.width + 10, 55)
                            }
                            // this.faction.buildings[t].spawnsmall = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 10, 125, 65, 50, "black")

                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[0].draw()
                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(beeworkerimg, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(beeworkerimg, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                }
                            }

                            // if (dataflop == 0) {
                            //     this.faction.buildings[t].spawnmedium = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 80, 125, 65, 50, "black")
                            //     this.faction.buildings[t].commandPanel.commandButtons[1].draw()
                            // }
                            if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                canvas_context.drawImage(beescoutimg, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[1].x + 30, this.faction.buildings[t].commandPanel.commandButtons[1].y + 2, 50, 50)
                            } else {
                                canvas_context.drawImage(beescoutimg, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[1].x + 30, this.faction.buildings[t].commandPanel.commandButtons[1].y + 2, 50, 50)
                            }
                            this.faction.buildings[t].spawnbig = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 150, 125, 65, 50, "black")
                            this.faction.buildings[t].spawnlast = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 220, 125, 65, 50, "black")

                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[2].draw()

                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(beesoldierimg, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[2].x + 30, this.faction.buildings[t].commandPanel.commandButtons[2].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(beesoldierimg, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[2].x + 30, this.faction.buildings[t].commandPanel.commandButtons[2].y + 2, 50, 50)

                                }
                            }
                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[3].draw()
                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(beemegaimg, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[3].x + 30, this.faction.buildings[t].commandPanel.commandButtons[3].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(beemegaimg, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[3].x + 30, this.faction.buildings[t].commandPanel.commandButtons[3].y + 2, 50, 50)
                                }
                            }

                            if (dataflop == 0) {
                                canvas_context.fillStyle = "white"
                                canvas_context.font = "14px arial"
                                canvas_context.fillText("Worker: 100", this.faction.buildings[t].commandPanel.commandButtons[0].x + 1, this.faction.buildings[t].commandPanel.commandButtons[0].y + 66)
                                canvas_context.fillText("Scout: 100", this.faction.buildings[t].commandPanel.commandButtons[1].x + 1, this.faction.buildings[t].commandPanel.commandButtons[1].y + 66)
                                canvas_context.fillText("Soldier: 230", this.faction.buildings[t].commandPanel.commandButtons[2].x + 1, this.faction.buildings[t].commandPanel.commandButtons[2].y + 66)
                                canvas_context.fillText("Queen: 450", this.faction.buildings[t].commandPanel.commandButtons[3].x + 1, this.faction.buildings[t].commandPanel.commandButtons[3].y + 66)
                            }
                            if (this.faction.buildings[t].timer > 0) {
                                if (dataflop == 0) {
                                    canvas_context.drawImage(progress, 0, (250 - (Math.round((this.faction.buildings[t].timer / this.faction.buildings[t].maxtimer) * 250))), progress.width, 10, faceborder.x, faceborder.y + faceborder.height + 2, faceborder.width, faceborder.width * .04)
                                    // dataflop = 1
                                }
                            } else {
                                //this.faction.units[t].commandPanel.commandButtons[0].color = "#090909"
                            }


                        }




                        if (this.faction.buildings[t].tree == 1) {

                            if (dataflop == 0) {
                                //canvas_context.strokeText("Units", sandmap.window.body.x + sandmap.window.body.width + 10, 55)
                                //canvas_context.fillText("Units", sandmap.window.body.x + sandmap.window.body.width + 10, 55)
                            }
                            // this.faction.buildings[t].spawnsmall = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 10, 125, 65, 50, "black")

                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[0].draw()
                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(gogonaut, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(gogonautinv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                }
                            }

                            // if (dataflop == 0) {
                            //     this.faction.buildings[t].spawnmedium = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 80, 125, 65, 50, "black")
                            //     this.faction.buildings[t].commandPanel.commandButtons[1].draw()
                            // }
                            if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                canvas_context.drawImage(gogonautteam, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[1].x + 30, this.faction.buildings[t].commandPanel.commandButtons[1].y + 2, 50, 50)
                            } else {
                                canvas_context.drawImage(gogonautteaminv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[1].x + 30, this.faction.buildings[t].commandPanel.commandButtons[1].y + 2, 50, 50)
                            }
                            this.faction.buildings[t].spawnbig = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 150, 125, 65, 50, "black")
                            this.faction.buildings[t].spawnlast = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 220, 125, 65, 50, "black")

                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[2].draw()

                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(gogonautchampion, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[2].x + 30, this.faction.buildings[t].commandPanel.commandButtons[2].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(gogonautchampioninv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[2].x + 30, this.faction.buildings[t].commandPanel.commandButtons[2].y + 2, 50, 50)

                                }
                            }
                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[3].draw()
                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(gogonautdefender, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[3].x + 30, this.faction.buildings[t].commandPanel.commandButtons[3].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(gogonautdefenderinv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[3].x + 30, this.faction.buildings[t].commandPanel.commandButtons[3].y + 2, 50, 50)
                                }
                            }

                            if (dataflop == 0) {
                                canvas_context.fillStyle = "white"
                                canvas_context.font = "14px arial"
                                canvas_context.fillText("Gogo: 75", this.faction.buildings[t].commandPanel.commandButtons[0].x + 1, this.faction.buildings[t].commandPanel.commandButtons[0].y + 66)
                                canvas_context.fillText("Team: 120", this.faction.buildings[t].commandPanel.commandButtons[1].x + 1, this.faction.buildings[t].commandPanel.commandButtons[1].y + 66)
                                canvas_context.fillText("Champ: 400", this.faction.buildings[t].commandPanel.commandButtons[2].x + 1, this.faction.buildings[t].commandPanel.commandButtons[2].y + 66)
                                canvas_context.fillText("Defend: 210", this.faction.buildings[t].commandPanel.commandButtons[3].x + 1, this.faction.buildings[t].commandPanel.commandButtons[3].y + 66)
                            }
                            if (this.faction.buildings[t].timer > 0) {
                                if (dataflop == 0) {
                                    canvas_context.drawImage(progress, 0, (250 - (Math.round((this.faction.buildings[t].timer / this.faction.buildings[t].maxtimer) * 250))), progress.width, 10, faceborder.x, faceborder.y + faceborder.height + 2, faceborder.width, faceborder.width * .04)
                                    // dataflop = 1
                                }
                            } else {
                                //this.faction.units[t].commandPanel.commandButtons[0].color = "#090909"
                            }


                        }
                        //ave egg



                        if (this.faction.buildings[t].egg == 1) {
                            if (dataflop == 0) {
                                //canvas_context.strokeText("Units", sandmap.window.body.x + sandmap.window.body.width + 10, 55)
                                //canvas_context.fillText("Units", sandmap.window.body.x + sandmap.window.body.width + 10, 55)
                            }
                            // this.faction.buildings[t].spawnsmall = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 10, 125, 65, 50, "black")Z

                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[0].draw()
                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(buzzlet, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(buzzletinv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                }
                            }

                            if (dataflop == 0) {
                                // this.faction.buildings[t].spawnmedium = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 80, 125, 65, 50, "black")
                                // this.faction.buildings[t].commandPanel.commandButtons[1].draw()
                            }
                            if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                canvas_context.drawImage(megagnat, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[1].x + 30, this.faction.buildings[t].commandPanel.commandButtons[1].y + 2, 50, 50)
                            } else {
                                canvas_context.drawImage(megagnatinv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[1].x + 30, this.faction.buildings[t].commandPanel.commandButtons[1].y + 2, 50, 50)
                            }
                            this.faction.buildings[t].spawnbig = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 150, 125, 65, 50, "black")
                            this.faction.buildings[t].spawnlast = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 220, 125, 65, 50, "black")

                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[2].draw()

                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(flugoon, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[2].x + 30, this.faction.buildings[t].commandPanel.commandButtons[2].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(flugooninv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[2].x + 30, this.faction.buildings[t].commandPanel.commandButtons[2].y + 2, 50, 50)

                                }
                            }
                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[3].draw()
                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(starbatross, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[3].x + 30, this.faction.buildings[t].commandPanel.commandButtons[3].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(starbatrossinv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[3].x + 30, this.faction.buildings[t].commandPanel.commandButtons[3].y + 2, 50, 50)
                                }
                            }

                            if (dataflop == 0) {
                                canvas_context.fillStyle = "white"
                                canvas_context.font = "14px arial"
                                canvas_context.fillText("Buzzlet: 90", this.faction.buildings[t].commandPanel.commandButtons[0].x + 1, this.faction.buildings[t].commandPanel.commandButtons[0].y + 66)
                                canvas_context.fillText("Mega: 130", this.faction.buildings[t].commandPanel.commandButtons[1].x + 1, this.faction.buildings[t].commandPanel.commandButtons[1].y + 66)
                                canvas_context.fillText("Flug: 180", this.faction.buildings[t].commandPanel.commandButtons[2].x + 1, this.faction.buildings[t].commandPanel.commandButtons[2].y + 66)
                                canvas_context.fillText("Starbat: 180", this.faction.buildings[t].commandPanel.commandButtons[3].x + 1, this.faction.buildings[t].commandPanel.commandButtons[3].y + 66)
                            }
                            if (this.faction.buildings[t].timer > 0) {
                                if (dataflop == 0) {
                                    canvas_context.drawImage(progress, 0, (250 - (Math.round((this.faction.buildings[t].timer / this.faction.buildings[t].maxtimer) * 250))), progress.width, 10, faceborder.x, faceborder.y + faceborder.height + 2, faceborder.width, faceborder.width * .04)
                                    // dataflop = 1
                                }
                            } else {
                                //this.faction.units[t].commandPanel.commandButtons[0].color = "#090909"
                            }

                        }




                        if (this.faction.buildings[t].barracks == 1) {
                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[0].draw()
                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(infantry, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(infantryinv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)

                                }
                            }
                            this.faction.buildings[t].spawnbig = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 210, 125, 90, 50, "black")

                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[2].draw()
                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(sniper1, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[2].x + 30, this.faction.buildings[t].commandPanel.commandButtons[2].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(sniper1inv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[2].x + 30, this.faction.buildings[t].commandPanel.commandButtons[2].y + 2, 50, 50)
                                }
                            }

                            if (dataflop == 0) {
                                canvas_context.fillStyle = "white"
                                canvas_context.font = "14px arial"
                                // canvas_context.fillText("Drone: 30", this.faction.buildings[t].commandPanel.commandButtons[0].x + 1, this.faction.buildings[t].commandPanel.commandButtons[0].y + 66)
                                canvas_context.fillText("Infantry: 85", this.faction.buildings[t].commandPanel.commandButtons[0].x + 1, this.faction.buildings[t].commandPanel.commandButtons[0].y + 66)
                                canvas_context.fillText("Sniper: 195", this.faction.buildings[t].commandPanel.commandButtons[2].x + 1, this.faction.buildings[t].commandPanel.commandButtons[2].y + 66)
                                // canvas_context.fillText("Drone: 30")
                                // canvas_context.fillText("Drone: 30")
                            }
                            if (this.faction.buildings[t].timer > 0) {
                                if (dataflop == 0) {
                                    canvas_context.drawImage(progress, 0, (250 - (Math.round((this.faction.buildings[t].timer / this.faction.buildings[t].maxtimer) * 250))), progress.width, 10, faceborder.x, faceborder.y + faceborder.height + 2, faceborder.width, faceborder.width * .04)
                                    // dataflop = 1
                                }
                            } else {
                                //this.faction.units[t].commandPanel.commandButtons[0].color = "#090909"
                            }

                        }
                        if (this.faction.buildings[t].slime == 1) {
                            if (dataflop == 0) {
                                //canvas_context.strokeText("Units", sandmap.window.body.x + sandmap.window.body.width + 10, 55)
                                //canvas_context.fillText("Units", sandmap.window.body.x + sandmap.window.body.width + 10, 55)
                            }
                            // this.faction.buildings[t].spawnsmall = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 10, 125, 65, 50, "black")

                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[0].draw()

                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(fruitingbuddy, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(fruitingbuddyinv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                }
                            }

                            if (dataflop == 0) {
                                // this.faction.buildings[t].spawnmedium = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 80, 125, 65, 50, "black")
                                // this.faction.buildings[t].commandPanel.commandButtons[1].draw()
                            }
                            if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                canvas_context.drawImage(sporeseer, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[1].x + 30, this.faction.buildings[t].commandPanel.commandButtons[1].y + 2, 50, 50)
                            } else {
                                canvas_context.drawImage(sporeseerinv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[1].x + 30, this.faction.buildings[t].commandPanel.commandButtons[1].y + 2, 50, 50)
                            }
                            this.faction.buildings[t].spawnbig = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 150, 125, 65, 50, "black")
                            this.faction.buildings[t].spawnlast = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 220, 125, 65, 50, "black")

                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[2].draw()
                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(sporevizir, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[2].x + 30, this.faction.buildings[t].commandPanel.commandButtons[2].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(sporevizirinv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[2].x + 30, this.faction.buildings[t].commandPanel.commandButtons[2].y + 2, 50, 50)

                                }
                            }
                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[3].draw()

                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(mycoknight, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[3].x + 30, this.faction.buildings[t].commandPanel.commandButtons[3].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(mycoknightinv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[3].x + 30, this.faction.buildings[t].commandPanel.commandButtons[3].y + 2, 50, 50)
                                }
                            }

                            if (dataflop == 0) {
                                canvas_context.fillStyle = "white"
                                canvas_context.font = "14px arial"
                                canvas_context.fillText("Buddy: 45", this.faction.buildings[t].commandPanel.commandButtons[0].x + 1, this.faction.buildings[t].commandPanel.commandButtons[0].y + 66)
                                canvas_context.fillText("Seer: 80", this.faction.buildings[t].commandPanel.commandButtons[1].x + 1, this.faction.buildings[t].commandPanel.commandButtons[1].y + 66)
                                canvas_context.fillText("Vizier: 130", this.faction.buildings[t].commandPanel.commandButtons[2].x + 1, this.faction.buildings[t].commandPanel.commandButtons[2].y + 66)
                                canvas_context.fillText("Knight: 200", this.faction.buildings[t].commandPanel.commandButtons[3].x + 1, this.faction.buildings[t].commandPanel.commandButtons[3].y + 66)
                            }
                            if (this.faction.buildings[t].timer > 0) {
                                if (dataflop == 0) {
                                    canvas_context.drawImage(progress, 0, (250 - (Math.round((this.faction.buildings[t].timer / this.faction.buildings[t].maxtimer) * 250))), progress.width, 10, faceborder.x, faceborder.y + faceborder.height + 2, faceborder.width, faceborder.width * .04)
                                    // dataflop = 1
                                }
                            } else {
                                //this.faction.units[t].commandPanel.commandButtons[0].color = "#090909"
                            }

                        }
                        if (this.faction.buildings[t].assembler == 1) {
                            // this.faction.buildings[t].spawnsmall = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 10, 125, 90, 50, "black")
                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[0].draw()
                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(hamartansoldier, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(hamartansoldierinv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)

                                }
                            }
                            // this.faction.buildings[t].spawnmedium = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 110, 125, 90, 50, "black")
                            // this.faction.buildings[t].commandPanel.commandButtons[1].draw()
                            // canvas_context.drawImage(infantry, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[1].x + 30, this.faction.buildings[t].commandPanel.commandButtons[1].y + 2, 50, 50)
                            this.faction.buildings[t].spawnbig = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 210, 125, 90, 50, "black")
                            // this.faction.buildings[t].commandPanel.commandButtons[2].draw()
                            // canvas_context.drawImage(sniper1, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[2].x + 30, this.faction.buildings[t].commandPanel.commandButtons[2].y + 2, 50, 50)


                            if (dataflop == 0) {
                                canvas_context.fillStyle = "white"
                                canvas_context.font = "14px arial"
                                // canvas_context.fillText("Drone: 30", this.faction.buildings[t].commandPanel.commandButtons[0].x + 1, this.faction.buildings[t].commandPanel.commandButtons[0].y + 66)
                                canvas_context.fillText("Soldier: 175", this.faction.buildings[t].commandPanel.commandButtons[0].x + 1, this.faction.buildings[t].commandPanel.commandButtons[0].y + 66)
                                // canvas_context.fillText("Sniper: 360", this.faction.buildings[t].commandPanel.commandButtons[2].x + 1, this.faction.buildings[t].commandPanel.commandButtons[2].y + 66)
                                // canvas_context.fillText("Drone: 30")
                                // canvas_context.fillText("Drone: 30")
                            }
                            if (this.faction.buildings[t].timer > 0) {
                                if (dataflop == 0) {
                                    canvas_context.drawImage(progress, 0, (250 - (Math.round((this.faction.buildings[t].timer / this.faction.buildings[t].maxtimer) * 250))), progress.width, 10, faceborder.x, faceborder.y + faceborder.height + 2, faceborder.width, faceborder.width * .04)
                                    // dataflop = 1
                                }
                            } else {
                                //this.faction.units[t].commandPanel.commandButtons[0].color = "#090909"
                            }

                        }
                        if (this.faction.buildings[t].assembler == 2) {
                            // this.faction.buildings[t].spawnsmall = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 10, 125, 90, 50, "black")
                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[0].draw()
                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(hamartanscout, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(hamartanscoutinv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)

                                }
                            }
                            // this.faction.buildings[t].spawnmedium = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 110, 125, 90, 50, "black")
                            // this.faction.buildings[t].commandPanel.commandButtons[1].draw()
                            // canvas_context.drawImage(infantry, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[1].x + 30, this.faction.buildings[t].commandPanel.commandButtons[1].y + 2, 50, 50)
                            this.faction.buildings[t].spawnbig = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 210, 125, 90, 50, "black")
                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[2].draw()
                                // canvas_context.drawImage(sniper1, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[2].x + 30, this.faction.buildings[t].commandPanel.commandButtons[2].y + 2, 50, 50)


                                canvas_context.fillStyle = "white"
                                canvas_context.font = "14px arial"
                                // canvas_context.fillText("Drone: 30", this.faction.buildings[t].commandPanel.commandButtons[0].x + 1, this.faction.buildings[t].commandPanel.commandButtons[0].y + 66)
                                canvas_context.fillText("Scout: 75", this.faction.buildings[t].commandPanel.commandButtons[0].x + 1, this.faction.buildings[t].commandPanel.commandButtons[0].y + 66)
                                // canvas_context.fillText("Sniper: 360", this.faction.buildings[t].commandPanel.commandButtons[2].x + 1, this.faction.buildings[t].commandPanel.commandButtons[2].y + 66)
                                // canvas_context.fillText("Drone: 30")
                                // canvas_context.fillText("Drone: 30")
                            }
                            if (this.faction.buildings[t].timer > 0) {
                                if (dataflop == 0) {
                                    canvas_context.drawImage(progress, 0, (250 - (Math.round((this.faction.buildings[t].timer / this.faction.buildings[t].maxtimer) * 250))), progress.width, 10, faceborder.x, faceborder.y + faceborder.height + 2, faceborder.width, faceborder.width * .04)
                                    // dataflop = 1
                                }
                            } else {
                                //this.faction.units[t].commandPanel.commandButtons[0].color = "#090909"
                            }

                        }
                        if (this.faction.buildings[t].bulbplant == 1) {
                            // if (dataflop == 0) {
                            //     //canvas_context.strokeText("Units", sandmap.window.body.x + sandmap.window.body.width + 10, 55)
                            //     //canvas_context.fillText("Units", sandmap.window.body.x + sandmap.window.body.width + 10, 55)
                            // }
                            // this.faction.buildings[t].spawnsmall = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 10, 125, 90, 50, "black")
                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[0].draw()
                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(librilbianpollinator, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(librilbianpollinatorinv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)

                                }
                            }
                            // this.faction.buildings[t].spawnmedium = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 110, 125, 90, 50, "black")
                            // this.faction.buildings[t].commandPanel.commandButtons[1].draw()
                            // canvas_context.drawImage(infantry, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[1].x + 30, this.faction.buildings[t].commandPanel.commandButtons[1].y + 2, 50, 50)
                            this.faction.buildings[t].spawnbig = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 210, 125, 90, 50, "black")
                            // this.faction.buildings[t].commandPanel.commandButtons[2].draw()
                            // canvas_context.drawImage(sniper1, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[2].x + 30, this.faction.buildings[t].commandPanel.commandButtons[2].y + 2, 50, 50)


                            if (dataflop == 0) {
                                canvas_context.fillStyle = "white"
                                canvas_context.font = "14px arial"
                                // canvas_context.fillText("Drone: 30", this.faction.buildings[t].commandPanel.commandButtons[0].x + 1, this.faction.buildings[t].commandPanel.commandButtons[0].y + 66)
                                canvas_context.fillText("Pollinator: 85", this.faction.buildings[t].commandPanel.commandButtons[0].x + 1, this.faction.buildings[t].commandPanel.commandButtons[0].y + 66)
                                // canvas_context.fillText("Sniper: 360", this.faction.buildings[t].commandPanel.commandButtons[2].x + 1, this.faction.buildings[t].commandPanel.commandButtons[2].y + 66)
                                // canvas_context.fillText("Drone: 30")
                                // canvas_context.fillText("Drone: 30")
                            }
                            if (this.faction.buildings[t].timer > 0) {
                                if (dataflop == 0) {
                                    canvas_context.drawImage(progress, 0, (250 - (Math.round((this.faction.buildings[t].timer / this.faction.buildings[t].maxtimer) * 250))), progress.width, 10, faceborder.x, faceborder.y + faceborder.height + 2, faceborder.width, faceborder.width * .04)
                                    // dataflop = 1
                                }
                            } else {
                                //this.faction.units[t].commandPanel.commandButtons[0].color = "#090909"
                            }

                        }
                        if (this.faction.buildings[t].bulbplant == 2) {
                            if (dataflop == 0) {
                                //canvas_context.strokeText("Units", sandmap.window.body.x + sandmap.window.body.width + 10, 55)
                                //canvas_context.fillText("Units", sandmap.window.body.x + sandmap.window.body.width + 10, 55)
                            }
                            // this.faction.buildings[t].spawnsmall = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 10, 125, 90, 50, "black")
                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[0].draw()
                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(librilbianpufffellow, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(librilbianpufffellowinv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                }
                            }
                            // this.faction.buildings[t].spawnmedium = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 110, 125, 90, 50, "black")
                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[1].draw()
                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(librilbianpodman, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[1].x + 30, this.faction.buildings[t].commandPanel.commandButtons[1].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(librilbianpodmaninv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[1].x + 30, this.faction.buildings[t].commandPanel.commandButtons[1].y + 2, 50, 50)
                                }
                            }
                            this.faction.buildings[t].spawnbig = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 210, 125, 90, 50, "black")
                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[2].draw()
                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(librilbiangoliophyte, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[2].x + 30, this.faction.buildings[t].commandPanel.commandButtons[2].y + 2, 50, 50)
                                } else {

                                    canvas_context.drawImage(librilbiangoliophyteinv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[2].x + 30, this.faction.buildings[t].commandPanel.commandButtons[2].y + 2, 50, 50)
                                }



                                canvas_context.fillStyle = "white"
                                canvas_context.font = "14px arial"
                                // canvas_context.fillText("Drone: 30", this.faction.buildings[t].commandPanel.commandButtons[0].x + 1, this.faction.buildings[t].commandPanel.commandButtons[0].y + 66)
                                canvas_context.fillText("Puff-Fellow: 90", this.faction.buildings[t].commandPanel.commandButtons[0].x + 1, this.faction.buildings[t].commandPanel.commandButtons[0].y + 66)
                                canvas_context.fillText("Podman: 140", this.faction.buildings[t].commandPanel.commandButtons[1].x + 1, this.faction.buildings[t].commandPanel.commandButtons[1].y + 66)
                                canvas_context.fillText("Golophyte: 355", this.faction.buildings[t].commandPanel.commandButtons[2].x + 1, this.faction.buildings[t].commandPanel.commandButtons[2].y + 66)
                                // canvas_context.fillText("Drone: 30")
                                // canvas_context.fillText("Drone: 30")
                            }
                            if (this.faction.buildings[t].timer > 0) {
                                if (dataflop == 0) {
                                    canvas_context.drawImage(progress, 0, (250 - (Math.round((this.faction.buildings[t].timer / this.faction.buildings[t].maxtimer) * 250))), progress.width, 10, faceborder.x, faceborder.y + faceborder.height + 2, faceborder.width, faceborder.width * .04)
                                    // dataflop = 1
                                }
                            } else {
                                //this.faction.units[t].commandPanel.commandButtons[0].color = "#090909"
                            }

                        }
                        if (this.faction.buildings[t].assembler == 3) {

                            if (dataflop == 0) {
                                //canvas_context.strokeText("Units", sandmap.window.body.x + sandmap.window.body.width + 10, 55)
                                //canvas_context.fillText("Units", sandmap.window.body.x + sandmap.window.body.width + 10, 55)
                            }
                            // this.faction.buildings[t].spawnsmall = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 10, 125, 90, 50, "black")
                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[0].draw()
                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(hamartanworker, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                } else {

                                    canvas_context.drawImage(hamartanworkerinv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                }
                            }
                            // this.faction.buildings[t].spawnmedium = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 110, 125, 90, 50, "black")
                            // this.faction.buildings[t].commandPanel.commandButtons[1].draw()
                            // canvas_context.drawImage(infantry, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[1].x + 30, this.faction.buildings[t].commandPanel.commandButtons[1].y + 2, 50, 50)
                            this.faction.buildings[t].spawnbig = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 210, 125, 90, 50, "black")
                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[2].draw()
                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(hamartaninvader, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[2].x + 30, this.faction.buildings[t].commandPanel.commandButtons[2].y + 2, 50, 50)
                                } else {

                                    canvas_context.drawImage(hamartaninvaderinv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[2].x + 30, this.faction.buildings[t].commandPanel.commandButtons[2].y + 2, 50, 50)
                                }
                            }


                            if (dataflop == 0) {
                                canvas_context.fillStyle = "white"
                                canvas_context.font = "14px arial"
                                // canvas_context.fillText("Drone: 30", this.faction.buildings[t].commandPanel.commandButtons[0].x + 1, this.faction.buildings[t].commandPanel.commandButtons[0].y + 66)
                                canvas_context.fillText("Worker: 145", this.faction.buildings[t].commandPanel.commandButtons[0].x + 1, this.faction.buildings[t].commandPanel.commandButtons[0].y + 66)
                                canvas_context.fillText("Invader: 340", this.faction.buildings[t].commandPanel.commandButtons[2].x + 1, this.faction.buildings[t].commandPanel.commandButtons[2].y + 66)
                                // canvas_context.fillText("Drone: 30")
                                // canvas_context.fillText("Drone: 30")
                            }
                            if (this.faction.buildings[t].timer > 0) {
                                if (dataflop == 0) {
                                    canvas_context.drawImage(progress, 0, (250 - (Math.round((this.faction.buildings[t].timer / this.faction.buildings[t].maxtimer) * 250))), progress.width, 10, faceborder.x, faceborder.y + faceborder.height + 2, faceborder.width, faceborder.width * .04)
                                    // dataflop = 1
                                }
                            } else {
                                //this.faction.units[t].commandPanel.commandButtons[0].color = "#090909"
                            }

                        }
                        if (this.faction.buildings[t].barracks == 2) {
                            // if (dataflop == 0) {
                            //     //canvas_context.strokeText("Units", sandmap.window.body.x + sandmap.window.body.width + 10, 55)
                            //     //canvas_context.fillText("Units", sandmap.window.body.x + sandmap.window.body.width + 10, 55)
                            // }
                            // this.faction.buildings[t].spawnsmall = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 10, 125, 90, 50, "black")
                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[0].draw()
                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(drone, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                } else {

                                    canvas_context.drawImage(droneinv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[0].x + 30, this.faction.buildings[t].commandPanel.commandButtons[0].y + 2, 50, 50)
                                }
                            }
                            // this.faction.buildings[t].spawnmedium = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 110, 125, 90, 50, "black")
                            // this.faction.buildings[t].commandPanel.commandButtons[1].draw()
                            // canvas_context.drawImage(infantry, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[1].x + 30, this.faction.buildings[t].commandPanel.commandButtons[1].y + 2, 50, 50)
                            this.faction.buildings[t].spawnbig = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 210, 125, 90, 50, "black")
                            if (dataflop == 0) {
                                // this.faction.buildings[t].commandPanel.commandButtons[2].draw()

                                if (sandmap.players.indexOf(this.faction.buildings[t].faction) == sandmap.turn) {
                                    canvas_context.drawImage(harvester, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[2].x + 30, this.faction.buildings[t].commandPanel.commandButtons[2].y + 2, 50, 50)
                                } else {
                                    canvas_context.drawImage(harvesterinv, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[2].x + 30, this.faction.buildings[t].commandPanel.commandButtons[2].y + 2, 50, 50)

                                }


                                canvas_context.fillStyle = "white"
                                canvas_context.font = "14px arial"
                                canvas_context.fillText("Scout: 30", this.faction.buildings[t].commandPanel.commandButtons[0].x + 1, this.faction.buildings[t].commandPanel.commandButtons[0].y + 66)
                                // canvas_context.fillText("Infantry: 90", this.faction.buildings[t].commandPanel.commandButtons[1].x + 1, this.faction.buildings[t].commandPanel.commandButtons[1].y + 66)
                                canvas_context.fillText("Harvester: 190", this.faction.buildings[t].commandPanel.commandButtons[2].x + 1, this.faction.buildings[t].commandPanel.commandButtons[2].y + 66)
                                // canvas_context.fillText("Drone: 30")
                                // canvas_context.fillText("Drone: 30")
                            }
                            if (this.faction.buildings[t].timer > 0) {
                                if (dataflop == 0) {
                                    canvas_context.drawImage(progress, 0, (250 - (Math.round((this.faction.buildings[t].timer / this.faction.buildings[t].maxtimer) * 250))), progress.width, 10, faceborder.x, faceborder.y + faceborder.height + 2, faceborder.width, faceborder.width * .04)
                                    // dataflop = 1
                                }
                            } else {
                                //this.faction.units[t].commandPanel.commandButtons[0].color = "#090909"
                            }

                        }
                        if (this.faction.buildings[t].gate == 1) {

                            canvas_context.fillStyle = "white"
                            if (dataflop == 0) {
                                if (this.faction.buildings[t].open == 1) {
                                    // canvas_context.strokeText("Status: Open", facex2+72, 55)
                                    canvas_context.fillText("Status: Open", facex2 + 72, 55)
                                } else {
                                    // canvas_context.strokeText("Status: Closed", sandmap.window.body.x + sandmap.window.body.width + 10, 55)
                                    canvas_context.fillText("Status: Closed", facex2 + 72, 55)
                                }
                            }
                            // this.faction.buildings[t].spawnsmall = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 10, 125, 90, 50, "black")

                            // if (dataflop == 0) {
                            //     this.faction.buildings[t].commandPanel.commandButtons[0].draw()
                            // }
                            // this.faction.buildings[t].spawnmedium = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 110, 125, 90, 50, "black")
                            // this.faction.buildings[t].commandPanel.commandButtons[1].draw()
                            // canvas_context.drawImage(infantry, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[1].x + 30, this.faction.buildings[t].commandPanel.commandButtons[1].y + 2, 50, 50)
                            this.faction.buildings[t].spawnbig = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 210, 125, 90, 50, "black")
                            // this.faction.buildings[t].commandPanel.commandButtons[2].draw()
                            // canvas_context.drawImage(harvester, 0, 0, 10, 10, this.faction.buildings[t].commandPanel.commandButtons[2].x + 30, this.faction.buildings[t].commandPanel.commandButtons[2].y + 2, 50, 50)

                            if (dataflop == 0) {
                                canvas_context.fillStyle = "white"
                                canvas_context.font = "22px arial"

                                if (this.faction.buildings[t].open == 1) {
                                    canvas_context.fillText("Close", this.faction.buildings[t].commandPanel.commandButtons[0].x + 5, this.faction.buildings[t].commandPanel.commandButtons[0].y + 37)
                                } else {
                                    canvas_context.fillText("Open", this.faction.buildings[t].commandPanel.commandButtons[0].x + 15, this.faction.buildings[t].commandPanel.commandButtons[0].y + 37)
                                }
                            }
                        }


                        if (dataflop == 0) {
                            dataflop = 1
                        }


                    }

                }

            }

        }
        default() {
            
            if (this.state == 0) {

                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {

                    canvas_context.fillStyle = this.faction.color
                    canvas_context.font = "28px arial"

                    canvas_context.fillStyle = "black"
                    canvas_context.strokeStyle = sandmap.players[sandmap.turn].color
                    canvas_context.lineWidth = 1.5
                    canvas_context.font = "28px arial"
                    if (dataflop == 0) {
                        canvas_context.strokeText(this.faction.name, sandmap.window.body.x + sandmap.window.body.width + 10, 25)
                        canvas_context.fillText(this.faction.name, sandmap.window.body.x + sandmap.window.body.width + 10, 25)
                    }


                    // this.faction.commandPanel.commandButtons[0] = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 20, 70, 140, 70, "black")
                    // this.faction.commandPanel.commandButtons[1] = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 170, 70, 140, 70, "black")
                    // this.faction.commandPanel.commandButtons[2] = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 20, 170, 140, 70, "black")
                    // this.faction.commandPanel.commandButtons[3] = new UiRectangle(sandmap.window.body.x + sandmap.window.body.width + 170, 170, 140, 70, "black")

                    if (dataflop == 0) {

                        if (this.faction.type == 4) {
                            this.faction.commandPanel.commandButtons[0].draw()
                            this.faction.commandPanel.commandButtons[1].draw()

                            let barrect = new UiRectangle(this.faction.commandPanel.commandButtons[1].x + 25, this.faction.commandPanel.commandButtons[1].y + 5, 40, 40, this.faction.color)
                            barrect.draw()
                            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                                canvas_context.drawImage(sporeball, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[1].x + 25, this.faction.commandPanel.commandButtons[1].y + 5, 40, 40)
                            } else {

                                canvas_context.drawImage(sporeballinv, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[1].x + 25, this.faction.commandPanel.commandButtons[1].y + 5, 40, 40)
                            }
                            canvas_context.fillStyle = "white"
                            canvas_context.font = "12px arial"
                            canvas_context.fillText("Sporeball: 170", this.faction.commandPanel.commandButtons[1].x + 15, this.faction.commandPanel.commandButtons[1].y + 66)

                            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                                canvas_context.drawImage(slime, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[0].x + 25, this.faction.commandPanel.commandButtons[0].y + 5, 40, 40)
                            } else {

                                canvas_context.drawImage(slimeinv, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[0].x + 25, this.faction.commandPanel.commandButtons[0].y + 5, 40, 40)
                            }
                            canvas_context.fillStyle = "white"
                            canvas_context.font = "12px arial"
                            canvas_context.fillText("Slime: 2", this.faction.commandPanel.commandButtons[0].x + 15, this.faction.commandPanel.commandButtons[0].y + 66)
                            if (this.faction.Nflag == 1) {
                                const xout = new RedX(this.faction.commandPanel.commandButtons[1].x + 90, this.faction.commandPanel.commandButtons[1].y + 15)
                                xout.draw()
                            }
                            if (this.faction.Bflag == 1) {
                                const xout = new RedX(this.faction.commandPanel.commandButtons[0].x + 90, this.faction.commandPanel.commandButtons[0].y + 15)
                                xout.draw()
                            }

                        } else if (this.faction.type == 0) {
                            this.faction.commandPanel.commandButtons[0].draw()
                            this.faction.commandPanel.commandButtons[1].draw()
                            this.faction.commandPanel.commandButtons[2].draw()
                            this.faction.commandPanel.commandButtons[3].draw()

                            let barrect = new UiRectangle(this.faction.commandPanel.commandButtons[1].x + 25, this.faction.commandPanel.commandButtons[1].y + 5, 40, 40, this.faction.color)
                            barrect.draw()
                            canvas_context.drawImage(barracks, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[1].x + 25, this.faction.commandPanel.commandButtons[1].y + 5, 40, 40)
                            canvas_context.fillStyle = "white"
                            canvas_context.font = "12px arial"
                            canvas_context.fillText("Barracks: 50", this.faction.commandPanel.commandButtons[1].x + 15, this.faction.commandPanel.commandButtons[1].y + 66) //70

                            barrect = new UiRectangle(this.faction.commandPanel.commandButtons[2].x + 25, this.faction.commandPanel.commandButtons[2].y + 5, 40, 40, this.faction.color)
                            barrect.draw()
                            canvas_context.drawImage(machinelab, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[2].x + 25, this.faction.commandPanel.commandButtons[2].y + 5, 40, 40)
                            canvas_context.fillStyle = "white"
                            canvas_context.font = "12px arial"
                            canvas_context.fillText("Machine Lab: 110", this.faction.commandPanel.commandButtons[2].x + 15, this.faction.commandPanel.commandButtons[2].y + 66)

                            barrect = new UiRectangle(this.faction.commandPanel.commandButtons[3].x + 25, this.faction.commandPanel.commandButtons[3].y + 5, 40, 40, this.faction.color)
                            barrect.draw()
                            canvas_context.drawImage(closedgate, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[3].x + 25, this.faction.commandPanel.commandButtons[3].y + 5, 40, 40)
                            canvas_context.fillStyle = "white"
                            canvas_context.font = "12px arial"
                            canvas_context.fillText("Blast Door: 25", this.faction.commandPanel.commandButtons[3].x + 15, this.faction.commandPanel.commandButtons[3].y + 66)

                            barrect = new UiRectangle(this.faction.commandPanel.commandButtons[0].x + 25, this.faction.commandPanel.commandButtons[0].y + 5, 40, 40, this.faction.color)
                            barrect.draw()
                            canvas_context.drawImage(icewall, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[0].x + 25, this.faction.commandPanel.commandButtons[0].y + 5, 40, 40)
                            canvas_context.fillStyle = "white"
                            canvas_context.font = "12px arial"
                            canvas_context.fillText("Wall: 10", this.faction.commandPanel.commandButtons[0].x + 15, this.faction.commandPanel.commandButtons[0].y + 66)
                            if (this.faction.Nflag == 1) {
                                const xout = new RedX(this.faction.commandPanel.commandButtons[1].x + 90, this.faction.commandPanel.commandButtons[1].y + 15)
                                xout.draw()
                            }
                            if (this.faction.Gflag == 1) {
                                const xout = new RedX(this.faction.commandPanel.commandButtons[3].x + 90, this.faction.commandPanel.commandButtons[3].y + 15)
                                xout.draw()
                            }
                            if (this.faction.Mflag == 1) {
                                const xout = new RedX(this.faction.commandPanel.commandButtons[2].x + 90, this.faction.commandPanel.commandButtons[2].y + 15)
                                xout.draw()
                            }
                            if (this.faction.Bflag == 1) {
                                const xout = new RedX(this.faction.commandPanel.commandButtons[0].x + 90, this.faction.commandPanel.commandButtons[0].y + 15)
                                xout.draw()
                            }
                        } else if (this.faction.type == 5) {
                            this.faction.commandPanel.commandButtons[0].draw()

                            // let barrect = new UiRectangle(this.faction.commandPanel.commandButtons[0].x + 25, this.faction.commandPanel.commandButtons[0].y + 5, 40, 40, this.faction.color)
                            // barrect.draw()
                            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                                canvas_context.drawImage(eggmound, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[0].x + 25, this.faction.commandPanel.commandButtons[0].y + 5, 40, 40)
                            } else {
                                canvas_context.drawImage(eggmoundinv, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[0].x + 25, this.faction.commandPanel.commandButtons[0].y + 5, 40, 40)
                            }
                            canvas_context.fillStyle = "white"
                            canvas_context.font = "12px arial"
                            canvas_context.fillText("Eggmound: 105", this.faction.commandPanel.commandButtons[0].x + 15, this.faction.commandPanel.commandButtons[0].y + 66)
                            if (this.faction.Bflag == 1) {
                                const xout = new RedX(this.faction.commandPanel.commandButtons[0].x + 90, this.faction.commandPanel.commandButtons[0].y + 15)
                                xout.draw()
                            }
                        } else if (this.faction.type == 7) {
                            this.faction.commandPanel.commandButtons[0].draw()
                            this.faction.commandPanel.commandButtons[1].draw()

                            // let barrect = new UiRectangle(this.faction.commandPanel.commandButtons[0].x + 25, this.faction.commandPanel.commandButtons[0].y + 5, 40, 40, this.faction.color)
                            // barrect.draw()
                            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                                canvas_context.drawImage(pond, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[0].x + 25, this.faction.commandPanel.commandButtons[0].y + 5, 40, 40)
                                canvas_context.drawImage(teleporterimg, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[1].x + 25, this.faction.commandPanel.commandButtons[1].y + 5, 40, 40)
                            } else {
                                canvas_context.drawImage(pondinv, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[0].x + 25, this.faction.commandPanel.commandButtons[0].y + 5, 40, 40)
                                canvas_context.drawImage(teleporterimg, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[1].x + 25, this.faction.commandPanel.commandButtons[1].y + 5, 40, 40)
                            }
                            canvas_context.fillStyle = "white"
                            canvas_context.font = "12px arial"
                            canvas_context.fillText("Pond: 250", this.faction.commandPanel.commandButtons[0].x + 15, this.faction.commandPanel.commandButtons[0].y + 66)
                            canvas_context.fillStyle = "white"
                            canvas_context.font = "12px arial"
                            canvas_context.fillText("Teleporter: 300", this.faction.commandPanel.commandButtons[1].x + 15, this.faction.commandPanel.commandButtons[1].y + 66)
                            if (this.faction.Bflag == 1) {
                                const xout = new RedX(this.faction.commandPanel.commandButtons[0].x + 90, this.faction.commandPanel.commandButtons[0].y + 15)
                                xout.draw()
                            }
                            if (this.faction.Mflag == 1) {
                                const xout = new RedX(this.faction.commandPanel.commandButtons[1].x + 90, this.faction.commandPanel.commandButtons[1].y + 15)
                                xout.draw()
                            }
                        } else if (this.faction.type == 9) {
                            this.faction.commandPanel.commandButtons[0].draw()

                            // let barrect = new UiRectangle(this.faction.commandPanel.commandButtons[0].x + 25, this.faction.commandPanel.commandButtons[0].y + 5, 40, 40, this.faction.color)
                            // barrect.draw()
                            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                                canvas_context.drawImage(gogonauttree2, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[0].x + 25, this.faction.commandPanel.commandButtons[0].y + 5, 40, 40)
                            } else {
                                canvas_context.drawImage(gogonauttreeinv2, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[0].x + 25, this.faction.commandPanel.commandButtons[0].y + 5, 40, 40)
                            }
                            canvas_context.fillStyle = "white"
                            canvas_context.font = "12px arial"
                            canvas_context.fillText("Tree: 200", this.faction.commandPanel.commandButtons[0].x + 15, this.faction.commandPanel.commandButtons[0].y + 66)
                            if (this.faction.Bflag == 1) {
                                const xout = new RedX(this.faction.commandPanel.commandButtons[0].x + 90, this.faction.commandPanel.commandButtons[0].y + 15)
                                xout.draw()
                            }
                        }  else if (this.faction.type == 10) {
                            this.faction.commandPanel.commandButtons[0].draw()

                            // let barrect = new UiRectangle(this.faction.commandPanel.commandButtons[0].x + 25, this.faction.commandPanel.commandButtons[0].y + 5, 40, 40, this.faction.color)
                            // barrect.draw()
                            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                                canvas_context.drawImage(beehiveimg, 0, 0, 20, 20, this.faction.commandPanel.commandButtons[0].x + 25, this.faction.commandPanel.commandButtons[0].y + 5, 40, 40)
                            } else {
                                canvas_context.drawImage(beehiveimg, 0, 0, 20, 20, this.faction.commandPanel.commandButtons[0].x + 25, this.faction.commandPanel.commandButtons[0].y + 5, 40, 40)
                            }
                            canvas_context.fillStyle = "white"
                            canvas_context.font = "12px arial"
                            canvas_context.fillText("Hive: 400", this.faction.commandPanel.commandButtons[0].x + 15, this.faction.commandPanel.commandButtons[0].y + 66)
                            if (this.faction.Bflag == 1) {
                                const xout = new RedX(this.faction.commandPanel.commandButtons[0].x + 90, this.faction.commandPanel.commandButtons[0].y + 15)
                                xout.draw()
                            }
                        } else if (this.faction.type == 1) {

                        } else if (this.faction.type == 2) {
                            this.faction.counterUI++
                            this.faction.commandPanel.commandButtons[0].draw()
                            this.faction.commandPanel.commandButtons[1].draw()
                            this.faction.commandPanel.commandButtons[2].draw()
                            this.faction.commandPanel.commandButtons[3].draw()

                            let barrect = new UiRectangle(this.faction.commandPanel.commandButtons[1].x + 25, this.faction.commandPanel.commandButtons[1].y + 5, 40, 40, this.faction.color)
                            // barrect.draw()
                            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                                canvas_context.drawImage(assembler1, (this.faction.counterUI % 10), 0, 10, 10, this.faction.commandPanel.commandButtons[1].x + 25, this.faction.commandPanel.commandButtons[1].y + 5, 40, 40)
                            } else {
                                canvas_context.drawImage(assembler1inv, (this.faction.counterUI % 10), 0, 10, 10, this.faction.commandPanel.commandButtons[1].x + 25, this.faction.commandPanel.commandButtons[1].y + 5, 40, 40)
                            }
                            canvas_context.fillStyle = "white"
                            canvas_context.font = "10px arial"
                            canvas_context.fillText("Soldier Assembler: 130", this.faction.commandPanel.commandButtons[1].x + 5, this.faction.commandPanel.commandButtons[1].y + 66)

                            barrect = new UiRectangle(this.faction.commandPanel.commandButtons[2].x + 25, this.faction.commandPanel.commandButtons[2].y + 5, 40, 40, this.faction.color)
                            // barrect.draw()

                            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                                canvas_context.drawImage(assembler2, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[2].x + 25, this.faction.commandPanel.commandButtons[2].y + 5, 40, 40)
                            } else {
                                canvas_context.drawImage(assembler2inv, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[2].x + 25, this.faction.commandPanel.commandButtons[2].y + 5, 40, 40)
                            }
                            canvas_context.fillStyle = "white"
                            canvas_context.font = "10px arial"
                            canvas_context.fillText("Scout Assembler: 210", this.faction.commandPanel.commandButtons[2].x + 5, this.faction.commandPanel.commandButtons[2].y + 66)

                            barrect = new UiRectangle(this.faction.commandPanel.commandButtons[3].x + 25, this.faction.commandPanel.commandButtons[3].y + 5, 40, 40, this.faction.color)
                            // barrect.draw()
                            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                                canvas_context.drawImage(assembler3, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[3].x + 25, this.faction.commandPanel.commandButtons[3].y + 5, 40, 40)
                            } else {
                                canvas_context.drawImage(assembler3inv, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[3].x + 25, this.faction.commandPanel.commandButtons[3].y + 5, 40, 40)
                            }
                            canvas_context.fillStyle = "white"
                            canvas_context.font = "8.5px arial"
                            canvas_context.fillText("High-Caste Assembler: 340", this.faction.commandPanel.commandButtons[3].x + 3, this.faction.commandPanel.commandButtons[3].y + 66)

                            barrect = new UiRectangle(this.faction.commandPanel.commandButtons[0].x + 25, this.faction.commandPanel.commandButtons[0].y + 5, 40, 40, this.faction.color)
                            // barrect.draw()
                            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                                canvas_context.drawImage(spire, (this.faction.counterUI % 5) * 10, 0, 10, 10, this.faction.commandPanel.commandButtons[0].x + 25, this.faction.commandPanel.commandButtons[0].y + 5, 40, 40)
                            } else {
                                canvas_context.drawImage(spireinv, (this.faction.counterUI % 5) * 10, 0, 10, 10, this.faction.commandPanel.commandButtons[0].x + 25, this.faction.commandPanel.commandButtons[0].y + 5, 40, 40)
                            }
                            canvas_context.fillStyle = "white"
                            canvas_context.font = "10px arial"
                            canvas_context.fillText("Spire: 40", this.faction.commandPanel.commandButtons[0].x + 35, this.faction.commandPanel.commandButtons[0].y + 66)
                            if (this.faction.Nflag == 1) {
                                const xout = new RedX(this.faction.commandPanel.commandButtons[1].x + 90, this.faction.commandPanel.commandButtons[1].y + 15)
                                xout.draw()
                            }
                            if (this.faction.Gflag == 1) {
                                const xout = new RedX(this.faction.commandPanel.commandButtons[3].x + 90, this.faction.commandPanel.commandButtons[3].y + 15)
                                xout.draw()
                            }
                            if (this.faction.Mflag == 1) {
                                const xout = new RedX(this.faction.commandPanel.commandButtons[2].x + 90, this.faction.commandPanel.commandButtons[2].y + 15)
                                xout.draw()
                            }
                            if (this.faction.Bflag == 1) {
                                const xout = new RedX(this.faction.commandPanel.commandButtons[0].x + 90, this.faction.commandPanel.commandButtons[0].y + 15)
                                xout.draw()
                            }

                        } else if (this.faction.type == 3) {
                            this.faction.counterUI++
                            // this.faction.commandPanel.commandButtons[0].draw()
                            this.faction.commandPanel.commandButtons[1].draw()
                            this.faction.commandPanel.commandButtons[2].draw()
                            // this.faction.commandPanel.commandButtons[3].draw()

                            let barrect = new UiRectangle(this.faction.commandPanel.commandButtons[1].x + 25, this.faction.commandPanel.commandButtons[1].y + 5, 40, 40, this.faction.color)
                            // barrect.draw()

                            if (sandmap.players.indexOf(this.faction) == 0) {
                                canvas_context.drawImage(librilbianbulbplant, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[1].x + 25, this.faction.commandPanel.commandButtons[1].y + 5, 40, 40)
                            } else {
                                canvas_context.drawImage(librilbianbulbplantinv, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[1].x + 25, this.faction.commandPanel.commandButtons[1].y + 5, 40, 40)
                            }
                            canvas_context.fillStyle = "white"
                            canvas_context.font = "11px arial"
                            canvas_context.fillText("Bulbplant: 80", this.faction.commandPanel.commandButtons[1].x + 5, this.faction.commandPanel.commandButtons[1].y + 66)

                            barrect = new UiRectangle(this.faction.commandPanel.commandButtons[2].x + 25, this.faction.commandPanel.commandButtons[2].y + 5, 40, 40, this.faction.color)
                            // barrect.draw()
                            if (sandmap.players.indexOf(this.faction) == 0) {
                                canvas_context.drawImage(librilbianpodmother, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[2].x + 25, this.faction.commandPanel.commandButtons[2].y + 5, 40, 40)
                            } else {
                                canvas_context.drawImage(librilbianpodmotherinv, 0, 0, 10, 10, this.faction.commandPanel.commandButtons[2].x + 25, this.faction.commandPanel.commandButtons[2].y + 5, 40, 40)

                            }
                            canvas_context.fillStyle = "white"
                            canvas_context.font = "11px arial"
                            canvas_context.fillText("Podmother: 210", this.faction.commandPanel.commandButtons[2].x + 5, this.faction.commandPanel.commandButtons[2].y + 66)


                            if (this.faction.Nflag == 1) {
                                const xout = new RedX(this.faction.commandPanel.commandButtons[1].x + 90, this.faction.commandPanel.commandButtons[1].y + 15)
                                xout.draw()
                            }
                            if (this.faction.Gflag == 1) {
                                const xout = new RedX(this.faction.commandPanel.commandButtons[3].x + 90, this.faction.commandPanel.commandButtons[3].y + 15)
                                xout.draw()
                            }
                            if (this.faction.Mflag == 1) {
                                const xout = new RedX(this.faction.commandPanel.commandButtons[2].x + 90, this.faction.commandPanel.commandButtons[2].y + 15)
                                xout.draw()
                            }
                            if (this.faction.Bflag == 1) {
                                const xout = new RedX(this.faction.commandPanel.commandButtons[0].x + 90, this.faction.commandPanel.commandButtons[0].y + 15)
                                xout.draw()
                            }

                        }
                    }



                }

                this.faction.commandPanel.textdraw()
            }
        }
        display() {
            this.state = 0
            let count = 0
            for (let t = 0; t < this.faction.units.length; t++) {
                if (this.faction.units[t].selected == 1) {
                    this.state++
                    count++
                }
                if (this.faction.units[t].selected == 2) {
                    this.state += .9
                    count++
                }
            }
            for (let t = 0; t < this.faction.buildings.length; t++) {
                if (this.faction.buildings[t].selected == 1) {
                    this.state = -1
                }
            }
            if (this.state > 0 && this.state < 2) {
                this.state = 1
            }
            if (count > 1 && pflag == 0) {
                this.state = 2
            }
            if (this.state == 0) {
                this.default()
            }
            if (this.state == -1) {
                this.building()
            }
            if (this.state == 1) {
                this.singleAgent()
            }

            if (this.state >= 2) {
                this.manyAgents()
            }


            this.hotkeys()
            if (dataflop == 0) {
                this.faction.flopped = 1
                dataflop = 1
            } else {
                this.faction.flopped = 0
            }
        }
    }
    class PlayerCommands {
        constructor(agent) {
            this.agent = agent
            this.commandButtons = []
            this.x = 905
            this.y = 98
            for (let t = 0; t < 9; t++) {
                if (t > 0 && t % 3 == 0) {
                    this.y += 72
                    this.x = 905
                }
                const button = new UiRectangle(this.x, this.y, 110, 69, "#090909")
                this.x += 115
                this.commandButtons.push(button)
            }
        }
        draw() {
            for (let t = 0; t < this.commandButtons.length; t++) {
                this.commandButtons[t].draw()
                canvas_context.font = "12px arial"
                canvas_context.fillStyle = "white"
                canvas_context.fillText(this.text[t], this.commandButtons[t].x + 5, this.commandButtons[t].y + 14)
            }
        }
        textdraw() {

            this.text = [' ', ' ', ' ', '  ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']
            if (this.agent.type == 0) {
                this.text = ['q', 'c', 'e', 'r', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']
            } else if (this.agent.type == 1) {
                this.text = [' ', ' ', ' ', '  ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']
            } else if (this.agent.type == 2) {
                this.text = ['q', 'c', 'e', 'r', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']
            } else if (this.agent.type == 3) {
                this.text = [' ', 'c', 'e', '  ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']
            } else if (this.agent.type == 4) {
                this.text = ['q', 'c', ' ', '  ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']
            } else if (this.agent.type == 5) {
                this.text = ['q', ' ', ' ', '  ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']
            } else if (this.agent.type == 6) {
                this.text = [' ', ' ', ' ', '  ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']
            } else if (this.agent.type == 7) {
                this.text = ['q', 'e', ' ', '  ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']
            } else if (this.agent.type == 8) {
                this.text = [' ', ' ', ' ', '  ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']
            } else if (this.agent.type == 9) {
                this.text = ['q', ' ', ' ', '  ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']
            } else if (this.agent.type == 10) {
                this.text = ['q', ' ', ' ', '  ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ']
            }

            if(controllerSupport == 1){
                this.text = ['Y', 'B', 'A', 'LB', 'RB', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',]
            }


            for (let t = 0; t < this.commandButtons.length; t++) {
                // this.commandButtons[t].draw()
                canvas_context.font = "12px arial"
                canvas_context.fillStyle = "white"
                canvas_context.fillText(this.text[t], this.commandButtons[t].x + 5, this.commandButtons[t].y + 14)
            }
        }
    }
    class BuildingQue {
        constructor(building) {
            this.building = building
        }
        draw() {
            if (this.building.faction.isAI == 1) {
                return
            }
            for (let t = 0; t < this.building.loaded.length; t++) {
                const rect = new UiRectangle(1240 + ((t % 2) * 20), 100 + (Math.floor(t / 2) * 20), 20, 20, "black")
                rect.draw()
                if (sandmap.players.indexOf(this.building.faction) == 0) {

                    if (this.building.loaded[t] == "drone") {
                        canvas_context.drawImage(drone, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "harvester") {
                        canvas_context.drawImage(harvester, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "infantry") {
                        canvas_context.drawImage(infantry, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "sniper") {
                        canvas_context.drawImage(sniper1, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "soldier") {
                        canvas_context.drawImage(hamartansoldier, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "invader") {
                        canvas_context.drawImage(hamartaninvader, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "scout") {
                        canvas_context.drawImage(hamartanscout, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "worker") {
                        canvas_context.drawImage(hamartanworker, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "buddy") {
                        canvas_context.drawImage(fruitingbuddy, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "knight") {
                        canvas_context.drawImage(mycoknight, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "seer") {
                        canvas_context.drawImage(sporeseer, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "vizier") {
                        canvas_context.drawImage(sporevizir, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "pollinator") {
                        canvas_context.drawImage(librilbianpollinator, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "goliophyte") {
                        canvas_context.drawImage(librilbiangoliophyte, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "podman") {
                        canvas_context.drawImage(librilbianpodman, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "pufffellow") {
                        canvas_context.drawImage(librilbianpufffellow, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "gogonautunit") {
                        canvas_context.drawImage(gogonaut, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "gogonautdefender") {
                        canvas_context.drawImage(gogonautdefender, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "gogonautchampion") {
                        canvas_context.drawImage(gogonautchampion, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "gogonautteam") {
                        canvas_context.drawImage(gogonautteam, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "babyalagadile") {
                        canvas_context.drawImage(alagadile, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "bigalagadile") {
                        canvas_context.drawImage(bigalagadile, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "hunchalagadile") {
                        canvas_context.drawImage(hunchalagadile, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "bighunchalagadile") {
                        canvas_context.drawImage(bighunchalagadile, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "spawn") {
                        canvas_context.drawImage(nymph, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    }else if (this.building.loaded[t] == "beeworker") {
                        canvas_context.drawImage(beeworkerimg, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    }else if (this.building.loaded[t] == "beesoldier") {
                        canvas_context.drawImage(beesoldierimg, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    }else if (this.building.loaded[t] == "beemega") {
                        canvas_context.drawImage(beemegaimg, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    }else if (this.building.loaded[t] == "beescout") {
                        canvas_context.drawImage(beescoutimg, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    }
                } else {

                    if (this.building.loaded[t] == "drone") {
                        canvas_context.drawImage(droneinv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "harvester") {
                        canvas_context.drawImage(harvesterinv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "infantry") {
                        canvas_context.drawImage(infantryinv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "sniper") {
                        canvas_context.drawImage(sniper1inv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "soldier") {
                        canvas_context.drawImage(hamartansoldierinv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "invader") {
                        canvas_context.drawImage(hamartaninvaderinv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "scout") {
                        canvas_context.drawImage(hamartanscoutinv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "worker") {
                        canvas_context.drawImage(hamartanworkerinv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "buddy") {
                        canvas_context.drawImage(fruitingbuddyinv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "knight") {
                        canvas_context.drawImage(mycoknightinv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "seer") {
                        canvas_context.drawImage(sporeseerinv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "vizier") {
                        canvas_context.drawImage(sporevizirinv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "pollinator") {
                        canvas_context.drawImage(librilbianpollinatorinv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "goliophyte") {
                        canvas_context.drawImage(librilbiangoliophyteinv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "podman") {
                        canvas_context.drawImage(librilbianpodmaninv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "pufffellow") {
                        canvas_context.drawImage(librilbianpufffellowinv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "gogonautunit") {
                        canvas_context.drawImage(gogonautinv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "gogonautdefender") {
                        canvas_context.drawImage(gogonautdefenderinv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "gogonautchampion") {
                        canvas_context.drawImage(gogonautchampioninv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "gogonautteam") {
                        canvas_context.drawImage(gogonautteaminv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "babyalagadile") {
                        canvas_context.drawImage(alagadileinv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "bigalagadile") {
                        canvas_context.drawImage(bigalagadileinv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "hunchalagadile") {
                        canvas_context.drawImage(hunchalagadileinv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "bighunchalagadile") {
                        canvas_context.drawImage(bighunchalagadileinv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    } else if (this.building.loaded[t] == "spawn") {
                        canvas_context.drawImage(nymphinv, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    }else if (this.building.loaded[t] == "beeworker") {
                        canvas_context.drawImage(beeworkerimg, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    }else if (this.building.loaded[t] == "beesoldier") {
                        canvas_context.drawImage(beesoldierimg, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    }else if (this.building.loaded[t] == "beemega") {
                        canvas_context.drawImage(beemegaimg, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    }else if (this.building.loaded[t] == "beescout") {
                        canvas_context.drawImage(beescoutimg, 0, 0, 10, 10, rect.x, rect.y, 20, 20)
                    }
                }

            }
        }
    }
    class AgentCommands {
        constructor(agent) {
            this.agent = agent
            this.commandButtons = []
            this.x = sandmap.window.body.x + sandmap.window.body.width + 5
            this.y = 98
            for (let t = 0; t < 9; t++) {
                if (t > 0 && t % 3 == 0) {
                    this.y += 72
                    this.x = sandmap.window.body.x + sandmap.window.body.width + 5
                }
                const button = new UiRectangle(this.x, this.y, 110, 69, "#090909")
                this.x += 115
                this.commandButtons.push(button)
            }
                this.text = ['q', 'c', 'e', 'r', 't', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',]
        }
        draw() {

            if(controllerSupport == 0){
                this.text = ['q', 'c', 'e', 'r', 't', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',]
            }else{
                if(this.agent.faction.type == 6 || this.agent.faction.type == 8){
                    this.text = ['RB', 'B', 'A', 'Y', 'LB', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',]
                }else{
                    this.text = ['Y', 'B', 'A', 'RB', 'LB', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',]
                }
            }
            for (let t = 0; t < this.commandButtons.length; t++) {
                this.commandButtons[t].draw()
                canvas_context.font = "12px arial"
                canvas_context.fillStyle = "white"
                canvas_context.fillText(this.text[t], this.commandButtons[t].x + 5, this.commandButtons[t].y + 14)
            }
        }
    }
    class AgentTile {
        constructor(agent) {
            this.agent = agent
            this.image = {}
            let t = 0
            this.x = (sandmap.window.body.x + sandmap.window.body.width + 10) + (55 * (t % 6))
            this.y = 10 + (55 * (Math.floor(t / 6)))
            this.width = 50
            this.height = 50
        }
        isPointInside(point) {
            if (point.x >= this.x) {
                if (point.y >= this.y) {
                    if (point.x <= this.x + this.width) {
                        if (point.y <= this.y + this.height) {
                            return true
                        }
                    }
                }
            }
            return false
        }
        draw(t, max) {
            let workableArea = 1280 - (sandmap.window.body.width + 20)
            let tall = 250


            // canvas_context.fillRect(sandmap.window.body.width + 10,10,360, tall)

            let total = workableArea * tall
            let squarepix = total / (max)
            let dim = Math.sqrt(squarepix)
            let cal = dim//50-(Math.floor(Math.sqrt(max))*3)
            let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 15, 18, 20, 24, 30, 36, 40, 45, 60, 72, 90, 120, 180, 360]
            let calx = cal * 1.1
            let caly = cal * 1.1
            let slots = 1//workableArea / calx
            let g = 0
            // for(let t = 0;t<arr.length;t++){
            //     if(slots < arr[t]){
            //         slots = arr[t]
            //         g = t
            //         break
            //     }
            // }
            calx = workableArea / slots
            caly = calx
            cal = calx / 1.1
            while (Math.ceil((max) / slots) * caly > tall && g < arr.length) {
                slots = arr[g + 1]
                g++
                calx = workableArea / slots
                cal = calx / 1.1
                caly = calx
            }
            // cal = Math.round(cal*10000)/10000
            //      //////////console.log(workableArea)
            //      let j = 0
            // while(!Number.isInteger((slots)) && j<10000){
            //     j++
            //     cal-=.0001
            //      slots = workableArea / calx
            //      calx = cal * 1.1
            //      caly = cal * 1.1
            // }
            this.x = (sandmap.window.body.x + sandmap.window.body.width + 10) + (calx * (t % (Math.floor((slots)))))
            this.y = 10 + (caly * (Math.floor(t / ((Math.floor((slots)))))))
            this.width = cal
            this.height = cal
            this.color = "#090909"
            this.ringColor = '#09090966'


            if(this.agent.bee == 1){
                if (this.agent.beeworker == 1) {
                    if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                        if (this.agent.dying <= 0) {
                            this.image = beeworkerimg
                        } else {
                            this.image = beeworkerdeathimg
                        }
                    } else {
                        if (this.agent.dying <= 0) {
                            this.image = beeworkerimg
                        } else {
                            this.image = beeworkerdeathimg
                        }
                    }
                } 
                if (this.agent.beescout == 1) {
                    if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                        if (this.agent.dying <= 0) {
                            this.image = beescoutimg
                        } else {
                            this.image = beescoutdeathimg
                        }
                    } else {
                        if (this.agent.dying <= 0) {
                            this.image = beescoutimg
                        } else {
                            this.image = beescoutdeathimg
                        }
                    }
                } 
                if (this.agent.beesoldier == 1) {
                    if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                        if (this.agent.dying <= 0) {
                            this.image = beesoldierimg
                        } else {
                            this.image = beesoldierdeathimg
                        }
                    } else {
                        if (this.agent.dying <= 0) {
                            this.image = beesoldierimg
                        } else {
                            this.image = beesoldierdeathimg
                        }
                    }
                } 
                if (this.agent.beemega == 1) {
                    if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                        if (this.agent.dying <= 0) {
                            this.image = beemegaimg
                        } else {
                            this.image = beemegadeathimg
                        }
                    } else {
                        if (this.agent.dying <= 0) {
                            this.image = beemegaimg
                        } else {
                            this.image = beemegadeathimg
                        }
                    }
                } 
            }else if (this.agent.gogo == 1) {

                if (this.agent.gogonaut == 1) {

                    if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                        if (this.agent.dying <= 0) {
                            this.image = gogonaut
                        } else {

                            this.image = gogonautdeath
                        }
                    } else {

                        if (this.agent.dying <= 0) {
                            this.image = gogonautinv

                        } else {

                            this.image = gogonautdeathinv
                        }
                    }
                } else if (this.agent.gogonautdefender == 1) {
                    if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                        if (this.agent.dying <= 0) {
                            this.image = gogonautdefender
                        } else {

                            this.image = gogonautdefenderdeath
                        }
                    } else {
                        if (this.agent.dying <= 0) {
                            this.image = gogonautdefenderinv
                        } else {
                            this.image = gogonautdefenderdeathinv
                        }
                    }
                } else if (this.agent.gogonautchampion == 1) {
                    if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                        if (this.agent.dying <= 0) {
                            this.image = gogonautchampion
                        } else {
                            this.image = gogonautchampiondeath
                        }
                    } else {
                        if (this.agent.dying <= 0) {
                            this.image = gogonautchampioninv
                        } else {
                            this.image = gogonautchampiondeathinv
                        }

                    }
                } else if (this.agent.gogonautteam == 1) {
                    if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                        if (this.agent.dying <= 0) {
                            this.image = gogonautteam
                        } else {
                            this.image = gogonautteamdeath
                        }
                    } else {
                        if (this.agent.dying <= 0) {
                            this.image = gogonautteaminv
                        } else {
                            this.image = gogonautteamdeathinv
                        }
                    }
                }
            } else if (this.agent.ave == 1) {
                if (this.agent.flugoon == 1) {

                    if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                        if (this.agent.dying <= 0) {
                            this.image = flugoon
                        } else {

                            this.image = flugoondeath
                        }
                    } else {

                        if (this.agent.dying <= 0) {
                            this.image = flugooninv

                        } else {

                            this.image = flugoondeathinv
                        }
                    }
                } else if (this.agent.buzzlet == 1) {
                    if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                        if (this.agent.dying <= 0) {
                            this.image = buzzlet
                        } else {

                            this.image = buzzletdeath
                        }
                    } else {
                        if (this.agent.dying <= 0) {
                            this.image = buzzletinv
                        } else {
                            this.image = buzzletdeathinv
                        }
                    }
                } else if (this.agent.starbatross == 1) {
                    if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                        if (this.agent.dying <= 0) {
                            this.image = starbatross
                        } else {
                            this.image = starbatrossdeath
                        }
                    } else {
                        if (this.agent.dying <= 0) {
                            this.image = starbatrossinv
                        } else {
                            this.image = starbatrossdeathinv
                        }

                    }
                } else if (this.agent.megagnat == 1) {
                    if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                        if (this.agent.dying <= 0) {
                            this.image = megagnat
                        } else {
                            this.image = megagnatdeath
                        }
                    } else {
                        if (this.agent.dying <= 0) {
                            this.image = megagnatinv
                        } else {
                            this.image = megagnatdeathinv
                        }
                    }
                }
            } else if (this.agent.alagadile == 1) {
                if (this.agent.bigalagadile == 1) {

                    if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                        if (this.agent.dying <= 0) {
                            this.image = bigalagadile
                        } else {

                            this.image = bigalagadiledeath
                        }
                    } else {

                        if (this.agent.dying <= 0) {
                            this.image = bigalagadileinv

                        } else {

                            this.image = bigalagadiledeathinv
                        }
                    }
                } else if (this.agent.babyalagadile == 1) {
                    if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                        if (this.agent.dying <= 0) {
                            this.image = alagadile
                        } else {

                            this.image = alagadiledeath
                        }
                    } else {
                        if (this.agent.dying <= 0) {
                            this.image = alagadileinv
                        } else {
                            this.image = alagadiledeathinv
                        }
                    }
                } else if (this.agent.hunchalagadile == 1) {
                    if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                        if (this.agent.dying <= 0) {
                            this.image = hunchalagadile
                        } else {
                            this.image = hunchalagadiledeath
                        }
                    } else {
                        if (this.agent.dying <= 0) {
                            this.image = hunchalagadileinv
                        } else {
                            this.image = hunchalagadiledeathinv
                        }

                    }
                } else if (this.agent.bighunchalagadile == 1) {
                    if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                        if (this.agent.dying <= 0) {
                            this.image = bighunchalagadile
                        } else {
                            this.image = bighunchalagadiledeath
                        }
                    } else {
                        if (this.agent.dying <= 0) {
                            this.image = bighunchalagadileinv
                        } else {
                            this.image = bighunchalagadiledeathinv
                        }
                    }
                }
            } else {
                if (this.agent.targetroid == 1) {
                    if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                        this.image = targetroidimg
                    } else {
                        this.image = targetroidimginv
                    }
                } else if (this.agent.hamartanscout == 1 || this.agent.hamartansoldier == 1 || this.agent.hamartaninvader == 1 || this.agent.hamartanworker == 1) {
                    if (this.agent.dying <= 0) {

                        if (this.agent.hamartanscout == 1) {
                            if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                                this.image = hamartanscout
                            } else {
                                this.image = hamartanscoutinv

                            }
                        } else if (this.agent.hamartansoldier == 1) {

                            if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                                this.image = hamartansoldier
                            } else {
                                this.image = hamartansoldierinv

                            }
                        } else if (this.agent.hamartaninvader == 1) {

                            if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                                this.image = hamartaninvader
                            } else {
                                this.image = hamartaninvaderinv

                            }
                        } else if (this.agent.hamartanworker == 1) {
                            if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                                this.image = hamartanworker
                            } else {
                                this.image = hamartanworkerinv

                            }
                        }
                    } else {
                        this.image = hamartandeath
                    }
                } else if (this.agent.drone == 1) {
                    if (this.agent.dying <= 0) {
                        if (this.agent.super == 1) {
                            this.image = superdrone
                        } else {
                            if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                                this.image = drone
                            } else {
                                this.image = droneinv

                            }
                        }
                    } else {
                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                            this.image = dronedeath
                        } else {
                            this.image = dronedeathinv

                        }
                    }
                } else if (this.agent.infantry == 1) {

                    if (this.agent.dying <= 0) {
                        if (this.agent.super == 1) {
                            this.image = superinfantry
                        } else {
                            if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                                this.image = infantry
                            } else {
                                this.image = infantryinv

                            }
                        }
                    } else {

                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                            this.image = infantrydeath
                        } else {
                            this.image = infantrydeathinv

                        }
                    }
                } else if (this.agent.infantry == 2) {
                    if (this.agent.dying <= 0) {
                        if (this.agent.super == 1) {
                            this.image = supersniper1
                        } else {
                            if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                                this.image = sniper1
                            } else {

                                this.image = sniper1inv
                            }

                        }
                    } else {

                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                            this.image = sniper1death
                        } else {
                            this.image = sniper1deathinv

                        }

                    }
                } else if (this.agent.harvester == 1) {
                    if (this.agent.dying <= 0) {
                        if (this.agent.super == 1) {
                            this.image = superharvester
                        } else {
                            if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                                this.image = harvester
                            } else {
                                this.image = harvesterinv

                            }

                        }
                    } else {
                        this.image = harvesterdeath

                    }
                } else if (this.agent.nymph == 1) {
                    if (this.agent.dying <= 0) {
                        if (this.agent.sana == 1) {
                            this.image = nymphsana
                        } else {
                            if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                                this.image = nymph
                            } else {
                                this.image = nymphinv
                            }
                        }
                    } else {

                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                            this.image = nymphdeath
                        } else {

                            this.image = nymphdeathinv
                        }

                    }
                } else if (this.agent.nymph == 2) {
                    if (this.agent.dying <= 0) {
                        if (this.agent.sana == 1) {
                            this.image = scuttlersana
                        } else {
                            if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                                this.image = scuttler
                            } else {
                                this.image = scuttlerinv

                            }
                        }
                    } else {

                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                            this.image = scuttlerdeathimg
                        } else {

                            this.image = scuttlerdeathimginv
                        }

                    }
                } else if (this.agent.gamergate == 1) {

                    if (this.agent.dying >= 1) {

                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                            this.image = gamergatedeath
                        } else {

                            this.image = gamergatedeathinv
                        }
                    } else {

                        if (this.agent.submerged == 0) {

                            if (this.agent.sana == 1) {
                                this.image = gamergatesana
                            } else {
                                if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                                    this.image = gamergate
                                } else {
                                    this.image = gamergateinv
                                }
                            }
                        } else {
                            if (sandmap.players[sandmap.turn] == this.agent.faction) {

                                if (this.agent.sana == 1) {
                                    this.image = gamergatedugsana
                                } else {
                                    if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                                        this.image = gamergatedug
                                    } else {
                                        this.image = gamergateduginv
                                    }
                                }
                            } else {
                                let wet = 0//0

                                for(let d = 1;d<sandmap.players.length;d++){
                                const indexer = Math.abs((sandmap.players.indexOf(this.agent.faction) + d)%sandmap.players.length)
                                for (let k = 0; k < sandmap.players[indexer].units.length; k++) {
                                    if (sandmap.players[indexer].units[k].drone == 1 || sandmap.players[indexer].units[k].imago == 2 || sandmap.players[indexer].units[k].hamartanscout == 1 || sandmap.players[indexer].units[k].pufffellow == 1 || sandmap.players[indexer].units[k].sporevizir == 1) {
                                        if (this.agent.gameline.target == sandmap.players[indexer].units[k].body) {
                                            if (this.agent.gameline.hypotenuse() <= sandmap.players[indexer].units[k].sight) {
                                                wet = 1
                                                break
                                            }
                                        } else {
                                            this.agent.gameline.target = sandmap.players[indexer].units[k].body
                                            if (this.agent.gameline.hypotenuse() <= sandmap.players[indexer].units[k].sight) {
                                                wet = 1
                                                break
                                            }
                                        }
                                    }
                                }
                                if (wet == 1) {
                                    if (this.agent.sana == 1) {
                                        this.image = gamergatedugsana
                                    } else {
                                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                                            this.image = gamergatedug
                                        } else {
                                            this.image = gamergateduginv

                                        }
                                    }
                                }


                            }

                            }
                        }
                    }
                } else if (this.agent.imago == 1) {

                    if (this.agent.dying <= 0) {
                        if (this.agent.sana == 1) {
                            this.image = imagosana
                        } else {

                            if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                                this.image = imago
                            } else {

                                this.image = imagoinv
                            }
                        }
                    } else {

                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                            this.image = imagodeath
                        } else {

                            this.image = imagodeathinv
                        }
                    }
                } else if (this.agent.pollinator == 1) {
                    if (this.agent.dying <= 0) {
                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                            this.image = librilbianpollinator
                        } else {
                            this.image = librilbianpollinatorinv
                        }
                    } else {
                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                            this.image = librilbianpollinatordeath

                        } else {
                            this.image = librilbianpollinatordeathinv

                        }
                    }
                } else if (this.agent.goliophyte == 1) {
                    if (this.agent.dying <= 0) {
                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                            this.image = librilbiangoliophyte
                        } else {
                            this.image = librilbiangoliophyteinv
                        }
                    } else {

                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                            this.image = librilbiangoliophytedeath

                        } else {
                            this.image = librilbiangoliophytedeathinv

                        }
                    }
                } else if (this.agent.pufffellow == 1) {
                    if (this.agent.dying <= 0) {
                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                            this.image = librilbianpufffellow
                        } else {
                            this.image = librilbianpufffellowinv
                        }
                    } else {

                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                            this.image = librilbianpufffellowdeath

                        } else {
                            this.image = librilbianpufffellowdeathinv

                        }

                    }
                } else if (this.agent.podman == 1) {
                    if (this.agent.dying <= 0) {
                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                            this.image = librilbianpodman
                        } else {
                            this.image = librilbianpodmaninv
                        }
                    } else {


                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                            this.image = librilbianpodmandeath

                        } else {
                            this.image = librilbianpodmandeathinv

                        }
                    }
                } else if (this.agent.fruiting == 1) {
                    if (this.agent.dying <= 0) {
                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                            this.image = fruitingbuddy
                        } else {
                            this.image = fruitingbuddyinv
                        }
                    } else {

                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                            this.image = fruitingbuddydeath
                        } else {
                            this.image = fruitingbuddydeathinv
                        }
                    }
                } else if (this.agent.mycoknight == 1) {

                    if (this.agent.dying <= 0) {
                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                            this.image = mycoknight
                        } else {
                            this.image = mycoknightinv

                        }
                    } else {

                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                            this.image = mycoknightdeath
                        } else {
                            this.image = mycoknightdeathinv

                        }
                    }
                } else if (this.agent.sporevizir == 1) {

                    if (this.agent.dying <= 0) {
                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                            this.image = sporevizir
                        } else {
                            this.image = sporevizirinv

                        }
                    } else {
                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                            this.image = sporevizirdeath

                        } else {
                            this.image = sporevizirdeathinv


                        }

                    }
                } else if (this.agent.seer == 1) {

                    if (this.agent.dying <= 0) {
                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                            this.image = sporeseer
                        } else {
                            this.image = sporeseerinv

                        }
                    } else {
                        if (sandmap.players.indexOf(this.agent.faction) == sandmap.turn) {
                            this.image = sporeseerdeath
                        } else {
                            this.image = sporeseerdeathinv
                        }


                    }
                } else {
                }
            }




            canvas_context.fillStyle = this.color
            canvas_context.strokeStyle = this.ringColor
            canvas_context.lineWidth = (cal * .08)
            canvas_context.strokeRect(this.x, this.y, this.width, this.height)
            canvas_context.fillRect(this.x, this.y, this.width, this.height)

            if (this.agent.dying >= 1) {
                canvas_context.drawImage(this.image, (this.agent.dying - 1) * 10, 0, 10, 10, this.x + (cal * .1), this.y + (cal * .1), cal * .8, cal * .8)
            } else {
                canvas_context.drawImage(this.image, 0, 0, 10, 10, this.x + (cal * .1), this.y + (cal * .1), cal * .8, cal * .8)
            }


            this.healthbar = new UiRectangle(this.x + (this.width * 0), this.y + (cal * .9), 11, 5, "transparent")
            this.healthbar.draw()
            if (this.agent.health / this.agent.maxhealth > .5) {
                this.healthbar = new UiRectangle(this.x + (this.width * 0), this.y + (cal * .9), (this.agent.health / this.agent.maxhealth) * (this.width * 1), (cal * .1), `rgb(${(1 - ((this.agent.health / this.agent.maxhealth))) * 512},${255},  0)`)
            } else {
                this.healthbar = new UiRectangle(this.x + (this.width * 0), this.y + (cal * .9), (this.agent.health / this.agent.maxhealth) * (this.width * 1), (cal * .1), `rgb(${255},${(((this.agent.health / this.agent.maxhealth) * 1)) * 512},  0)`)
            }
            this.healthbar.draw()


        }
    }


    let playercolors = ["#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white", "#999999", "white"]
    let playercolorscount = 0
    class Player {
        constructor(name, color, ai, type, data = 0) {
            this.enemyBullets = []
            this.createdCount = 0
            this.sendBuildings = 1
            if(data == 0){
                   this.idtable = []

            this.controlGroups = [[], [], [], [], [], [], [], [], [], []]
            this.secondColor = playercolors[playercolorscount]
            playercolorscount++
            this.justcapped = {}
            this.justcapped.tk = -1
            this.nymphstop = 0
            this.id = Math.random()
            this.campaignThrottle = 0
            this.collectiveStrain = 0
            this.counterUI = 0
            this.Mflag = 0
            this.Nflag = 0
            this.Bflag = 0
            this.Gflag = 0
            this.surf = 0
            this.slimeflag = 0
            this.attacktimeout = 0
            this.blocks = []
            this.seen = []
            this.seenrocks = []
            this.fog = []
            this.name = name
            this.selected_tile = {}
            this.color = color
            this.buildings = []
            this.units = []
            this.hotrock = 250
            this.isAI = ai
            this.type = type
            this.chunk = 0
            this.clickrate = 400//1//1 // 2 // 10 //2 //400
            this.aimode = 0
            this.racksflag = 5
            this.racks = 0
            this.lab = 0
            this.averageSpace = {}
            this.baseMoveFlag = 0
            this.defending = 0
            this.income = 0
            this.canvas = document.createElement('canvas');
            this.canvas.width = worldscale
            this.canvas.height = worldscale
            this.context = this.canvas.getContext('2d');
            this.canvas2 = document.createElement('canvas');
            this.canvas2.width = worldscale
            this.canvas2.height = worldscale
            this.context2 = this.canvas.getContext('2d');
            this.canvasx = document.createElement('canvas');
            this.canvasx.width = worldscale
            this.canvasx.height = worldscale
            this.contextx = this.canvasx.getContext('2d');
            this.canvas2x = document.createElement('canvas');
            this.canvas2x.width = worldscale
            this.canvas2x.height = worldscale
            this.context2x = this.canvas2x.getContext('2d');


            this.contextx.drawImage(fogblockx, 0, 0, 128, 128, 0, 0, worldscale, worldscale)
            this.tick = 0
            this.inned = 0
            this.playerUI = new GlobalUI(this)
            this.commandPanel = new PlayerCommands(this)
            }else{
                   this.idtable = []

            this.controlGroups = [[], [], [], [], [], [], [], [], [], []]
            this.secondColor = playercolors[playercolorscount]
            playercolorscount++
            this.justcapped = {}
            this.justcapped.tk = -1
            this.nymphstop = 0
            this.id = Math.random()
            this.campaignThrottle = 0
            this.collectiveStrain = 0
            this.counterUI = 0
            this.Mflag = 0
            this.Nflag = 0
            this.Bflag = 0
            this.Gflag = 0
            this.surf = 0
            this.slimeflag = 0
            this.attacktimeout = 0
            this.blocks = []
            this.seen = []
            this.seenrocks = []
            this.fog = []
            this.name = name
            this.selected_tile = {}
            this.color = color
            this.buildings = []
            this.units = []
            this.hotrock = 250
            this.isAI = 0//ai
            this.type = type
            this.chunk = 0
            this.clickrate = 400//1//1 // 2 // 10 //2 //400
            this.aimode = 0
            this.racksflag = 5
            this.racks = 0
            this.lab = 0
            this.averageSpace = {}
            this.baseMoveFlag = 0
            this.defending = 0
            this.income = 0
            this.canvas = document.createElement('canvas');
            this.canvas.width = worldscale
            this.canvas.height = worldscale
            this.context = this.canvas.getContext('2d');
            this.canvas2 = document.createElement('canvas');
            this.canvas2.width = worldscale
            this.canvas2.height = worldscale
            this.context2 = this.canvas.getContext('2d');
            this.canvasx = document.createElement('canvas');
            this.canvasx.width = worldscale
            this.canvasx.height = worldscale
            this.contextx = this.canvasx.getContext('2d');
            this.canvas2x = document.createElement('canvas');
            this.canvas2x.width = worldscale
            this.canvas2x.height = worldscale
            this.context2x = this.canvas2x.getContext('2d');


            this.contextx.drawImage(fogblockx, 0, 0, 128, 128, 0, 0, worldscale, worldscale)
            this.tick = 0
            this.inned = 0
            this.playerUI = new GlobalUI(this)
            this.commandPanel = new PlayerCommands(this)


            for(let t = 0;t<data.length;t++){
                if(data[t].d > 0){
                    //////////console.log(data[t], "base")
                    
                    let id =  data[t].d%1  //Math.floor((data[t]%1)*1000)/1000
                    //////////console.log(id, "id")
                    data[t].d = Math.floor(data[t].d)
                    //////////console.log(data[t], "after")
                    let background = invert_cantor(data[t].d)
                    let backgroundtk = invert_cantor(background.x)
                    let backgroundval = invert_cantor(background.y)
                    let standee = new Agent(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn-1)])
                    //////////console.log(backgroundtk, backgroundval)
                    //////////console.log(standee, "base")
                    backgroundval.type = backgroundtk.y


                                if( backgroundval.type == 1){
                                    standee.isNymph()
                                }else if( backgroundval.type == 2){
                                    standee.isNymph()
                                    standee.finishMorph1()
                                }else if( backgroundval.type == 3){
                                    standee.isNymph()
                                    standee.finishMorph1()
                                    standee.finishMorph2()
                                }else if( backgroundval.type == 4){
                                    standee.isNymph()
                                    standee.finishMorph1()
                                    standee.finishMorphgamergate()
                                }else if( backgroundval.type == 5){
                                    standee.isFruitingBuddy()
                                }else if( backgroundval.type == 6){
                                    standee.isMycoknight()
                                }else if( backgroundval.type == 7){
                                    standee.isSporeseer()
                                }else if( backgroundval.type == 8){
                                    standee.isSporevizir()
                                }else if( backgroundval.type == 9){
                                    standee.isInfantry()
                                }else if( backgroundval.type == 10){
                                    standee.isSniper()
                                }else if( backgroundval.type == 11){
                                    standee.isHarvester()
                                }else if( backgroundval.type == 12){
                                    standee.isScout()
                                }else if( backgroundval.type == 13){
                                    standee.isHamartanscout()
                                }else if( backgroundval.type == 14){
                                    standee.isHamartanworker()
                                }else if( backgroundval.type == 15){
                                    standee.isHamartaninvader()
                                }else if( backgroundval.type == 16){
                                    standee.isHamartansoldier()
                                }else if( backgroundval.type == 17){
                                    standee.isPollinator()
                                }else if( backgroundval.type == 18){
                                    standee.isGoliophyte()
                                }else if( backgroundval.type == 19){
                                    standee.isPufffellow()
                                }else if( backgroundval.type == 20){
                                    standee.isPodman()
                                }else if( backgroundval.type == 21){
                                    standee.isBuzzlet()
                                }else if( backgroundval.type == 22){
                                    standee.isFlugoon()
                                }else if( backgroundval.type == 23){
                                    standee.isStarbatross()
                                }else if( backgroundval.type == 24){
                                    standee.isMegagnat()
                                }else if( backgroundval.type == 25){
                                    standee.isAlagadile()
                                }else if( backgroundval.type == 26){
                                    standee.isBigAlagadile()
                                }else if( backgroundval.type == 27){
                                    standee.isBigHunchAlagadile()
                                }else if( backgroundval.type == 28){
                                    standee.isHunchAlagadile()
                                }else if( backgroundval.type == 29){
                                    standee.isGogonaut()
                                }else if( backgroundval.type == 30){
                                    standee.isGogonautDefender()
                                }else if( backgroundval.type == 31){
                                    standee.isGogonautChampion()
                                }else if( backgroundval.type == 32){
                                    standee.isGogonautTeam()
                                }else if( backgroundval.type == 33){
                                    standee.isBeeWorker()
                                }else if( backgroundval.type == 34){
                                    standee.isBeeScout()
                                }else if( backgroundval.type == 35){
                                    standee.isBeeSoldier()
                                }else if( backgroundval.type == 36){
                                    standee.isBeeMega()
                                }else if( backgroundval.type == 37){
                                    standee.isTargetroid()
                                }else if( backgroundval.type == 38){
                                    standee.isSchlorkupine()
                                }


                    standee.health = backgroundtk.x
                    standee.id = id
                    //////////console.log(standee)
                    // //////////console.log(background)
                    if(backgroundval.type > 38){
                     if(backgroundval.type == 39){
                        // standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn-1)], 0 1, 0)
                    }else if(backgroundval.type == 40){
                        // standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn-1)],0, 0, 50)
                        standee.isBarracks()
                    }else if(backgroundval.type == 41){
                        // standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn-1)],0, 0, 50)
                        standee.isMachineLab()
                    }else if(backgroundval.type == 42){
                        // standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn-1)],0, 0, 50)
                        standee.isGate()
                    }else if(backgroundval.type == 43){
                        standee.isSlime()
                    }else if(backgroundval.type == 44){
                        standee.isSporeball()
                    }else if(backgroundval.type == 45){
                        standee.isSpire()
                    }else  if(backgroundval.type == 46){
                        // standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn-1)],0, 0, 50)
                        standee.isSoldierAssembler()
                    }else if(backgroundval.type == 47){
                        // standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn-1)],0, 0, 50)
                        standee.isScoutAssembler()
                    }else if(backgroundval.type == 48){
                        // standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn-1)],0, 0, 50)
                        standee.isHighCasteAssembler()
                    }else if(backgroundval.type == 49){
                        standee.isBulbplant()
                    }else if(backgroundval.type == 50){
                        standee.isPodmother()
                    }else if(backgroundval.type == 51){
                        standee.isEggmound()
                    }else if(backgroundval.type == 52){
                        standee.isEgg()
                    }else if(backgroundval.type == 53){
                        standee.isPond()
                    }else if(backgroundval.type == 54){
                        standee.isTree()
                    }else if(backgroundval.type == 55){
                        standee.isBeehive()
                    }
                                
                    
                    standee.id = id
                    if(!this.idtable.includes(id)){

                    this.buildings.push(standee)
                    this.idtable.push(standee.id)
                    }
                    }else{
                    if(!this.idtable.includes(id)){
                    this.units.push(standee)
                    this.idtable.push(standee.id)
                    }
                    }
                    //////////console.log(standee, "after")
                }
            }

            
            }
        }
    unitize(data, player){
    // this.units = []
    this.idtable = []

    for (let t = 0; t < this.units.length; t++) {
        this.idtable.push(this.units[t].id)
        this.units[t].decay--
        if (this.units[t].decay < 0) {
            this.units[t].health = -3
        }
    }
    for (let t = 0; t < this.buildings.length; t++) {
        this.idtable.push(this.buildings[t].id)
        // this.buildings[t].decay--
        if (this.buildings[t].decay < 0) {
            this.buildings[t].health = -3
        }
    }


    for (let t = 0; t < data.length; t++) {
        if (data[t].d != 0) {
            //////////console.log(data[t].w)
            if (data[t].d <= -1) {
                data[t].d = Math.abs(data[t].d)
                if(Math.floor(data[t].w) > 0){
                    continue
                }
                let id = data[t].w%1
                data[t].d = Math.floor(data[t].d)
                let background = invert_cantor(data[t].d)
                let backgroundtk = invert_cantor(background.x)
                let backgroundval = invert_cantor(background.y)
                backgroundval.type = backgroundtk.y
                let standee
                //////////console.log(backgroundval)
                if ((this.units.length)+this.buildings.length > t) {



                    //////////console.log(backgroundtk, backgroundval, background)
                    if (backgroundval.type > 0) {
                        //////////console.log("b")
                        if (backgroundval.type == -38+39) {
                    this.buildings[t-this.units.length].totalBlank(sandmap.blocks[Math.min(Math.max(backgroundval.x, 0), worldscale)][Math.min(Math.max(backgroundval.y, 0), worldscale)], 0, player)
                    standee = this.buildings[t-this.units.length]
                    standee.isWall(sandmap.blocks[backgroundval.x][backgroundval.y])
                        //  standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn - 1)], 0,1,0)
                        } else if (backgroundval.type == -38+40) {
                    this.buildings[t-this.units.length].totalBlank(sandmap.blocks[Math.min(Math.max(backgroundval.x, 0), worldscale)][Math.min(Math.max(backgroundval.y, 0), worldscale)], 1, player)
                    standee = this.buildings[t-this.units.length]
                        //  standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn - 1)], 0,0,0)
                            standee.isBarracks(sandmap.blocks[backgroundval.x][backgroundval.y])
                        } else if (backgroundval.type == -38+41) {
                    this.buildings[t-this.units.length].totalBlank(sandmap.blocks[Math.min(Math.max(backgroundval.x, 0), worldscale)][Math.min(Math.max(backgroundval.y, 0), worldscale)], 1, player)
                    standee = this.buildings[t-this.units.length]
                        //  standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn - 1)], 0,0,0)
                            standee.isMachineLab(sandmap.blocks[backgroundval.x][backgroundval.y])
                        } else if (backgroundval.type == -38+42) {
                    this.buildings[t-this.units.length].totalBlank(sandmap.blocks[Math.min(Math.max(backgroundval.x, 0), worldscale)][Math.min(Math.max(backgroundval.y, 0), worldscale)], 1, player)
                    standee = this.buildings[t-this.units.length]
                        //  standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn - 1)], 0,0,0)
                            standee.isGate(sandmap.blocks[backgroundval.x][backgroundval.y])
                        } else if (backgroundval.type == -38+43) {
                    this.buildings[t-this.units.length].totalBlank(sandmap.blocks[Math.min(Math.max(backgroundval.x, 0), worldscale)][Math.min(Math.max(backgroundval.y, 0), worldscale)], 0, player)
                    standee = this.buildings[t-this.units.length]
                        //  standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn - 1)], 0,1,0)
                            standee.isSlime(sandmap.blocks[backgroundval.x][backgroundval.y])
                        } else if (backgroundval.type == -38+44) {
                    this.buildings[t-this.units.length].totalBlank(sandmap.blocks[Math.min(Math.max(backgroundval.x, 0), worldscale)][Math.min(Math.max(backgroundval.y, 0), worldscale)], 0, player)
                    standee = this.buildings[t-this.units.length]
                        //  standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn - 1)], 0,1,0)
                            standee.isSporeball(sandmap.blocks[backgroundval.x][backgroundval.y])
                        } else if (backgroundval.type == -38+45) {
                        //  standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn - 1)], 0,1,0)
                    this.buildings[t-this.units.length].totalBlank(sandmap.blocks[Math.min(Math.max(backgroundval.x, 0), worldscale)][Math.min(Math.max(backgroundval.y, 0), worldscale)], 0, player)
                    standee = this.buildings[t-this.units.length]
                            standee.isSpire(sandmap.blocks[backgroundval.x][backgroundval.y])
                        } else if (backgroundval.type == -38+46) {
                    this.buildings[t-this.units.length].totalBlank(sandmap.blocks[Math.min(Math.max(backgroundval.x, 0), worldscale)][Math.min(Math.max(backgroundval.y, 0), worldscale)], 1, player)
                    standee = this.buildings[t-this.units.length]
                        //  standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn - 1)], 0,0,0)
                            standee.isSoldierAssembler(sandmap.blocks[backgroundval.x][backgroundval.y])
                        } else if (backgroundval.type == -38+47) {
                    this.buildings[t-this.units.length].totalBlank(sandmap.blocks[Math.min(Math.max(backgroundval.x, 0), worldscale)][Math.min(Math.max(backgroundval.y, 0), worldscale)], 1, player)
                    standee = this.buildings[t-this.units.length]
                        //  standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn - 1)], 0,0,0)
                            standee.isScoutAssembler(sandmap.blocks[backgroundval.x][backgroundval.y])
                        } else if (backgroundval.type == -38+48) {
                    this.buildings[t-this.units.length].totalBlank(sandmap.blocks[Math.min(Math.max(backgroundval.x, 0), worldscale)][Math.min(Math.max(backgroundval.y, 0), worldscale)], 1, player)
                    standee = this.buildings[t-this.units.length]
                        //  standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn - 1)], 0,0,0)
                            standee.isHighCasteAssembler(sandmap.blocks[backgroundval.x][backgroundval.y])
                        } else if (backgroundval.type == -38+49) {
                    this.buildings[t-this.units.length].totalBlank(sandmap.blocks[Math.min(Math.max(backgroundval.x, 0), worldscale)][Math.min(Math.max(backgroundval.y, 0), worldscale)], 0, player)
                    standee = this.buildings[t-this.units.length]
                        //  standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn - 1)], 0,1,0)
                            standee.isBulbplant(sandmap.blocks[backgroundval.x][backgroundval.y])
                        } else if (backgroundval.type == -38+50) {
                    this.buildings[t-this.units.length].totalBlank(sandmap.blocks[Math.min(Math.max(backgroundval.x, 0), worldscale)][Math.min(Math.max(backgroundval.y, 0), worldscale)], 1, player)
                    standee = this.buildings[t-this.units.length]
                        //  standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn - 1)], 0,0,0)
                            standee.isPodmother(sandmap.blocks[backgroundval.x][backgroundval.y])
                        } else if (backgroundval.type == -38+51) {
                    this.buildings[t-this.units.length].totalBlank(sandmap.blocks[Math.min(Math.max(backgroundval.x, 0), worldscale)][Math.min(Math.max(backgroundval.y, 0), worldscale)], 0, player)
                    standee = this.buildings[t-this.units.length]
                        //  standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn - 1)], 0,1,0)
                            standee.isEggmound(sandmap.blocks[backgroundval.x][backgroundval.y])
                        } else if (backgroundval.type == -38+52) {
                    this.buildings[t-this.units.length].totalBlank(sandmap.blocks[Math.min(Math.max(backgroundval.x, 0), worldscale)][Math.min(Math.max(backgroundval.y, 0), worldscale)], 0, player)
                    standee = this.buildings[t-this.units.length]
                        //  standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn - 1)], 0,1,0)
                            standee.isEgg(sandmap.blocks[backgroundval.x][backgroundval.y])
                        } else if (backgroundval.type == -38+53) {
                    this.buildings[t-this.units.length].totalBlank(sandmap.blocks[Math.min(Math.max(backgroundval.x, 0), worldscale)][Math.min(Math.max(backgroundval.y, 0), worldscale)], 1, player)
                    standee = this.buildings[t-this.units.length]
                        //  standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn - 1)], 0,0,0)
                            standee.isPond(sandmap.blocks[backgroundval.x][backgroundval.y])
                        } else if (backgroundval.type == -38+54) {
                    this.buildings[t-this.units.length].totalBlank(sandmap.blocks[Math.min(Math.max(backgroundval.x, 0), worldscale)][Math.min(Math.max(backgroundval.y, 0), worldscale)], 1, player)
                    standee = this.buildings[t-this.units.length]
                        //  standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn - 1)], 0,0,0)
                            standee.isTree(sandmap.blocks[backgroundval.x][backgroundval.y])
                        } else if (backgroundval.type == -38+55) {
                    this.buildings[t-this.units.length].totalBlank(sandmap.blocks[Math.min(Math.max(backgroundval.x, 0), worldscale)][Math.min(Math.max(backgroundval.y, 0), worldscale)], 1, player)
                    standee = this.buildings[t-this.units.length]
                        //  standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn - 1)], 0,0,0)
                            standee.isBeehive(sandmap.blocks[backgroundval.x][backgroundval.y])
                        }else if (backgroundval.type == -38+56) {
                    this.buildings[t-this.units.length].totalBlank(sandmap.blocks[Math.min(Math.max(backgroundval.x, 0), worldscale)][Math.min(Math.max(backgroundval.y, 0), worldscale)], 0, player)
                    standee = this.buildings[t-this.units.length]
                        //  standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn - 1)], 0,0,0)
                            standee.isTeleporter(sandmap.blocks[backgroundval.x][backgroundval.y])
                        }
                    }

                } else {
                    // standee = new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[Math.abs(sandmap.turn - 1)], 0,1,0)



                //////////console.log(backgroundtk, backgroundval, background)
                if (backgroundval.type > 0) {
                    //////////console.log("b")
                    if (backgroundval.type == -38+39) {
                  standee= new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[player], 0,1,0)
                  standee.isWall(sandmap.blocks[backgroundval.x][backgroundval.y])
                    } else if (backgroundval.type == -38+40) {
                  standee= new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[player], 0,0,0)
                        standee.isBarracks(sandmap.blocks[backgroundval.x][backgroundval.y])
                    } else if (backgroundval.type == -38+41) {
                  standee= new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[player], 0,0,0)
                        standee.isMachineLab(sandmap.blocks[backgroundval.x][backgroundval.y])
                    } else if (backgroundval.type == -38+42) {
                  standee= new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[player], 0,0,0)
                        standee.isGate(sandmap.blocks[backgroundval.x][backgroundval.y])
                    } else if (backgroundval.type == -38+43) {
                  standee= new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[player], 0,1,0)
                        standee.isSlime(sandmap.blocks[backgroundval.x][backgroundval.y])
                    } else if (backgroundval.type == -38+44) {
                  standee= new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[player], 0,1,0)
                        standee.isSporeball(sandmap.blocks[backgroundval.x][backgroundval.y])
                    } else if (backgroundval.type == -38+45) {
                  standee= new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[player], 0,1,0)
                        standee.isSpire(sandmap.blocks[backgroundval.x][backgroundval.y])
                    } else if (backgroundval.type == -38+46) {
                  standee= new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[player], 0,0,0)
                        standee.isSoldierAssembler(sandmap.blocks[backgroundval.x][backgroundval.y])
                    } else if (backgroundval.type == -38+47) {
                  standee= new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[player], 0,0,0)
                        standee.isScoutAssembler(sandmap.blocks[backgroundval.x][backgroundval.y])
                    } else if (backgroundval.type == -38+48) {
                  standee= new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[player], 0,0,0)
                        standee.isHighCasteAssembler(sandmap.blocks[backgroundval.x][backgroundval.y])
                    } else if (backgroundval.type == -38+49) {
                  standee= new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[player], 0,1,0)
                        standee.isBulbplant(sandmap.blocks[backgroundval.x][backgroundval.y])
                    } else if (backgroundval.type == -38+50) {
                  standee= new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[player], 0,0,0)
                        standee.isPodmother(sandmap.blocks[backgroundval.x][backgroundval.y])
                    } else if (backgroundval.type == 13) {
                  standee= new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[player], 0,1,0)
                        standee.isEggmound(sandmap.blocks[backgroundval.x][backgroundval.y])
                    } else if (backgroundval.type == -38+52) {
                  standee= new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[player], 0,1,0)
                        standee.isEgg(sandmap.blocks[backgroundval.x][backgroundval.y])
                    } else if (backgroundval.type == -38+53) {
                  standee= new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[player], 0,0,0)
                        standee.isPond(sandmap.blocks[backgroundval.x][backgroundval.y])
                    } else if (backgroundval.type == -38+54) {
                  standee= new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[player], 0,0,0)
                        standee.isTree(sandmap.blocks[backgroundval.x][backgroundval.y])
                    } else if (backgroundval.type == -38+55) {
                  standee= new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[player], 0,0,0)
                        standee.isBeehive(sandmap.blocks[backgroundval.x][backgroundval.y])
                    }else if (backgroundval.type == -38+56) {
                  standee= new Building(sandmap.blocks[backgroundval.x][backgroundval.y], sandmap.players[player], 0,1,0)
                        standee.isTeleporter(sandmap.blocks[backgroundval.x][backgroundval.y])
                    }
                }

                    standee.decay = 32
                standee.health = backgroundtk.x 
                    standee.id = id
                    //////////console.log(id)
                    let wet = 0
                    for (let t = 0; t < this.buildings.length; t++) {
                        if (standee.id == this.buildings[t].id) {
                            wet = 1
                        }
                    }
                    if (wet == 0) {
                        this.buildings.push(standee)
                        this.idtable.push(standee.id)
                    }

                } 
            } else {

                //////////console.log(4)
                let id = data[t].d % 1
                data[t].d = Math.floor(data[t].d)
                let nextwalk = invert_cantor(data[t].w)
                let walkdying = invert_cantor(nextwalk.x)
                let proceed = invert_cantor(nextwalk.y)
                let background = invert_cantor(data[t].d)
                let backgroundtk = invert_cantor(background.x)
                let backgroundval = invert_cantor(background.y)
                let standee
                if (this.units.length > t) {
                    this.units[t].totalBlank(sandmap.blocks[Math.min(Math.max(backgroundval.x, 0), worldscale)][Math.min(Math.max(backgroundval.y, 0), worldscale)], player)
                    standee = this.units[t]
                } else {
                    standee = new Agent(sandmap.blocks[Math.min(Math.max(backgroundval.x, 0), worldscale)][Math.min(Math.max(backgroundval.y, 0), worldscale)], this)
                }
                backgroundval.type = backgroundtk.y
                if (backgroundval.type == 1) {
                    standee.isNymph()
                } else if (backgroundval.type == 2) {
                    standee.isNymph()
                    standee.finishMorph1()
                } else if (backgroundval.type == 3) {
                    standee.isNymph()
                    standee.finishMorph1()
                    standee.finishMorph2()
                } else if (backgroundval.type == 4) {
                    standee.isNymph()
                    standee.finishMorph1()
                    standee.finishMorphgamergate()
                } else if (backgroundval.type == 5) {
                    standee.isFruitingBuddy()
                } else if (backgroundval.type == 6) {
                    standee.isMycoknight()
                } else if (backgroundval.type == 7) {
                    standee.isSporeseer()
                } else if (backgroundval.type == 8) {
                    standee.isSporevizir()
                } else if (backgroundval.type == 9) {
                    standee.isInfantry()
                } else if (backgroundval.type == 10) {
                    standee.isSniper()
                } else if (backgroundval.type == 11) {
                    standee.isHarvester()
                } else if (backgroundval.type == 12) {
                    standee.isScout()
                } else if (backgroundval.type == 13) {
                    standee.isHamartanscout()
                } else if (backgroundval.type == 14) {
                    standee.isHamartanworker()
                } else if (backgroundval.type == 15) {
                    standee.isHamartaninvader()
                } else if (backgroundval.type == 16) {
                    standee.isHamartansoldier()
                } else if (backgroundval.type == 17) {
                    standee.isPollinator()
                } else if (backgroundval.type == 18) {
                    standee.isGoliophyte()
                } else if (backgroundval.type == 19) {
                    standee.isPufffellow()
                } else if (backgroundval.type == 20) {
                    standee.isPodman()
                } else if (backgroundval.type == 21) {
                    standee.isBuzzlet()
                } else if (backgroundval.type == 22) {
                    standee.isFlugoon()
                } else if (backgroundval.type == 23) {
                    standee.isStarbatross()
                } else if (backgroundval.type == 24) {
                    standee.isMegagnat()
                } else if (backgroundval.type == 25) {
                    standee.isAlagadile()
                } else if (backgroundval.type == 26) {
                    standee.isBigAlagadile()
                } else if (backgroundval.type == 27) {
                    standee.isBigHunchAlagadile()
                } else if (backgroundval.type == 28) {
                    standee.isHunchAlagadile()
                } else if (backgroundval.type == 29) {
                    standee.isGogonaut()
                } else if (backgroundval.type == 30) {
                    standee.isGogonautDefender()
                } else if (backgroundval.type == 31) {
                    standee.isGogonautChampion()
                } else if (backgroundval.type == 32) {
                    standee.isGogonautTeam()
                } else if (backgroundval.type == 33) {
                    standee.isBeeWorker()
                } else if (backgroundval.type == 34) {
                    standee.isBeeScout()
                } else if (backgroundval.type == 35) {
                    standee.isBeeSoldier()
                } else if (backgroundval.type == 36) {
                    standee.isBeeMega()
                } else if (backgroundval.type == 37) {
                    standee.isTargetroid()
                } else if (backgroundval.type == 38) {
                    standee.isSchlorkupine()
                }
                standee.health = backgroundtk.x
                standee.walkcounter = walkdying.x
                standee.movespeedcount = walkdying.y
                if (walkdying.x > 0 || walkdying.y > 0) {
                    standee.moving = true
                    standee.realPath.push(sandmap.blocks[proceed.x][proceed.y])
                    standee.realPath.push(sandmap.blocks[proceed.x][proceed.y])
                }
                standee.id = id

                let wet = 0
                for (let t = 0; t < this.units.length; t++) {
                    if (standee.id == this.units[t].id) {
                        wet = 1
                    }
                }
                if (wet == 0) {
                    standee.tile = standee.realPath[standee.index]
                    standee.tile.occupant = standee
                    standee.tile.occupied = true
                    standee.tile.walkable = false
                    this.units.push(standee)
                    this.idtable.push(standee.id)
                }
            
            }
        }
    }
}
        init() {
            this.inned = 1
            this.contextx.drawImage(fogblockx, 0, 0, 128, 128, 0, 0, worldscale, worldscale)
        }

        dataOutput() {
            //moved
        }
        findBase() {
            this.averageSpace.dirs1 = 0
            this.averageSpace.dirs2 = 0
            this.averageSpace.dirs3 = 0
            this.averageSpace.dirs4 = 0
            for (let t = 0; t < this.faction.buildings.length; t++) {
                if (this.averageSpace.dirs1 == 0) {// right
                    if (this.faction.buildings[t].tile.x >= this.tile.x) {
                        if (this.faction.buildings[t].tile.y == this.tile.y) {
                            this.averageSpace.dirs1 += 1
                        }
                    }
                }
                if (this.averageSpace.dirs2 == 0) {// down
                    if (this.faction.buildings[t].tile.y >= this.tile.y) {
                        if (this.faction.buildings[t].tile.x == this.tile.x) {
                            this.averageSpace.dirs2 += 1
                        }
                    }
                }
                if (this.averageSpace.dirs3 == 0) { // left
                    if (this.faction.buildings[t].tile.x <= this.tile.x) {
                        if (this.faction.buildings[t].tile.y == this.tile.y) {
                            this.averageSpace.dirs3 += 1
                        }
                    }
                }
                if (this.averageSpace.dirs4 == 0) {  // up
                    if (this.faction.buildings[t].tile.y <= this.tile.y) {
                        if (this.faction.buildings[t].tile.x == this.tile.x) {
                            this.averageSpace.dirs4 += 1
                        }
                    }
                }
            }

            this.averageSpace.decayingInTheWind = 1 - ((this.averageSpace.dirs1 + this.averageSpace.dirs2 + this.averageSpace.dirs3 + this.averageSpace.dirs4) / 4)
        }
        findBase() {
            if (this.buildings.length > 0) {
                let tindex = 0
                let kindex = 0
                for (let t = 0; t < this.buildings.length; t++) {
                    tindex += (this.buildings[t].tile.t)
                    kindex += (this.buildings[t].tile.k)
                }
                if (this.averageSpace.tile != sandmap.blocks[Math.floor(tindex / this.buildings.length)][Math.floor(kindex / this.buildings.length)]) {
                    let dis = Math.abs(this.averageSpace.tile.t - sandmap.blocks[Math.floor(tindex / this.buildings.length)][Math.floor(kindex / this.buildings.length)].t) + Math.abs(this.averageSpace.tile.k - sandmap.blocks[Math.floor(tindex / this.buildings.length)][Math.floor(kindex / this.buildings.length)].k)
                    if (dis > 4) {
                        this.averageSpace.tile = sandmap.blocks[Math.floor(tindex / this.buildings.length)][Math.floor(kindex / this.buildings.length)]
                        this.baseMoveFlag = 1
                    }
                }
            } else {
                this.averageSpace.tile = sandmap.blocks[10][10]
            }
        }
        ai() {
            for (let t = 0; t < this.seenrocks.length; t++) {
                if (this.seenrocks[t].sourcerock <= 0) {
                    this.seenrocks.splice(t, 1)
                }
            }

            if(this.dynamic == 1){
                    this.clickrate = this.units.length
            }

            if (campaignController.mission > -1) {
                if (this.campaignThrottle <= 0) {
                    this.campaignThrottle = 1
                    for (let t = 0; t < this.units.length; t++) {
                        // if(!(this.units[t].attacksplatter > 0)){

                        // if (this.units[t].pollinator != 1 && this.units[t].hamartanworker != 1 && this.units[t].nymph != 1) {
                        // if (Math.random() < .5) {
                        //this.units[t].attackmoveunit()
                        //test case 123456
                        this.units[t].attackmove()
                        this.units[t].attacksplatter = this.units[t].movespeed
                        // } else if (Math.random() < .5) {
                        //     this.units[t].attackmove()
                        //     this.units[t].attacksplatter = this.units[t].movespeed
                        // }
                    }

                    // }else{
                    //     this.units[t].attacksplatter--
                    //     this.campaignThrottle--
                    // }

                    // }
                }
                this.campaignThrottle--
                // this.units[t].attacksplatter--
            } else {

                for (let t = 0; t < this.units.length; t++) {
                    if (!(this.units[t].attacksplatter > 0)) {
                        if (this.units[t].pollinator != 1 && this.units[t].hamartanworker != 1 && this.units[t].nymph != 1) {
                            if (Math.random() < .9) {
                                //this.units[t].attackmoveunit()
                                //test case 123456
                                this.units[t].attackmove()
                                this.units[t].attacksplatter = this.units[t].movespeed
                            } else {
                                this.units[t].attackmove()
                                this.units[t].attacksplatter = this.units[t].movespeed
                            }
                        }
                    } else {
                        this.units[t].attacksplatter--
                    }
                }
            }
            if (this.type == 8) {
                this.targetroidAI()
            } else if (this.type == 6) {
                this.schlorkupineAI()
            } else if (this.type == 5) { //avesectian ai
                // if (sandmap.players.indexOf(this) == 0) {
                //     this.avesectianAI()
                // } else {
                this.alternateAvesectianAI()
                // }
            } else if (this.type == 4) {
                // if(sandmap.players.indexOf(this) == 0){
                // this.plaztiliteAI()
                this.alternatePlaztiliteAI()

                // }else{
                //     this.alternatePlaztiliteAI()
                // }
            } else if (this.type == 3) { //librilbian AI
                if (campaignController.mission > -1) {
                    this.campaignLibrilbianAI()
                } else {
                //     if(sandmap.players.indexOf(this) == 0){
                //     this.librilbianAI()
                // }else{
                    this.alternateLibrilbianAI()

                // }
                }
            } else if (this.type == 7) { //librilbian AI
                this.alagadileAI()
            } else if (this.type == 2) { //hamartan AI
                // if(sandmap.players.indexOf(this) == 0){
                // this.alternateHamartanAI()
                // }else{
                this.huntAlternateHamartanAI()
                // }
            } else if (this.type == 1) { //colditzlerian AI
                // if(sandmap.players.indexOf(this) == 0){
                // this.alternatecolditzlerAI()
                // }else{
                // //     // this.colditzlerAI()
                // //     this.alternatecolditzlerAI()
                this.retreatAlternatecolditzlerAI()
                // }
            } else if (this.type == 9) { //colditzlerian AI
                this.gogonautAI()
            } else if (this.type == 10) { //colditzlerian AI
                this.beepleAI()
            } else if (this.type == 0) { // human below, itzler above
                // if(sandmap.players.indexOf(this) == 0){
                if (campaignController.mission > -1) {

                    this.campaignHumanAI()
                } else {

                    this.alternateHumanAI()
                }
                // }else{
                // this.humanAI()
                // }
            } else if (this.type == -1) {
                //group AI
                if (this.defending >= 1) {
                    this.defending = 0
                    this.defenseforce = 0
                    for (let t = 0; t < this.units.length; t++) {
                        if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < 110) { //16 //80

                            this.units[t].ultrabreak = this.attackedAt
                            this.units[t].ultrawalk = 0
                            this.units[t].start = this.units[t].tile
                        }
                    }
                }
            }

            this.defending--
        }
        schlorkupineAI() {

            this.chunk++
            let index = -1
            let j = 0


            let unitcountersee = 0
            let buildingsseecount = 0
            let lastseen = {}
            for(let d = 1;d<sandmap.players.length;d++){
            const indexer = Math.abs((sandmap.players.indexOf(this) + d)%sandmap.players.length)

            for (let t = 0; t < sandmap.players[indexer].buildings.length; t++) {
                if (this.blocks[sandmap.players[indexer].buildings[t].tile.t][sandmap.players[indexer].buildings[t].tile.k].markdraw == 1) {
                    buildingsseecount++
                    lastseen = sandmap.blocks[sandmap.players[indexer].buildings[t].tile.t][sandmap.players[indexer].buildings[t].tile.k]
                }
            }
            for (let t = 0; t < sandmap.players[indexer].units.length; t++) {
                if (this.blocks[sandmap.players[indexer].units[t].tile.t][sandmap.players[indexer].units[t].tile.k].markdraw == 1) {
                    unitcountersee++
                    lastseen = sandmap.blocks[sandmap.players[indexer].units[t].tile.t][sandmap.players[indexer].units[t].tile.k]
                }
            }
        }

            if (this.units.length > 0) {
                if ((unitcountersee > 0 || buildingsseecount > 0) && (this.units[0].attackCost > 640)) {
                    // this.attackedAt = lastseen
                    for (let t = 0; t < this.units.length; t++) {
                        if ((this.units[t].health > this.units[t].maxhealth * .25)) {
                            if (!(this.units[t].defendsplatter > 0)) {

                                let gj = 0
                                while (lastseen.walkable == false) {
                                    if (gj > 100) {
                                        break
                                    }
                                    lastseen = sandmap.blocks[Math.min(Math.max(lastseen.t - (Math.sign(Math.random() - .5)), 0), worldscale - 1)][Math.min(Math.max(lastseen.k - (Math.sign(Math.random() - .5)), 0), worldscale - 1)]
                                }
                                this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - lastseen.t) + Math.abs(this.units[t].tile.k - lastseen.k)) * this.units[t].movespeed * 1
                                this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - lastseen.t) + Math.abs(this.units[t].tile.k - lastseen.k)) * this.units[t].movespeed) * 1
                                this.units[t].ultrabreak = lastseen
                                this.units[t].ultrawalk = 0
                                this.units[t].start = this.units[t].tile
                                this.units[t].defendsplatter = 50  //this.units[t].movespeed
                            } else {
                                this.units[t].defendsplatter--
                            }
                        }
                    }
                }
            }
            for (let t = 0; t < this.units.length; t++) {
                if (this.units[t].attackCost > 400) {
                    if ((this.units[t].health > this.units[t].maxhealth * .25)) {
                        this.units[t].attackmove()
                    }
                }
            }
            for (let t = 0; t < this.units.length; t++) {
                this.units[t].smartAttack()
            }
            for (let t = 0; t < this.units.length; t++) {
                this.units[t].fleeingpathlimit--
            }

            for (let t = 0; t < this.units.length; t++) {
                if (this.units.length > 0) {//this.units.length >= this.seenrocks.length - 1 &&

                    if (!(this.units[t].health > this.units[t].maxhealth * .25)) {

                        let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                        let u = 0
                        while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                            u++
                            block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                        }
                        if (!(this.units[t].fleeingpathlimit > 0)) {
                            this.units[t].fleeingpathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * .5
                            this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * .1
                            this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed * .02
                            this.units[t].ultrabreak = block
                            this.units[t].ultrawalk = 0
                            this.units[t].start = this.units[t].tile
                            break
                        }
                    }
                    // if (this.units[t].tile.sourcerock > 0 || (this.units[t].realPath[this.units[t].realPath.length - 1].sourcerock > 0 && this.units[t].tile != this.units[t].realPath[this.units[t].realPath.length - 1] && this.units[t].realPath[this.units[t].realPath.length - 1].occupied == false)) {

                    // } else {
                    if (this.seenrocks.length < this.units.length) { //Math.random() < 1 ||
                        let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                        let u = 0
                        while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                            u++
                            block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                        }

                        if (this.units[t].hotrockrepathlimit <= 0) {
                            if (this.units[t].sight <= 8) {
                                this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * .02
                                this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed * .02
                                this.units[t].ultrabreak = block
                                this.units[t].ultrawalk = 0
                                this.units[t].start = this.units[t].tile
                            }
                        }
                    }
                    // }
                }
            }

            for (let t = 0; t < this.units.length; t++) {

                index = -1
                // if (this.units[t].realPath.length - 1 == this.units[t].index) { //} || this.units[t].realPath[this.units[t].index].walkable !== true) {
                if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {

                    if (this.units[t].hotrockrepathlimit <= 0) {
                        let max = 999999999
                        let drytrack = 0
                        for (let h = 0; h < sandmap.hotrocks.length; h++) {
                            if (sandmap.hotrocks[h].walkable == true && sandmap.hotrocks[h].occupied == false && this.blocks[sandmap.hotrocks[h].t][sandmap.hotrocks[h].k].markdraw == 1) {
                                const link = (new LineOP(this.units[t].tile, sandmap.hotrocks[h])).hypotenuse()
                                // //////////console.log(link)
                                if (link < max) {
                                    max = link
                                    index = h
                                    if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                                    } else {

                                        this.units[t].ultrabreak = sandmap.hotrocks[index]
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                        drytrack = Math.floor((this.units[t].movespeed) * (max * .1))
                                    }
                                }
                            }
                        }
                        if (drytrack != 0) {
                            this.units[t].hotrockrepathlimit = drytrack
                        }
                    }
                }

                if (this.units[t].incomeCost < 640) {
                    this.units[t].upgradeIncome()
                    if (this.units[t].speedCost <= 320 && this.units[t].incomeCost > 280) {
                        this.units[t].upgradeSpeed()
                    }
                } else {
                    if (this.units[t].speedCost < 520) {
                        this.units[t].upgradeSpeedSchlorkupine()
                    }
                    // this.units[t].upgradeIncome()

                    this.units[t].upgradeAttack()
                    // this.units[t].upgradeSpeed()
                    this.units[t].upgradeDefenseSchlorkupine()
                    if (this.units[t].attackCost > 240) {
                        if (this.units[t].incomeCost < 680) {
                            this.units[t].upgradeIncome()
                        }
                    }
                }
            }
        }
        targetroidAI() {

            this.chunk++
            let index = -1
            let j = 0



            let unitcountersee = 0
            let buildingsseecount = 0
            let lastseen = {}
            for(let d = 1;d<sandmap.players.length;d++){
            const indexer = Math.abs((sandmap.players.indexOf(this) + d)%sandmap.players.length)

            for (let t = 0; t < sandmap.players[indexer].buildings.length; t++) {
                if (this.blocks[sandmap.players[indexer].buildings[t].tile.t][sandmap.players[indexer].buildings[t].tile.k].markdraw == 1) {
                    buildingsseecount++
                    lastseen = sandmap.blocks[sandmap.players[indexer].buildings[t].tile.t][sandmap.players[indexer].buildings[t].tile.k]
                }
            }
            for (let t = 0; t < sandmap.players[indexer].units.length; t++) {
                if (this.blocks[sandmap.players[indexer].units[t].tile.t][sandmap.players[indexer].units[t].tile.k].markdraw == 1) {
                    unitcountersee++
                    lastseen = sandmap.blocks[sandmap.players[indexer].units[t].tile.t][sandmap.players[indexer].units[t].tile.k]
                }
            }
        }


            if (this.units.length > 0) {
                if ((unitcountersee > 0 || buildingsseecount > 0) && (this.units[0].attackCost > 640)) {
                    // this.attackedAt = lastseen
                    for (let t = 0; t < this.units.length; t++) {
                        if ((this.units[t].health > this.units[t].maxhealth * .25)) {
                            if (!(this.units[t].defendsplatter > 0)) {

                                let gj = 0
                                while (lastseen.walkable == false) {
                                    if (gj > 100) {
                                        break
                                    }
                                    lastseen = sandmap.blocks[Math.min(Math.max(lastseen.t - (Math.sign(Math.random() - .5)), 0), worldscale - 1)][Math.min(Math.max(lastseen.k - (Math.sign(Math.random() - .5)), 0), worldscale - 1)]
                                }
                                this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - lastseen.t) + Math.abs(this.units[t].tile.k - lastseen.k)) * this.units[t].movespeed * 1
                                this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - lastseen.t) + Math.abs(this.units[t].tile.k - lastseen.k)) * this.units[t].movespeed) * 1
                                this.units[t].ultrabreak = lastseen
                                this.units[t].ultrawalk = 0
                                this.units[t].start = this.units[t].tile
                                this.units[t].defendsplatter = 50  //this.units[t].movespeed
                            } else {
                                this.units[t].defendsplatter--
                            }
                        }
                    }
                }
            }
            for (let t = 0; t < this.units.length; t++) {
                if (this.units[t].attackCost > 400) {
                    if ((this.units[t].health > this.units[t].maxhealth * .25)) {
                        this.units[t].attackmove()
                    }
                }
            }
            for (let t = 0; t < this.units.length; t++) {
                this.units[t].smartAttack()
            }
            for (let t = 0; t < this.units.length; t++) {
                this.units[t].fleeingpathlimit--
            }

            for (let t = 0; t < this.units.length; t++) {
                if (this.units.length > 0) {//this.units.length >= this.seenrocks.length - 1 &&

                    if (!(this.units[t].health > this.units[t].maxhealth * .25)) {

                        let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                        let u = 0
                        while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                            u++
                            block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                        }
                        if (!(this.units[t].fleeingpathlimit > 0)) {
                            this.units[t].fleeingpathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * .5
                            this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * .1
                            this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed * .02
                            this.units[t].ultrabreak = block
                            this.units[t].ultrawalk = 0
                            this.units[t].start = this.units[t].tile
                            break
                        }
                    }
                    // if (this.units[t].tile.sourcerock > 0 || (this.units[t].realPath[this.units[t].realPath.length - 1].sourcerock > 0 && this.units[t].tile != this.units[t].realPath[this.units[t].realPath.length - 1] && this.units[t].realPath[this.units[t].realPath.length - 1].occupied == false)) {

                    // } else {
                    if (this.seenrocks.length < this.units.length) { //Math.random() < 1 ||
                        let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                        let u = 0
                        while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                            u++
                            block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                        }

                        if (this.units[t].hotrockrepathlimit <= 0) {
                            if (this.units[t].sight <= 8) {
                                this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * .02
                                this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed * .02
                                this.units[t].ultrabreak = block
                                this.units[t].ultrawalk = 0
                                this.units[t].start = this.units[t].tile
                            }
                        }
                    }
                    // }
                }
            }

            for (let t = 0; t < this.units.length; t++) {

                index = -1
                // if (this.units[t].realPath.length - 1 == this.units[t].index) { //} || this.units[t].realPath[this.units[t].index].walkable !== true) {
                if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {

                    if (this.units[t].hotrockrepathlimit <= 0) {
                        let max = 999999999
                        let drytrack = 0
                        for (let h = 0; h < sandmap.hotrocks.length; h++) {
                            if (sandmap.hotrocks[h].walkable == true && sandmap.hotrocks[h].occupied == false && this.blocks[sandmap.hotrocks[h].t][sandmap.hotrocks[h].k].markdraw == 1) {
                                const link = (new LineOP(this.units[t].tile, sandmap.hotrocks[h])).hypotenuse()
                                // //////////console.log(link)
                                if (link < max) {
                                    max = link
                                    index = h
                                    if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                                    } else {

                                        this.units[t].ultrabreak = sandmap.hotrocks[index]
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                        drytrack = Math.floor((this.units[t].movespeed) * (max * .1))
                                    }
                                }
                            }
                        }
                        if (drytrack != 0) {
                            this.units[t].hotrockrepathlimit = drytrack
                        }
                    }
                }

                if (this.units[t].incomeCost < 640) {
                    this.units[t].upgradeIncome()
                    if (this.units[t].speedCost <= 320 && this.units[t].incomeCost > 280) {
                        this.units[t].upgradeSpeed()
                    }
                } else {
                    if (this.units[t].speedCost < 520) {
                        this.units[t].upgradeSpeed()
                    }
                    // this.units[t].upgradeIncome()

                    this.units[t].upgradeAttack()
                    // this.units[t].upgradeSpeed()
                    this.units[t].upgradeDefense()
                    if (this.units[t].attackCost > 240) {
                        if (this.units[t].incomeCost < 680) {
                            this.units[t].upgradeIncome()
                        }
                    }
                }
            }
        }
        beepleAI(){

            if (this.defending >= 25) {
                let mx = 0
                let my = 0
                for (let t = 0; t < this.units.length; t++) {
                    mx += this.units[t].tile.x
                    my += this.units[t].tile.y
                }

                mx = Math.floor((mx/this.units.length)*.1)
                my = Math.floor((my/this.units.length)*.1)

                this.defending = 0
                this.defenseforce = 0
                for (let t = 0; t < this.units.length; t++) {
                    // if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < 110) { //16 //80
                    if ((true)) {
                        if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < ((worldscale * .15) * 10)) {
                            if (this.units[t].defensepathlimit <= 0) {
                                this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * .67
                                this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed * .37
                                this.units[t].ultrabreak =   sandmap.blocks[mx][my]        //      this.attackedAt
                                this.units[t].ultrawalk = 0
                                this.units[t].start = this.units[t].tile
                            }
                        }
                    }
                    // }
                }
            }



            let unitcountersee = 0
            let buildingsseecount = 0
            let lastseen = {}
            let epowercount = 0
            let healthMeter = 999999999

            for(let d = 1;d<sandmap.players.length;d++){
            const indexer = Math.abs((sandmap.players.indexOf(this) + d)%sandmap.players.length)

            for (let t = 0; t < sandmap.players[indexer].buildings.length; t++) {
                if (this.blocks[sandmap.players[indexer].buildings[t].tile.t][sandmap.players[indexer].buildings[t].tile.k].markdraw == 1) { //can see this unit
                    buildingsseecount++
                    if (healthMeter > sandmap.players[indexer].buildings[t].health) {
                        lastseen = sandmap.blocks[sandmap.players[indexer].buildings[t].tile.t][sandmap.players[indexer].buildings[t].tile.k]
                    }
                }
            }

            for (let t = 0; t < sandmap.players[indexer].units.length; t++) {
                if (this.blocks[sandmap.players[indexer].units[t].tile.t][sandmap.players[indexer].units[t].tile.k].markdraw == 1) {//can see this building
                    unitcountersee++
                    if (healthMeter > sandmap.players[indexer].units[t].health) {
                        healthMeter = sandmap.players[indexer].units[t].health
                        lastseen = sandmap.blocks[sandmap.players[indexer].units[t].tile.t][sandmap.players[indexer].units[t].tile.k]
                    }
                    epowercount += sandmap.players[indexer].units[t].health //add up their health (not super fair to players, as they only get the healthbar graphic)
                }
            }
        }
            let powercount = 0
            for (let t = 0; t < this.units.length; t++) {
                if ((unitcountersee > 0 || buildingsseecount > 0) && (this.units[t].health > 500)) { //calculate strength of current army
                    if ((this.units[t].health > this.units[t].maxhealth * .25)) {
                        // if (!(this.units[t].defendsplatter > 0)) {
                        powercount += this.units[t].health
                        // }
                    }
                }
            }

            if (this.units.length > 0) {
                for (let t = 0; t < this.units.length; t++) {
                    if ((unitcountersee > 0 || buildingsseecount > 0) && (this.units[t].health > 500)) {
                        if ((this.units[t].health > this.units[t].maxhealth * .25)) {
                            if (!(this.units[t].defendsplatter > 0)) {
                                // if(!(this.units[t].isInRange(this.units[t].attacktarget && this.units[t].attacktarget.health > 0))){
                                if (epowercount <= powercount) {
                                    let gj = 0
                                    while (lastseen.walkable == false) {
                                        if (gj > 100) {
                                            break
                                        }
                                        lastseen = sandmap.blocks[Math.min(Math.max(lastseen.t - (Math.sign(Math.random() - .5)), 0), worldscale - 1)][Math.min(Math.max(lastseen.k - (Math.sign(Math.random() - .5)), 0), worldscale - 1)]
                                    }
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - lastseen.t) + Math.abs(this.units[t].tile.k - lastseen.k)) * this.units[t].movespeed * .5
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - lastseen.t) + Math.abs(this.units[t].tile.k - lastseen.k)) * this.units[t].movespeed) * 1
                                    this.units[t].ultrabreak = lastseen
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                    this.units[t].defendsplatter = this.units[t].movespeed * 9 //prevent spam
                                } else {
                                    this.units[t].defendsplatter--
                                }
                                // }
                            } else {
                                this.units[t].defendsplatter--
                            }
                        } else {
                            this.units[t].defendsplatter--
                        }
                    } else {
                        this.units[t].defendsplatter--
                    }
                }
            }

            for (let t = 0; t < this.units.length; t++) {
                this.units[t].smartAttack()
            }



            // if (Math.random() < .1) {
            for (let t = 0; t < this.units.length; t++) {
                if (!(this.units[t].attacksplatter > 0)) {
                    this.units[t].attacksplatter = this.units[t].movespeed * 1
                    this.units[t].attackmove()
                } else {
                    this.units[t].attacksplatter--
                }
            }
            // }
            this.chunk++
            let index = -1
            let j = 0


            let workercount = 0
            for (let t = 0; t < this.units.length; t++) {
                if (this.units[t].beeworker == 1) {
                    workercount++
                }
            }



            if (this.chunk % this.clickrate == 0 || Math.random() < .03) {
                for (let t = 0; t < this.buildings.length; t++) {
                    if(workercount < this.units.length*.5){
                            if (this.hotrock > 110) {
                                this.buildings[t].makeBeeWorker()
                            }
                    }else{
                        if (this.buildings[t].beehive == 1) {
                            if (Math.random() < .02) {
                                if (this.hotrock > 240) {
                                    this.buildings[t].makeBeeWorker()
                                }
                            }
                            if (Math.random() < .01) {
                                if (this.hotrock > 240) {
                                    this.buildings[t].makeBeeScout()
                                }
                            }
                            if (Math.random() < .03) {
                                if (this.hotrock > 240) {
                                    this.buildings[t].makeBeeSoldier()
                                }
                            }
                            if (Math.random() < .04) {
                                if (this.hotrock > 400) {
                                    this.buildings[t].makeBeeMega()
                                }
                            }
    
                        }
                    }

                }
                let tpos = 0
                let kpos = 0

                for (let t = 0; t < this.units.length; t++) {
                    tpos += this.units[t].tile.t
                    kpos += this.units[t].tile.k
                }
                tpos = Math.max(Math.min(Math.round(tpos / 3), (worldscale - 4)), 0)
                kpos = Math.max(Math.min(Math.round(kpos / 3), (worldscale - 4)), 0)

                let tile = sandmap.blocks[tpos][kpos]
                if (tile.occupied == true) {
                    if (kpos < (worldscale - 4)) {
                        tile = sandmap.blocks[tpos][kpos + 1]
                    } else {
                        if (tpos < (worldscale - 4)) {
                            tile = sandmap.blocks[tpos + 1][kpos]
                        }
                    }
                }

                // let count = 3
                // for (let t = 0; t < this.units.length; t++) {
                //     const link = new LineOP(this.units[t].tile, tile)
                //     if (((this.hotrock >= 380) && link.hypotenuse() <= 500)) { //975
                //         count++
                //     }
                // }

                this.racks = 0
                for (let t = 0; t < this.buildings.length; t++) {
                    if (this.buildings[t].beehive == 1) {
                        this.racks++
                    }
                }

                for (let t = 0; t < this.units.length; t++) {
                    // if (this.units[t].realPath.length - 1 == this.units[t].index) {
                    if ((this.racks * 400) < this.hotrock) { //400
                        if (Math.random() < .5) {
                            if (Math.random() < .5) {
                                this.buildHive(sandmap.blocks[Math.max(this.units[t].tile.t - 3, 0)][this.units[t].tile.k])
                            } else {
                                this.buildHive(sandmap.blocks[Math.min(this.units[t].tile.t + 3, (worldscale - 1))][this.units[t].tile.k])
                            }
                        } else {
                            if (Math.random() < .5) {
                                this.buildHive(sandmap.blocks[this.units[t].tile.t][Math.min(this.units[t].tile.k + 3, (worldscale - 1))])
                            } else {
                                this.buildHive(sandmap.blocks[this.units[t].tile.t][Math.max(this.units[t].tile.k - 3, 0)])
                            }
                        }
                        // break
                    }
                    // }
                }


            }


            if (this.chunk % this.clickrate == 0) {
                //this.units.sort((a, b) => (Math.random() > .5) ? 1 : -1)
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units.length > 2) {//this.units.length >= this.seenrocks.length - 1 &&
                        if (this.units[t].tile.sourcerock > 0 || (this.units[t].realPath[this.units[t].realPath.length - 1].sourcerock > 0 && this.units[t].tile != this.units[t].realPath[this.units[t].realPath.length - 1] && this.units[t].realPath[this.units[t].realPath.length - 1].occupied == false)) {

                        } else {

                            // if (Math.random() < ((1 / this.units.length)) * this.clickrate) {
                            // if (Math.random() < ((10 / this.units.length)) * this.clickrate) {
                            if (Math.random() < .05) {
                                // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]

                                let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                let u = 0
                                while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                    u++
                                    block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                }
                                // 

                                if (this.units[t].hotrockrepathlimit <= 0) {
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * .375
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed * .12
                                    this.units[t].ultrabreak = block
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }

                            }
                        }
                    }
                }
                for (let t = 0; t < this.units.length; t++) {

                    index = -1
                    // if (this.units[t].realPath.length - 1 == this.units[t].index) { //} || this.units[t].realPath[this.units[t].index].walkable !== true) {
                    if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {

                        if (this.units[t].hotrockrepathlimit <= 0) {
                            let max = 999999999
                            let drytrack = 0
                            for (let h = 0; h < sandmap.hotrocks.length; h++) {
                                if (sandmap.hotrocks[h].walkable == true && sandmap.hotrocks[h].occupied == false && this.blocks[sandmap.hotrocks[h].t][sandmap.hotrocks[h].k].markdraw == 1) {
                                    const link = (new LineOP(this.units[t].tile, sandmap.hotrocks[h])).hypotenuse()
                                    // //////////console.log(link)
                                    if (link < max) {
                                        max = link
                                        index = h
                                        if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                                        } else {

                                            this.units[t].ultrabreak = sandmap.hotrocks[index]
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            drytrack = Math.floor((this.units[t].movespeed) * (max * .1)) * 2
                                        }
                                    }
                                }
                            }
                            if (drytrack != 0) {
                                this.units[t].hotrockrepathlimit = drytrack * .5
                            }
                        }
                    }
                }

            }

            for (let t = 0; t < this.units.length; t++) {
                if (this.units[t].index == this.units[t].realPath.length - 1) {
                    this.units[t].hotrockrepathlimit -= this.units[t].movespeed
                    this.units[t].defensepathlimit -= this.units[t].movespeed
                }
            }



        }
        gogonautAI() {

            if (this.defending >= 25) {
                this.defending = 0
                this.defenseforce = 0
                for (let t = 0; t < this.units.length; t++) {
                    // if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < 110) { //16 //80
                    if ((true)) {
                        if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < ((worldscale * .5) * 10)) {
                            if (this.units[t].defensepathlimit <= 0) {
                                this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * .67
                                this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed * .37
                                this.units[t].ultrabreak = this.attackedAt
                                this.units[t].ultrawalk = 0
                                this.units[t].start = this.units[t].tile
                            }
                        }
                    }
                    // }
                }
            }
            // if (Math.random() < .1) {
            for (let t = 0; t < this.units.length; t++) {
                if (!(this.units[t].attacksplatter > 0)) {
                    this.units[t].attacksplatter = this.units[t].movespeed * 1
                    this.units[t].attackmove()
                } else {
                    this.units[t].attacksplatter--
                }
            }
            // }
            this.chunk++
            let index = -1
            let j = 0


            let workercount = 0
            // for (let t = 0; t < this.units.length; t++) {
            //     if (this.units[t].bighunchalagadile == 1) {
            //         workercount++
            //     }
            //     if (this.units[t].bigalagadile == 1) {
            //         workercount++
            //     }
            // }



            if (this.chunk % this.clickrate == 0 || Math.random() < .03) {
                for (let t = 0; t < this.buildings.length; t++) {

                    if (this.buildings[t].tree == 1) {
                        if (Math.random() < .02) {
                            if (this.hotrock > 100) {
                                this.buildings[t].makeGogonaut()
                            }
                        }
                        if (Math.random() < .1) {
                            if (this.hotrock > 400) {
                                this.buildings[t].makeGogonautChampion()
                            }
                        }
                        if (Math.random() < .03) {
                            if (this.hotrock > 150) {
                                this.buildings[t].makeGogonautTeam()
                            }
                        }
                        if (Math.random() < .04) {
                            if (this.hotrock > 210) {
                                this.buildings[t].makeGogonautDefender()
                            }
                        }

                    }
                }
                let tpos = 0
                let kpos = 0

                for (let t = 0; t < this.units.length; t++) {
                    tpos += this.units[t].tile.t
                    kpos += this.units[t].tile.k
                }
                tpos = Math.max(Math.min(Math.round(tpos / 3), (worldscale - 4)), 0)
                kpos = Math.max(Math.min(Math.round(kpos / 3), (worldscale - 4)), 0)

                let tile = sandmap.blocks[tpos][kpos]
                if (tile.occupied == true) {
                    if (kpos < (worldscale - 4)) {
                        tile = sandmap.blocks[tpos][kpos + 1]
                    } else {
                        if (tpos < (worldscale - 4)) {
                            tile = sandmap.blocks[tpos + 1][kpos]
                        }
                    }
                }

                // let count = 3
                // for (let t = 0; t < this.units.length; t++) {
                //     const link = new LineOP(this.units[t].tile, tile)
                //     if (((this.hotrock >= 380) && link.hypotenuse() <= 500)) { //975
                //         count++
                //     }
                // }

                this.racks = 0
                for (let t = 0; t < this.buildings.length; t++) {
                    if (this.buildings[t].tree == 1) {
                        this.racks++
                    }
                }

                for (let t = 0; t < this.units.length; t++) {
                    // if (this.units[t].realPath.length - 1 == this.units[t].index) {
                    if ((this.racks * 250) < this.hotrock) { //400
                        if (Math.random() < .5) {
                            if (Math.random() < .5) {
                                this.buildTree(sandmap.blocks[Math.max(this.units[t].tile.t - 3, 0)][this.units[t].tile.k])
                            } else {
                                this.buildTree(sandmap.blocks[Math.min(this.units[t].tile.t + 3, (worldscale - 1))][this.units[t].tile.k])
                            }
                        } else {
                            if (Math.random() < .5) {
                                this.buildTree(sandmap.blocks[this.units[t].tile.t][Math.min(this.units[t].tile.k + 3, (worldscale - 1))])
                            } else {
                                this.buildTree(sandmap.blocks[this.units[t].tile.t][Math.max(this.units[t].tile.k - 3, 0)])
                            }
                        }
                        // break
                    }
                    // }
                }


            }


            if (this.chunk % this.clickrate == 0) {
                //this.units.sort((a, b) => (Math.random() > .5) ? 1 : -1)
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units.length > 2) {//this.units.length >= this.seenrocks.length - 1 &&
                        if (this.units[t].tile.sourcerock > 0 || (this.units[t].realPath[this.units[t].realPath.length - 1].sourcerock > 0 && this.units[t].tile != this.units[t].realPath[this.units[t].realPath.length - 1] && this.units[t].realPath[this.units[t].realPath.length - 1].occupied == false)) {

                        } else {

                            // if (Math.random() < ((1 / this.units.length)) * this.clickrate) {
                            // if (Math.random() < ((10 / this.units.length)) * this.clickrate) {
                            if (Math.random() < .05) {
                                // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]

                                let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                let u = 0
                                while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                    u++
                                    block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                }
                                // 

                                if (this.units[t].hotrockrepathlimit <= 0) {
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * .375
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed * .12
                                    this.units[t].ultrabreak = block
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }

                            }
                        }
                    }
                }
                for (let t = 0; t < this.units.length; t++) {

                    index = -1
                    // if (this.units[t].realPath.length - 1 == this.units[t].index) { //} || this.units[t].realPath[this.units[t].index].walkable !== true) {
                    if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {

                        if (this.units[t].hotrockrepathlimit <= 0) {
                            let max = 999999999
                            let drytrack = 0
                            for (let h = 0; h < sandmap.hotrocks.length; h++) {
                                if (sandmap.hotrocks[h].walkable == true && sandmap.hotrocks[h].occupied == false && this.blocks[sandmap.hotrocks[h].t][sandmap.hotrocks[h].k].markdraw == 1) {
                                    const link = (new LineOP(this.units[t].tile, sandmap.hotrocks[h])).hypotenuse()
                                    // //////////console.log(link)
                                    if (link < max) {
                                        max = link
                                        index = h
                                        if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                                        } else {

                                            this.units[t].ultrabreak = sandmap.hotrocks[index]
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            drytrack = Math.floor((this.units[t].movespeed) * (max * .1)) * 2
                                        }
                                    }
                                }
                            }
                            if (drytrack != 0) {
                                this.units[t].hotrockrepathlimit = drytrack * .5
                            }
                        }
                    }
                }

            }

            for (let t = 0; t < this.units.length; t++) {
                if (this.units[t].index == this.units[t].realPath.length - 1) {
                    this.units[t].hotrockrepathlimit -= this.units[t].movespeed
                    this.units[t].defensepathlimit -= this.units[t].movespeed
                }
            }


        }


        alagadileAI() {

            if (this.defending >= 500) {
                this.defending = 0
                this.defenseforce = 0
                for (let t = 0; t < this.units.length; t++) {
                    // if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < 110) { //16 //80
                    if (this.units[t].bigalagadile == 1 || this.units[t].bighunchalagadile == 1) {
                        if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < ((worldscale * .33) * 10)) { //16 //80

                            if (this.units[t].defensepathlimit <= 0) {
                                this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * .27
                                this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed * .17
                                this.units[t].ultrabreak = this.attackedAt
                                this.units[t].ultrawalk = 0
                                this.units[t].start = this.units[t].tile
                            }
                        }
                    } else {

                        if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < ((worldscale * .5) * 10)) {
                            if (this.units[t].defensepathlimit <= 0) {
                                this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * .27
                                this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed * .17
                                this.units[t].ultrabreak = this.attackedAt
                                this.units[t].ultrawalk = 0
                                this.units[t].start = this.units[t].tile
                            }
                        }
                    }
                    // }
                }
            }
            // if (Math.random() < .1) {
            for (let t = 0; t < this.units.length; t++) {
                if (!(this.units[t].attacksplatter > 0)) {
                    this.units[t].attacksplatter = this.units[t].movespeed * .2
                    this.units[t].attackmove()
                } else {
                    this.units[t].attacksplatter--
                }
            }
            // }
            this.chunk++
            let index = -1
            let j = 0


            let workercount = 0
            for (let t = 0; t < this.units.length; t++) {
                if (this.units[t].bighunchalagadile == 1) {
                    workercount++
                }
                if (this.units[t].bigalagadile == 1) {
                    workercount++
                }
            }



            if (this.chunk % this.clickrate == 0 || Math.random() < .03) {


                for (let t = 0; t < this.units.length; t++) {
                    this.units[t].smartAttack()
                }

                for (let t = 0; t < this.buildings.length; t++) {

                    if (this.buildings[t].pond == 1) {
                        if (Math.random() < .0005) {
                            if (this.hotrock > 60) {
                                this.buildings[t].makeAlagadile()
                            }
                        }
                    }
                    if (workercount < 5) {
                        if (this.buildings[t].pond == 1) {
                            if (Math.random() < .01) {
                                if (this.hotrock > 210) {
                                    this.buildings[t].makeBigHunchAlagadile()
                                }
                            }
                            if (Math.random() < .01) {
                                if (this.hotrock > 190) {
                                    this.buildings[t].makeBigAlagadile()
                                }
                            }
                        }
                    } else {

                        if (this.buildings[t].pond == 1) {
                            if (workercount <= (unitcap * .3)) {
                                if (Math.random() < .0005) {
                                    if (this.hotrock > 60) {
                                        this.buildings[t].makeAlagadile()
                                    }
                                }
                                if (Math.random() < .01) {
                                    if (this.hotrock > 140) {
                                        this.buildings[t].makeHunchAlagadile()
                                    }
                                }
                                if (Math.random() < .0013) {
                                    if (this.hotrock > 240) {
                                        this.buildings[t].makeBigHunchAlagadile()
                                    }
                                }
                                if (Math.random() < .0013) {
                                    if (this.hotrock > 240) {
                                        this.buildings[t].makeBigAlagadile()
                                    }
                                }

                            } else {

                                if (Math.random() < .05) {
                                    if (this.hotrock > 140) {
                                        this.buildings[t].makeHunchAlagadile()
                                    }
                                }
                                if (Math.random() < .03) {
                                    if (this.hotrock > 240) {
                                        this.buildings[t].makeBigHunchAlagadile()
                                    }
                                }
                                if (Math.random() < .03) {
                                    if (this.hotrock > 240) {
                                        this.buildings[t].makeBigAlagadile()
                                    }
                                }
                            }
                        }
                    }
                }
            }

            let tpos = 0
            let kpos = 0

            for (let t = 0; t < this.units.length; t++) {
                tpos += this.units[t].tile.t
                kpos += this.units[t].tile.k
            }
            tpos = Math.max(Math.min(Math.round(tpos / 3), (worldscale - 4)), 0)
            kpos = Math.max(Math.min(Math.round(kpos / 3), (worldscale - 4)), 0)

            let tile = sandmap.blocks[tpos][kpos]
            if (tile.occupied == true) {
                if (kpos < (worldscale - 4)) {
                    tile = sandmap.blocks[tpos][kpos + 1]
                } else {
                    if (tpos < (worldscale - 4)) {
                        tile = sandmap.blocks[tpos + 1][kpos]
                    }
                }
            }

            // let count = 3
            // for (let t = 0; t < this.units.length; t++) {
            //     const link = new LineOP(this.units[t].tile, tile)
            //     if (((this.hotrock >= 380) && link.hypotenuse() <= 500)) { //975
            //         count++
            //     }
            // }

            this.racks = 0
            for (let t = 0; t < this.buildings.length; t++) {
                if (this.buildings[t].pond == 1) {
                    if (this.buildings[t].que != 1) {
                        this.racks++
                    }
                }
            }

            for (let t = 0; t < this.units.length; t++) {
                if (this.units[t].realPath.length - 1 == this.units[t].index) {
                    if (this.racks == 0) { //400
                        if (Math.random() < .5) {
                            if (Math.random() < .5) {
                                this.buildPond(sandmap.blocks[Math.max(this.units[t].tile.t - 3, 0)][this.units[t].tile.k])
                            } else {
                                this.buildPond(sandmap.blocks[Math.min(this.units[t].tile.t + 3, (worldscale - 1))][this.units[t].tile.k])
                            }
                        } else {
                            if (Math.random() < .5) {
                                this.buildPond(sandmap.blocks[this.units[t].tile.t][Math.min(this.units[t].tile.k + 3, (worldscale - 1))])
                            } else {
                                this.buildPond(sandmap.blocks[this.units[t].tile.t][Math.max(this.units[t].tile.k - 3, 0)])
                            }
                        }
                        break
                    }
                }
            }




            if (this.chunk % this.clickrate == 0) {
                //this.units.sort((a, b) => (Math.random() > .5) ? 1 : -1)
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units.length > 2) {//this.units.length >= this.seenrocks.length - 1 &&
                        if (this.units[t].tile.sourcerock > 0 || (this.units[t].realPath[this.units[t].realPath.length - 1].sourcerock > 0 && this.units[t].tile != this.units[t].realPath[this.units[t].realPath.length - 1] && this.units[t].realPath[this.units[t].realPath.length - 1].occupied == false)) {

                        } else {

                            // if (Math.random() < ((1 / this.units.length)) * this.clickrate) {
                            // if (Math.random() < ((10 / this.units.length)) * this.clickrate) {
                            if (Math.random() < .05) {
                                // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]

                                let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                let u = 0
                                while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                    u++
                                    block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                }
                                // 

                                if (this.units[t].hotrockrepathlimit <= 0) {
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * .175
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed * .02
                                    this.units[t].ultrabreak = block
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }

                            }
                        }
                    }
                }
                for (let t = 0; t < this.units.length; t++) {

                    index = -1
                    // if (this.units[t].realPath.length - 1 == this.units[t].index) { //} || this.units[t].realPath[this.units[t].index].walkable !== true) {
                    if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {

                        if (this.units[t].hotrockrepathlimit <= 0) {
                            let max = 999999999
                            let drytrack = 0
                            for (let h = 0; h < sandmap.hotrocks.length; h++) {
                                if (sandmap.hotrocks[h].walkable == true && sandmap.hotrocks[h].occupied == false && this.blocks[sandmap.hotrocks[h].t][sandmap.hotrocks[h].k].markdraw == 1) {
                                    const link = (new LineOP(this.units[t].tile, sandmap.hotrocks[h])).hypotenuse()
                                    // //////////console.log(link)
                                    if (link < max) {
                                        max = link
                                        index = h
                                        if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                                        } else {

                                            this.units[t].ultrabreak = sandmap.hotrocks[index]
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            drytrack = Math.floor((this.units[t].movespeed) * (max * .1))
                                        }
                                    }
                                }
                            }
                            if (drytrack != 0) {
                                this.units[t].hotrockrepathlimit = drytrack * .5
                            }
                        }
                    }
                }

            }

            for (let t = 0; t < this.units.length; t++) {
                if (this.units[t].index == this.units[t].realPath.length - 1) {
                    this.units[t].hotrockrepathlimit -= this.units[t].movespeed
                    this.units[t].defensepathlimit -= this.units[t].movespeed
                }
            }



        }
        alternateAvesectianAI() {
            this.chunk++
            let index = -1
            let j = 0
            if (this.chunk % this.clickrate == 0) {
                //this.units.sort((a, b) => (Math.random() > .5) ? 1 : -1)


                let unitcountersee = 0
                let buildingsseecount = 0
                let lastseen = {}
                let healthMeter = 999999999
                let epowercount = 0

                for(let d = 1;d<sandmap.players.length;d++){
                const indexer = Math.abs((sandmap.players.indexOf(this) + d)%sandmap.players.length)

                for (let t = 0; t < sandmap.players[indexer].buildings.length; t++) {
                    if (this.blocks[sandmap.players[indexer].buildings[t].tile.t][sandmap.players[indexer].buildings[t].tile.k].markdraw == 1) { //can see this unit
                        buildingsseecount++
                        if (healthMeter > sandmap.players[indexer].buildings[t].health) {
                            lastseen = sandmap.blocks[sandmap.players[indexer].buildings[t].tile.t][sandmap.players[indexer].buildings[t].tile.k]
                        }
                    }
                }

                for (let t = 0; t < sandmap.players[indexer].units.length; t++) {
                    if (this.blocks[sandmap.players[indexer].units[t].tile.t][sandmap.players[indexer].units[t].tile.k].markdraw == 1) {//can see this building
                        unitcountersee++
                        if (healthMeter > sandmap.players[indexer].units[t].health) {
                            healthMeter = sandmap.players[indexer].units[t].health
                            lastseen = sandmap.blocks[sandmap.players[indexer].units[t].tile.t][sandmap.players[indexer].units[t].tile.k]
                        }
                        epowercount += sandmap.players[indexer].units[t].health //add up their health (not super fair to players, as they only get the healthbar graphic)
                    }
                }
            }
                let powercount = 0
                for (let t = 0; t < this.units.length; t++) {
                    if ((unitcountersee > 0 || buildingsseecount > 0) && (this.units[t].health > 400)) { //calculate strength of current army
                        if ((this.units[t].health > this.units[t].maxhealth * .25)) {
                            // if (!(this.units[t].defendsplatter > 0)) {
                            powercount += this.units[t].health
                            // }
                        }
                    }
                }

                if (this.units.length > 0) {
                    for (let t = 0; t < this.units.length; t++) {
                        if ((unitcountersee > 0 || buildingsseecount > 0) && (this.units[t].health > 400)) {
                            if ((this.units[t].health > this.units[t].maxhealth * .25)) {
                                if (!(this.units[t].defendsplatter > 0)) {
                                    // if(!(this.units[t].isInRange(this.units[t].attacktarget && this.units[t].attacktarget.health > 0))){
                                    if (epowercount <= powercount) {
                                        let gj = 0
                                        while (lastseen.walkable == false) {
                                            if (gj > 100) {
                                                break
                                            }
                                            lastseen = sandmap.blocks[Math.min(Math.max(lastseen.t - (Math.sign(Math.random() - .5)), 0), worldscale - 1)][Math.min(Math.max(lastseen.k - (Math.sign(Math.random() - .5)), 0), worldscale - 1)]
                                        }
                                        this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - lastseen.t) + Math.abs(this.units[t].tile.k - lastseen.k)) * this.units[t].movespeed * .5
                                        this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - lastseen.t) + Math.abs(this.units[t].tile.k - lastseen.k)) * this.units[t].movespeed) * 1
                                        this.units[t].ultrabreak = lastseen
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                        this.units[t].defendsplatter = this.units[t].movespeed * 9 //prevent spam
                                    } else {
                                        this.units[t].defendsplatter--
                                    }
                                    // }
                                } else {
                                    this.units[t].defendsplatter--
                                }
                            } else {
                                this.units[t].defendsplatter--
                            }
                        } else {
                            this.units[t].defendsplatter--
                        }
                    }
                }

                for (let t = 0; t < this.units.length; t++) {
                    this.units[t].smartAttack()
                }



            } else {
                return
            }

            if (this.defending >= 1) {

                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].buzzlet == 1) {
                        if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < 300) {
                            if (this.buildings.length < 0) { //lol
                                let block = this.buildings[0].tile
                                // if (this.units[t].hotrockrepathlimit <= 0) {
                                this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * 1.01
                                this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed
                                this.units[t].ultrabreak = block
                                this.units[t].ultrawalk = 0
                                this.units[t].start = this.units[t].tile
                                // }


                            } else {

                                if (Math.abs(this.units[t].tile.x - this.units[t].realPath[this.units[t].realPath.length - 1].x) + Math.abs(this.units[t].tile.y - this.units[t].realPath[this.units[t].realPath.length - 1].y) < (worldscale * .25 * 10)) {
                                    let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                    let u = 0
                                    while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1) || (Math.abs(this.units[t].tile.x - block.x) + Math.abs(this.units[t].tile.y - block.y) < (worldscale * .25 * 10))) && u < 1000) {
                                        u++
                                        block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                    }
                                    // 

                                    // if (this.units[t].hotrockrepathlimit <= 0) {
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * 1.01
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed
                                    this.units[t].ultrabreak = block
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                    // }


                                } else {

                                }

                            }
                        }
                    }
                }
            }
            if (this.defending >= 20) {
                this.defending = 0
                this.defenseforce = 0
                for (let t = 0; t < this.units.length; t++) {
                    // if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < 110) { //16 //80
                    if (this.units[t].buzzlet == 1) {
                    } else if (this.units[t].megagnat == 1) {
                        if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < 400) { //16 //80

                            if (this.units[t].defensepathlimit <= 0) {
                                this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01
                                this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                this.units[t].ultrabreak = this.attackedAt
                                this.units[t].ultrawalk = 0
                                this.units[t].start = this.units[t].tile
                            }
                        }
                    } else {

                        if (this.units[t].defensepathlimit <= 0) {
                            this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01
                            this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                            this.units[t].ultrabreak = this.attackedAt
                            this.units[t].ultrawalk = 0
                            this.units[t].start = this.units[t].tile
                        }
                    }
                    // }
                }
            }
            for (let t = 0; t < this.units.length; t++) {
                if (!(this.units[t].attacksplatter > 0)) {
                    this.units[t].attacksplatter = this.units[t].firerate
                    this.units[t].attackmove()
                } else {
                    this.units[t].attacksplatter--
                }
            }


            this.workercount = 0
            this.buzzcount = 0
            for (let t = 0; t < this.units.length; t++) {
                if (this.units[t].buzzlet == 1) {
                    this.workercount++
                    this.buzzcount++
                }
                if (this.units[t].megagnat == 1) {
                    this.workercount++
                }
            }

            this.eggcount = 0
            this.moundcount = 0
            for (let t = 0; t < this.buildings.length; t++) {
                if (this.buildings[t].egg == 1) {
                    if (this.buildings[t].que != 1) {
                        this.eggcount++
                    }
                } else {
                    this.moundcount++
                }
            }



            if (this.chunk % this.clickrate == 0 || Math.random() < .03) {
                for (let t = 0; t < this.buildings.length; t++) {
                    if (this.buzzcount == 0) {
                        if (this.buildings[t].egg == 1) {
                            this.buildings[t].hatchBuzzlet()
                        }
                    }
                    if (this.eggcount > this.moundcount + 2 && this.buzzcount / this.units.length < .15) {
                        if (this.buildings[t].egg == 1) {
                            this.buildings[t].hatchBuzzlet()
                        }
                    }
                    if (this.buildings[t].egg == 1) {
                        if (this.workercount < this.units.length * (1 - (this.units.length / unitcap))) {
                            if (this.workercount < 5) {
                                this.buildings[t].hatchBuzzlet()
                            } else {
                                if (this.eggcount > 1) {
                                    this.buildings[t].hatchBuzzlet()
                                } else {
                                    this.buildings[t].hatchMegagnat()
                                }
                            }
                        } else {
                            if (this.flugflop != 1) {
                                this.flugflop = 1
                                this.buildings[t].hatchFlugoon()
                            } else {
                                this.flugflop = 0
                                this.buildings[t].hatchStarbatross()
                            }
                        }
                    }
                }
            }


            let tpos = 0
            let kpos = 0

            for (let t = 0; t < this.units.length; t++) {
                tpos += this.units[t].tile.t
                kpos += this.units[t].tile.k
            }
            tpos = Math.max(Math.min(Math.round(tpos / 3), (worldscale - 4)), 0)
            kpos = Math.max(Math.min(Math.round(kpos / 3), (worldscale - 4)), 0)

            let tile = sandmap.blocks[tpos][kpos]
            if (tile.occupied == true) {
                if (kpos < (worldscale - 4)) {
                    tile = sandmap.blocks[tpos][kpos + 1]
                } else {
                    if (tpos < (worldscale - 4)) {
                        tile = sandmap.blocks[tpos + 1][kpos]
                    }
                }
            }

            if (this.eggcount == 0) {
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].realPath.length - 1 == this.units[t].index) {
                        if ((this.racks !== 1 && this.hotrock > 340)) { //400
                            if (Math.random() < .5) {
                                if (Math.random() < .5) {
                                    this.buildMound(sandmap.blocks[Math.max(this.units[t].tile.t - 3, 0)][this.units[t].tile.k])
                                } else {
                                    this.buildMound(sandmap.blocks[Math.min(this.units[t].tile.t + 3, (worldscale - 1))][this.units[t].tile.k])
                                }
                            } else {
                                if (Math.random() < .5) {
                                    this.buildMound(sandmap.blocks[this.units[t].tile.t][Math.min(this.units[t].tile.k + 3, (worldscale - 1))])
                                } else {
                                    this.buildMound(sandmap.blocks[this.units[t].tile.t][Math.max(this.units[t].tile.k - 3, 0)])
                                }
                            }
                            break
                        }
                    }
                }
            }





            if (this.chunk % this.clickrate == 0) {
                for (let t = 0; t < this.units.length; t++) {
                    index = -1
                    if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {

                        if (this.units[t].hotrockrepathlimit <= 0) {
                            let max = 999999999
                            let drytrack = 0
                            for (let h = 0; h < sandmap.hotrocks.length; h++) {
                                if (sandmap.hotrocks[h].walkable == true && sandmap.hotrocks[h].occupied == false && this.blocks[sandmap.hotrocks[h].t][sandmap.hotrocks[h].k].markdraw == 1) {
                                    const link = (new LineOP(this.units[t].tile, sandmap.hotrocks[h])).hypotenuse()
                                    if (link < max) {
                                        max = link
                                        index = h
                                        if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                                        } else {
                                            this.units[t].ultrabreak = sandmap.hotrocks[index]
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            drytrack = Math.floor((this.units[t].movespeed + 1) * (max * .1))
                                        }
                                    }
                                }
                            }
                            if (drytrack != 0) {
                                this.units[t].hotrockrepathlimit = drytrack
                            }
                        }
                    }
                }
            }


            for (let t = 0; t < this.units.length; t++) {
                if (this.units.length >= this.seenrocks.length - 3 && (this.units[t].health / this.units[t].maxhealth) > .3) {
                    if (this.units[t].buzzlet == 1) {
                        if (this.units[t].defensepathlimit <= 0) {
                            let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                            let u = 0
                            while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                u++
                                block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                            }
                            this.units[t].ultrabreak = block
                            this.units[t].ultrawalk = 0
                            this.units[t].start = this.units[t].tile
                            let dlockdi = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k))
                            this.units[t].hotrockrepathlimit = Math.max(dlockdi, 15) * (this.units[t].movespeed)
                            this.units[t].defensepathlimit = (this.units[t].movespeed) * (worldscale * .05)
                        }
                    } else {
                        if (this.units[t].defensepathlimit <= 0) {
                            if (this.units[t].hotrockrepathlimit <= 0) {
                                if (this.units[t].tile.sourcerock <= 0) {
                                    let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                    let u = 0
                                    while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                        u++
                                        block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                    }
                                    this.units[t].ultrabreak = block
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                    let dlockdi = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k))
                                    this.units[t].hotrockrepathlimit = Math.max(dlockdi, 15) * (this.units[t].movespeed)
                                    this.units[t].defensepathlimit = (this.units[t].movespeed) * (worldscale * .05)
                                }
                            }
                        }
                    }
                }
            }


        }
        avesectianAI() {

            if (this.defending >= 20) {
                this.defending = 0
                this.defenseforce = 0
                for (let t = 0; t < this.units.length; t++) {
                    // if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < 110) { //16 //80
                    if (this.units[t].buzzlet == 1 || this.units[t].megagnat == 1) {
                        if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < 400) { //16 //80

                            if (this.units[t].defensepathlimit <= 0) {
                                this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01
                                this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                this.units[t].ultrabreak = this.attackedAt
                                this.units[t].ultrawalk = 0
                                this.units[t].start = this.units[t].tile
                            }
                        }
                    } else {

                        if (this.units[t].defensepathlimit <= 0) {
                            this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01
                            this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                            this.units[t].ultrabreak = this.attackedAt
                            this.units[t].ultrawalk = 0
                            this.units[t].start = this.units[t].tile
                        }
                    }
                    // }
                }
            }
            if (Math.random() < .01) {
                for (let t = 0; t < this.units.length; t++) {
                    if (!(this.units[t].attacksplatter > 0)) {
                        this.units[t].attacksplatter = this.units[t].movespeed
                        this.units[t].attackmove()
                    } else {
                        this.units[t].attacksplatter--
                    }
                }
            }
            this.chunk++
            let index = -1
            let j = 0


            let workercount = 0
            for (let t = 0; t < this.units.length; t++) {
                if (this.units[t].buzzlet == 1) {
                    workercount++
                }
                if (this.units[t].megagnat == 1) {
                    workercount++
                }
            }



            if (this.chunk % this.clickrate == 0 || Math.random() < .03) {
                for (let t = 0; t < this.buildings.length; t++) {

                    if (workercount < 5) {
                        if (this.buildings[t].egg == 1) {
                            if (Math.random() < .01) {
                                if (this.hotrock > 60) {
                                    this.buildings[t].hatchBuzzlet()
                                }
                            }
                            if (Math.random() < .001) {
                                if (this.hotrock > 140) {
                                    this.buildings[t].hatchMegagnat()
                                }
                            }
                        }
                    } else {

                        if (this.buildings[t].egg == 1) {
                            if (workercount <= (unitcap * .3)) {
                                if (Math.random() < .005) {
                                    if (this.hotrock > 60) {
                                        this.buildings[t].hatchBuzzlet()
                                    }
                                }
                                if (Math.random() < .01) {
                                    if (this.hotrock > 140) {
                                        this.buildings[t].hatchMegagnat()
                                    }
                                }
                                if (Math.random() < .0013) {
                                    if (this.hotrock > 240) {
                                        this.buildings[t].hatchStarbatross()
                                    }
                                }
                                if (Math.random() < .0013) {
                                    if (this.hotrock > 240) {
                                        this.buildings[t].hatchFlugoon()
                                    }
                                }

                            } else {

                                if (Math.random() < .05) {
                                    if (this.hotrock > 140) {
                                        this.buildings[t].hatchMegagnat()
                                    }
                                }
                                if (Math.random() < .03) {
                                    if (this.hotrock > 240) {
                                        this.buildings[t].hatchStarbatross()
                                    }
                                }
                                if (Math.random() < .03) {
                                    if (this.hotrock > 240) {
                                        this.buildings[t].hatchFlugoon()
                                    }
                                }
                            }
                        }
                    }
                }
            }

            let tpos = 0
            let kpos = 0

            for (let t = 0; t < this.units.length; t++) {
                tpos += this.units[t].tile.t
                kpos += this.units[t].tile.k
            }
            tpos = Math.max(Math.min(Math.round(tpos / 3), (worldscale - 4)), 0)
            kpos = Math.max(Math.min(Math.round(kpos / 3), (worldscale - 4)), 0)

            let tile = sandmap.blocks[tpos][kpos]
            if (tile.occupied == true) {
                if (kpos < (worldscale - 4)) {
                    tile = sandmap.blocks[tpos][kpos + 1]
                } else {
                    if (tpos < (worldscale - 4)) {
                        tile = sandmap.blocks[tpos + 1][kpos]
                    }
                }
            }

            // let count = 3
            // for (let t = 0; t < this.units.length; t++) {
            //     const link = new LineOP(this.units[t].tile, tile)
            //     if (((this.hotrock >= 380) && link.hypotenuse() <= 500)) { //975
            //         count++
            //     }
            // }
            for (let t = 0; t < this.units.length; t++) {
                if (this.units[t].realPath.length - 1 == this.units[t].index) {
                    if ((this.racks !== 1 && this.hotrock > 340)) { //400
                        if (Math.random() < .5) {
                            if (Math.random() < .5) {
                                this.buildMound(sandmap.blocks[Math.max(this.units[t].tile.t - 3, 0)][this.units[t].tile.k])
                            } else {
                                this.buildMound(sandmap.blocks[Math.min(this.units[t].tile.t + 3, (worldscale - 1))][this.units[t].tile.k])
                            }
                        } else {
                            if (Math.random() < .5) {
                                this.buildMound(sandmap.blocks[this.units[t].tile.t][Math.min(this.units[t].tile.k + 3, (worldscale - 1))])
                            } else {
                                this.buildMound(sandmap.blocks[this.units[t].tile.t][Math.max(this.units[t].tile.k - 3, 0)])
                            }
                        }
                        break
                    }
                }
            }





            if (this.chunk % this.clickrate == 0) {
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units.length >= this.seenrocks.length - 1 && this.units.length > 3) {
                        if (Math.random() < ((1 / this.units.length) / 40) * this.clickrate) {
                            // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]

                            let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                            let u = 0
                            while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                u++
                                block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                            }
                            // 

                            if (this.units[t].hotrockrepathlimit <= 0) {
                                this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * 1.01
                                this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed
                                this.units[t].ultrabreak = block
                                this.units[t].ultrawalk = 0
                                this.units[t].start = this.units[t].tile
                            }

                        }
                    }



                    if (this.units[t].realPath.length - 1 == this.units[t].index) { //} || this.units[t].realPath[this.units[t].index].walkable !== true) {
                        if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {
                            let max = 999999999
                            for (let h = 0; h < sandmap.hotrocks.length; h++) {
                                if (sandmap.hotrocks[h].walkable == true && sandmap.hotrocks[h].occupied == false && this.blocks[sandmap.hotrocks[h].t][sandmap.hotrocks[h].k].markdraw == 1) {
                                    const link = (new LineOP(this.units[t].tile, sandmap.hotrocks[h])).hypotenuse()
                                    // //////////console.log(link)
                                    if (link < max) {
                                        max = link
                                        index = h
                                    }
                                }
                            }

                            if (typeof sandmap.hotrocks[index] !== "undefined") {
                                if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {

                                } else {
                                    j++

                                    this.units[t].ultrabreak = sandmap.hotrocks[index]
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                    if (j > 11) { //6
                                        break
                                    }
                                }
                            } else {
                                if (Math.random() < (1 / this.units.length)) {
                                    if (this.seen.length > 0) {
                                        const block = this.seen[this.seen.length - 1]
                                        if (block.occupied == true) {
                                            const blockbackup = this.seen[(Math.floor(this.seen.length * Math.random()))]
                                            // 

                                            this.units[t].ultrabreak = blockbackup
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                        } else {
                                            // 
                                            this.units[t].ultrabreak = block
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                        }
                                    }
                                }
                            }
                        }
                    } else if (this.units[t].realPath.length > this.units[t].index) {
                        if (this.units[t].realPath[this.units[t].index + 1].walkable !== true) {
                            if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {
                                let max = 999999999
                                for (let h = 0; h < sandmap.hotrocks.length; h++) {
                                    if (sandmap.hotrocks[h].walkable == true && sandmap.hotrocks[h].occupied == false && this.blocks[sandmap.hotrocks[h].t][sandmap.hotrocks[h].k].markdraw == 1) {
                                        const link = (new LineOP(this.units[t].tile, sandmap.hotrocks[h])).hypotenuse()
                                        // //////////console.log(link)
                                        if (link < max) {
                                            max = link
                                            index = h
                                        }
                                    }
                                }

                                if (index < 0 || sandmap.hotrocks.length - 1 < index) {
                                    if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {

                                    } else {
                                        j++
                                        this.units[t].ultrabreak = sandmap.hotrocks[index]
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile

                                        if (j > 11) { //6
                                            break
                                        }
                                    }
                                } else {
                                    if (Math.random() < .03) {
                                        if (this.seen.length > 0) {
                                            const block = this.seen[this.seen.length - 1]
                                            if (block.occupied == true) {
                                                const blockbackup = this.seen[(Math.floor(this.seen.length * Math.random()))]


                                                this.units[t].ultrabreak = blockbackup
                                                this.units[t].ultrawalk = 0
                                                this.units[t].start = this.units[t].tile
                                            } else {

                                                this.units[t].ultrabreak = block
                                                this.units[t].ultrawalk = 0
                                                this.units[t].start = this.units[t].tile
                                            }
                                        }
                                    } else {
                                        if (true) {
                                            if (true) { //.01
                                                // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]

                                                let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                                let u = 0
                                                while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                                    u++
                                                    block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                                }

                                                this.units[t].ultrabreak = block
                                                this.units[t].ultrawalk = 0
                                                this.units[t].start = this.units[t].tile
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }




        }
        plaztiliteAI() {

            if (Math.random() < .01) {
                for (let t = 0; t < this.units.length; t++) {

                    if (!(this.units[t].attacksplatter > 0)) {
                        if (Math.random() < .9) {
                            //this.units[t].attackmoveunit()
                            //test case 123456
                            this.units[t].attackmove()
                            this.units[t].attacksplatter = this.units[t].movespeed
                        } else {
                            this.units[t].attackmove()
                            this.units[t].attacksplatter = this.units[t].movespeed
                        }
                    } else {

                        this.units[t].attacksplatter--
                    }
                }
            }
            if ((this.units.length * 2 > this.racksflag) || this.hotrock * .0037 > this.racksflag) {
                if (this.racks > 0) {
                    this.racksflag += 17 //8 //17
                }
                this.racks = 0
            }


            this.chunk++
            let index = -1
            let j = 0
            if (this.chunk % this.clickrate == 0) {

                if (this.hotrock >= 10) {

                    let wet = 0
                    for (let t = this.buildings.length - 1; t >= 0; t--) {
                        if (this.buildings[t].sporeball == 1) {
                            if (this.racks == 1) {
                                wet = 1
                            }

                            let max = 999999999999
                            let slimetarget = this.buildings[t].tile

                            for (let k = 0; k < this.seenrocks.length; k++) {
                                if (this.seenrocks[k].slime == false || this.seenrocks[k].primed != 1) {
                                    const dis = (new LineOP(this.buildings[t].tile, this.seenrocks[k])).hypotenuse()
                                    if (dis < max && !this.seenrocks[k].breaker.includes(t)) {
                                        max = dis
                                        slimetarget = this.seenrocks[k]
                                    }
                                }

                            }
                            // for(let k = 0;k<this.seenrocks.length;k++){
                            // if(slimetarget.primed == 1){
                            //     continue
                            // }
                            if (slimetarget.breaker.includes(t)) {
                                //////////console.log("what")
                                // if(Math.random()<.01){
                                //     slimetarget.breaker.splice(slimetarget.breaker.indexOf(t), 1)
                                // }
                                // if(t > 0){
                                //     t--
                                // }
                                // continue
                            } else if (Math.abs(slimetarget.t - this.buildings[t].tile.t) + Math.abs(slimetarget.k - this.buildings[t].tile.k) > 400) {//cost to build new sporeball and change //1000
                                //////////console.log("huh")

                                for (let g = this.buildings.length - 1; g >= 0; g--) {
                                    if (this.buildings[g].sporeball == 1) {
                                        this.racks = 1
                                        wet = 1
                                    }
                                }
                                if (wet == 0 && this.hotrock < 400) {
                                    if (Math.random() < .001 || (this.hotrock > 400 && Math.random() < .01)) {
                                        if (slimetarget.primed != 1) {
                                            if (Math.random() < .5) {
                                                if (Math.random() < .5) {
                                                    //////////console.log("ball")
                                                    this.buildBarracks(sandmap.blocks[slimetarget.t][slimetarget.k + 1])
                                                    //////////console.log("case A")
                                                } else {
                                                    //////////console.log("ball")
                                                    this.buildBarracks(sandmap.blocks[slimetarget.t][slimetarget.k - 1])
                                                    //////////console.log("case B")
                                                }
                                            } else {
                                                if (Math.random() < .5) {
                                                    //////////console.log("ball")
                                                    this.buildBarracks(sandmap.blocks[slimetarget.t + 1][slimetarget.k])
                                                    //////////console.log("case C")
                                                } else {
                                                    //////////console.log("ball")
                                                    this.buildBarracks(sandmap.blocks[slimetarget.t - 1][slimetarget.k])
                                                    //////////console.log("case D")
                                                }

                                            }
                                        }
                                    }
                                }
                                slimetarget.breaker.push(t)
                                // if(t > 0){
                                //     // t--
                                // }
                                // continue
                            }

                            if ((slimetarget.builtOn == 0) || slimetarget.primed != 1 && (slimetarget.occupant.faction.id == -1 || slimetarget.occupant.faction.id == this.id)) { // && slimetarget.occupied == false){ //wow primed is a big diff
                                this.path = []
                                this.pather = slimemakingastar
                                sandmap.diagonal = false
                                this.path = [...this.pather.search(sandmap, this.buildings[t].tile, slimetarget, {}, this.seen)]
                                sandmap.diagonal = true
                                if (this.path.length > 0) {
                                    let discount = 0
                                    for (let p = 0; p < this.path.length; p++) {
                                        if (this.path[p].slime == true) {
                                            discount -= 5
                                        }
                                    }
                                    if (((this.path.length * 5) + discount) <= this.hotrock && ((this.path.length * 5) + discount) < 170) {//} &&  ((this.path.length*5)+discount) > 0){ //cost to build new sporeball // no free paths
                                        for (let p = 0; p < this.path.length; p++) {
                                            this.buildWall(this.path[p])
                                        }
                                        // break
                                    } else if (((this.path.length * 2) + discount) >= 170) {
                                        // for(let p = 0;p<this.path.length;p++){
                                        //     if(p%2 ==0){
                                        //         this.buildWall(this.path[p])
                                        //     }
                                        // }
                                        // //////////console.log((this.path.length*5), discount)
                                        if (Math.random() < .01) {
                                            //////////console.log("length ball")

                                            for (let g = this.buildings.length - 1; g >= 0; g--) {
                                                if (this.buildings[g].sporeball == 1) {
                                                    this.racks = 1
                                                    wet = 1
                                                }
                                            }
                                            if (wet == 0) {
                                                this.buildBarracks(this.path[(this.path.length - 2)])
                                                //////////console.log("case E")
                                            }
                                        }
                                        // if(t > 0){
                                        //     // t--
                                        // }
                                        // break
                                    }
                                }
                            }
                            // }
                        }
                    }


                    for (let g = this.buildings.length - 1; g >= 0; g--) {
                        if (this.buildings[g].sporeball == 1) {
                            this.racks = 1
                            wet = 1
                        }
                    }
                    if (wet == 0) {
                        if (this.seenrocks.length > 0) {
                            const slimetarget = this.seenrocks[Math.floor(Math.random() * this.seenrocks.length)]

                            if (Math.random() < .5) {
                                if (Math.random() < .5) {
                                    //////////console.log("ball")
                                    this.buildBarracks(sandmap.blocks[slimetarget.t][slimetarget.k + 1])
                                    //////////console.log("case A")
                                } else {
                                    //////////console.log("ball")
                                    this.buildBarracks(sandmap.blocks[slimetarget.t][slimetarget.k - 1])
                                    //////////console.log("case B")
                                }
                            } else {
                                if (Math.random() < .5) {
                                    //////////console.log("ball")
                                    this.buildBarracks(sandmap.blocks[slimetarget.t + 1][slimetarget.k])
                                    //////////console.log("case C")
                                } else {
                                    //////////console.log("ball")
                                    this.buildBarracks(sandmap.blocks[slimetarget.t - 1][slimetarget.k])
                                    //////////console.log("case D")
                                }

                            }


                            //////////console.log("solo ball")
                            // this.buildBarracks(this.seenrocks[Math.floor(Math.random() * this.seen.length)])
                            //////////console.log("case F")
                        }
                    }


                }


                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].hotrockrepathlimit <= 0) {
                        if (this.seenrocks.length <= this.units.length) {
                            if (this.units[t].fruiting == 1) { //lmao pollinator
                                if (Math.random() < .05) { //.5
                                    // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]

                                    let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                    let u = 0
                                    while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                        u++
                                        block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                    }
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * 1.01
                                    this.units[t].ultrabreak = block
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }
                            }
                        } else {
                            if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {
                                if (Math.random() < .05) { //.5
                                    if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                                    } else {
                                        // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                        let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                        let u = 0
                                        while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                            u++
                                            block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                        }

                                        this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * 1.01
                                        this.units[t].ultrabreak = block
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                    }
                                }
                            }
                        }
                    }
                }

                for (let t = 0; t < this.units.length; t++) {

                    index = -1
                    // if (this.units[t].realPath.length - 1 == this.units[t].index) { //} || this.units[t].realPath[this.units[t].index].walkable !== true) {
                    if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {

                        if (this.units[t].hotrockrepathlimit <= 0) {
                            let max = 999999999
                            let drytrack = 0
                            for (let h = 0; h < sandmap.hotrocks.length; h++) {
                                if (sandmap.hotrocks[h].walkable == true && sandmap.hotrocks[h].occupied == false && this.blocks[sandmap.hotrocks[h].t][sandmap.hotrocks[h].k].markdraw == 1) {
                                    const link = (new LineOP(this.units[t].tile, sandmap.hotrocks[h])).hypotenuse()
                                    // //////////console.log(link)
                                    if (link < max) {
                                        max = link
                                        index = h
                                        if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                                        } else {

                                            this.units[t].ultrabreak = sandmap.hotrocks[index]
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            drytrack = Math.floor((this.units[t].movespeed + 1) * (max * .1))
                                        }
                                    }
                                }
                            }
                            if (drytrack != 0) {
                                this.units[t].hotrockrepathlimit = drytrack
                            }
                        }
                    }
                }
            }


            if (this.defending >= 5) {
                this.defending = 0
                this.defenseforce = 1
                if (this.defenseforce > 0) {
                    // //////////console.log(this.buildings, "bef")
                    this.buildings.sort((a, b) => ((new LineOP(a.tile, this.attackedAt).hypotenuse()) < (new LineOP(b.tile, this.attackedAt)).hypotenuse()) ? 1 : -1)
                    // //////////console.log(this.buildings, "ant")


                    for (let t = this.buildings.length - 1; t > 0; t--) { //reversal for prox
                        if (this.buildings[t].slime == 1) {
                            if (Math.random() < .5) {
                                if (this.hotrock > 95 && Math.random() < .7) {
                                    this.buildings[t].makeSporeseer()
                                } else {
                                    this.buildings[t].makeVizier()
                                }
                            } else {
                                if (Math.random() < .5) {
                                    if (Math.random() < .5) {
                                        if (Math.random() < .5) {
                                            if (Math.random() < .5) {
                                                if (this.hotrock > 65) {
                                                    this.buildings[t].makeFruitingbuddy()
                                                }
                                            } else {
                                                if (Math.random() < .5) {
                                                    if (this.hotrock > 95 && Math.random() < .7) {
                                                        this.buildings[t].makeSporeseer()
                                                    } else {
                                                        this.buildings[t].makeVizier()
                                                    }
                                                } else {
                                                    if (this.hotrock > 355) {
                                                        this.buildings[t].makeMycoknight()
                                                    }
                                                }
                                            }
                                        } else {
                                            if (Math.random() < .5) {
                                                if (this.hotrock > 95 && Math.random() < .7) {
                                                    this.buildings[t].makeSporeseer()
                                                } else {
                                                    this.buildings[t].makeVizier()
                                                }
                                            } else {
                                                if (this.hotrock > 355) {
                                                    this.buildings[t].makeMycoknight()
                                                }
                                            }
                                        }
                                    } else {
                                        if (Math.random() < .5) {
                                            if (this.hotrock > 95 && Math.random() < .7) {
                                                this.buildings[t].makeSporeseer()
                                            } else {
                                                this.buildings[t].makeVizier()
                                            }
                                        } else {
                                            if (this.hotrock > 355) {
                                                this.buildings[t].makeMycoknight()
                                            }
                                        }
                                    }
                                } else {
                                    if (this.hotrock > 355) {
                                        this.buildings[t].makeMycoknight()
                                    }
                                }
                            }
                        }
                    }
                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].fruiting == 1) {
                            if (Math.random() < 7 / this.defenseforce) { //2
                                if (this.units[t].defensepathlimit <= 0) {
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                    this.units[t].ultrabreak = this.attackedAt
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }
                            }
                        }

                        if (this.units[t].mycoknight == 1) {
                            if (Math.random() < 7 / this.defenseforce) { //2
                                if (this.units[t].defensepathlimit <= 0) {
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                    this.units[t].ultrabreak = this.attackedAt
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }
                            }
                        }

                        if (this.units[t].seer == 1) {
                            if (Math.random() < 7 / this.defenseforce) { //2
                                if (this.units[t].defensepathlimit <= 0) {
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                    this.units[t].ultrabreak = this.attackedAt
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }
                            }
                        }
                        if (this.units[t].sporevizir == 1) { //was busted
                            if (Math.random() < 7 / this.defenseforce) { //2
                                if (this.units[t].index == this.units[t].realPath.length - 1) {

                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                    this.units[t].ultrabreak = this.attackedAt
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }
                            }
                        }
                    }
                } else {

                }
            } else {
                let j = 0
                if (Math.random() < (.000095 * this.clickrate * this.hotrock)) { //holy wowie, this was a comma //25 _9
                    for (let t = this.buildings.length - 1; t > 0; t--) { //reversal for prox
                        if (this.buildings[t].slime == 1) {
                            if (Math.random() < 3 / this.buildings.length) {  //.5
                                //////////console.log(this.seenrocks.length, this.units.length)
                                if ((this.hotrock > 70 + (this.buildings.length * 5) || this.seenrocks.length <= this.units.length) && (Math.random() < (3 / this.units.length))) {
                                    this.buildings[t].makeFruitingbuddy()
                                    j++
                                    if (j > 5) { //6
                                        break
                                    }
                                    if (Math.random() < .1) {
                                        break
                                    }
                                } else if ((this.hotrock > 80 + (this.buildings.length * 2) || this.seenrocks.length <= this.units.length) && (Math.random() < (17 / this.units.length))) {
                                    if (Math.random() < 3 / this.buildings.length) {  //.5
                                        this.buildings[t].makeSporeseer()
                                        j++
                                        if (j > 5) { //6
                                            break
                                        }
                                    } else {

                                        if (Math.random() < 3 / this.buildings.length) {  //.5
                                            this.buildings[t].makeVizier()
                                        }
                                        j++
                                        if (j > 5) { //6
                                            break
                                        }
                                    }
                                    if (Math.random() < .1) {
                                        break
                                    }
                                } else if ((this.hotrock > 180 + (this.buildings.length * 1) || this.seenrocks.length <= this.units.length) && (Math.random() < (50 / this.units.length))) {

                                    this.buildings[t].makeMycoknight()
                                    j++
                                    if (j > 5) { //6
                                        break
                                    }

                                }
                            }
                        }
                    }
                }
            }




        }

        async alternatePlaztiliteAI() {

            for (let t = 0; t < this.units.length; t++) {
                if (!(this.units[t].attacksplatter > 0)) {
                    this.units[t].attackmove()
                    this.units[t].attacksplatter = this.units[t].movespeed
                } else {
                    this.units[t].attacksplatter--
                }
            }
            if ((this.units.length * 2 > this.racksflag) || this.hotrock * .0037 > this.racksflag) {
                if (this.racks > 0) {
                    this.racksflag += 17 //8 //17
                }
                this.racks = 0
            }


            this.chunk++
            let index = -1
            let j = 0
            if (this.chunk % this.clickrate == 0) {
                for (let t = 0; t < this.units.length; t++) {
                    this.units[t].smartAttack()
                }

                //this.units.sort((a, b) => (Math.random() > .5) ? 1 : -1)
                if (this.hotrock >= 10) {

                    let wet = 0
                    let sporestep = 0

                    for (let g = this.buildings.length - 1; g >= 0; g--) {
                        if (this.buildings[g].sporeball == 1) {
                            this.racks = 1
                            if (Math.random() < .1) {
                                wet = 1
                            }
                        }
                    }

                    this.seriouslystop = 0
                    for (let t = this.buildings.length - 1; t >= 0; t--) {
                        if (this.seriouslystop == 1) {
                            break
                        }
                        if (sporestep > 2) {
                            break
                        }
                        if (this.buildings[t].sporeball == 1 && sporestep <= 2) {
                            if (this.racks == 1) {
                                if (Math.random() < .1) {
                                    wet = 1
                                }
                            }
                            let max = 999999999999
                            for (let t = 0; t < this.seenrocks.length; t++) {

                            }
                            // this.seenrocks[Math.floor(this.seenrocks.length*Math.random())]  //this.buildings[t].tile


                            let slimetarget = {}
                            let link = new LineOP(this.buildings[t].tile, {})
                            for (let t = 0; t < this.seenrocks.length; t++) {
                                link.target = this.seenrocks[t]
                                let dis = link.hypotenuse()
                                if (this.seenrocks[t].sourcerock > 0) {
                                    if (dis < max) {
                                        max = dis
                                        slimetarget = this.seenrocks[t]
                                    }
                                }
                            }
                            let h = 0
                            let i = 0
                            let xcount = 0
                            if (this.seenrocks.length > 0) {
                                if ((slimetarget.occupant.faction.id == -1 || slimetarget.occupant.faction.id == this.id)) {
                                    xcount++
                                }
                                if (!(this.justcapped.tk == `${slimetarget.t}, ${slimetarget.k}`)) {
                                    xcount++
                                }
                                if (!(slimetarget.primed == 1)) {
                                    xcount++
                                }
                                if ((slimetarget.sourcerock > 0)) {
                                    xcount++
                                }
                            }
                            while (xcount < 4) {
                                if (h > this.seenrocks.length) {
                                    break
                                }
                                xcount = 0
                                // //////////console.log(h)
                                i = Math.floor(this.seenrocks.length * Math.random())
                                slimetarget = this.seenrocks[i]
                                h++
                                if ((slimetarget.occupant.faction.id == -1 || slimetarget.occupant.faction.id == this.id)) {
                                    xcount++
                                }
                                if (!(this.justcapped.tk == `${slimetarget.t}, ${slimetarget.k}`)) {
                                    xcount++
                                }
                                if (!(slimetarget.primed == 1)) {
                                    xcount++
                                }
                                if ((slimetarget.sourcerock > 0)) {
                                    xcount++
                                }
                                // if(!(Math.abs(this.buildings[t].tile.t-slimetarget.t) + Math.abs(this.buildings[t].tile.k-slimetarget.k) <= this.hotrock*.19)){
                                //     xcount++
                                // } 

                            }
                            //////////console.log(i)
                            // for (let k = 0; k < this.seenrocks.length; k++) {
                            //     if ( (this.seenrocks[k].occupant.faction.id == -1 ||this.seenrocks[k].occupant.faction.id == this.id) && (this.seenrocks[k].slime == false || this.seenrocks[k].primed != 1)) { //(this.seenrocks[k].slime == false || this.seenrocks[k].primed != 1) &&
                            //         const dis = (new LineOP(this.buildings[t].tile, this.seenrocks[k])).hypotenuse()
                            //         if (dis < max ) { //&& !this.seenrocks[k].breaker.includes(t)
                            //             if(!this.buildings[t].triedRocks.includes(`${this.seenrocks[k].t},${this.seenrocks[k].k}`)){
                            //                 max = dis
                            //                 slimetarget = this.seenrocks[k]
                            //                 this.seenrocks[k].breaker.push(t)
                            //             }
                            //         }
                            //     }

                            // }
                            if (slimetarget.breaker.includes(t)) {
                            } else if (Math.abs(slimetarget.t - this.buildings[t].tile.t) + Math.abs(slimetarget.k - this.buildings[t].tile.k) > (worldscale * .12)) {

                                if (wet == 0 && this.hotrock > 540) {
                                    if (slimetarget.primed != 1) {
                                        if (Math.random() < .5) {
                                            if (Math.random() < .5) {
                                                this.buildBarracks(sandmap.blocks[slimetarget.t][slimetarget.k + 1])
                                            } else {
                                                this.buildBarracks(sandmap.blocks[slimetarget.t][slimetarget.k - 1])
                                            }
                                        } else {
                                            if (Math.random() < .5) {
                                                this.buildBarracks(sandmap.blocks[slimetarget.t + 1][slimetarget.k])
                                            } else {
                                                this.buildBarracks(sandmap.blocks[slimetarget.t - 1][slimetarget.k])
                                            }

                                        }
                                    }
                                    // }
                                }
                                slimetarget.breaker.push(t)
                            }
                            //&& (slimetarget.occupant.faction.id == -1 || slimetarget.occupant.faction.id == this.id)
                            if (h < this.seenrocks.length || h == 1) {

                                if (slimetarget != this.buildings[t].tile) { // && slimetarget.occupied == false){ //wow primed is a big diff //(slimetarget.builtOn == 0) || 
                                    if ((slimetarget.occupant.faction.id == -1 || slimetarget.occupant.faction.id == this.id)) {

                                        this.pather = slimemakingastar
                                        sandmap.diagonal = false
                                        if (Math.abs(this.buildings[t].tile.t - slimetarget.t) + Math.abs(this.buildings[t].tile.k - slimetarget.k) <= this.hotrock * .5 && this.seriouslystop == 0) {
                                            if (this.chunk % (this.clickrate * 10) == 0) {
                                                this.path = await [...this.pather.search(sandmap, this.buildings[t].tile, slimetarget, {}, this)]
                                                this.seriouslystop = 1
                                            } else {
                                                this.path = []
                                            }
                                        } else {
                                            this.path = []
                                        }
                                        sporestep += 10
                                        sandmap.diagonal = true
                                        if (this.path.length > 0) {
                                            //////////console.log(slimetarget.t, slimetarget.k)

                                            let discount = 0
                                            for (let p = 0; p < this.path.length; p++) {
                                                if (this.path[p].slime == true) {
                                                    discount -= 5
                                                }
                                            }

                                            //////////console.log(discount,(this.path.length * 5) + discount)
                                            if (((this.path.length * 5) + discount) == 0) {
                                                // //////////console.log(slimetarget.t, slimetarget.k)
                                                this.buildings[t].triedRocks.push(`${slimetarget.t},${slimetarget.k}`)
                                                // //////////console.log(this.buildings[t].triedRocks)
                                            }
                                            // && ((this.path.length * 5) + discount) < 220
                                            if (((this.path.length * 5) + discount) <= this.hotrock) {//} &&  ((this.path.length*5)+discount) > 0){ //cost to build new sporeball // no free paths
                                                for (let p = 0; p < this.path.length; p++) {
                                                    this.buildWall(this.path[p])
                                                    this.justcapped.tk = `${slimetarget.t}, ${slimetarget.k}`
                                                }
                                                this.buildings[t].triedRocks = []
                                                // break
                                            } else if (((this.path.length * 6) + discount) >= 170) {
                                                // if (Math.random() < .01) {
                                                for (let g = this.buildings.length - 1; g >= 0; g--) {
                                                    if (this.buildings[g].sporeball == 1) {
                                                        this.racks = 1
                                                        if (Math.random() > .7) {
                                                            wet = 1
                                                        }
                                                    }
                                                }
                                                if (wet == 0) {
                                                    this.buildBarracks(this.path[(this.path.length - 2)])
                                                }
                                                // }
                                            }
                                        }

                                    }
                                }
                            }
                        }
                    }


                    for (let g = this.buildings.length - 1; g >= 0; g--) {
                        if (this.buildings[g].sporeball == 1) {
                            this.racks = 1
                            wet = 1
                        }
                    }
                    if (wet == 0) {
                        if (this.seenrocks.length > 0) {
                            const slimetarget = this.seenrocks[Math.floor(Math.random() * this.seenrocks.length)]

                            if (Math.random() < .5) {
                                if (Math.random() < .5) {
                                    this.buildBarracks(sandmap.blocks[slimetarget.t][slimetarget.k + 1])
                                } else {
                                    this.buildBarracks(sandmap.blocks[slimetarget.t][slimetarget.k - 1])
                                }
                            } else {
                                if (Math.random() < .5) {
                                    this.buildBarracks(sandmap.blocks[slimetarget.t + 1][slimetarget.k])
                                } else {
                                    this.buildBarracks(sandmap.blocks[slimetarget.t - 1][slimetarget.k])
                                }

                            }
                        }
                    }


                }


                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].hotrockrepathlimit <= 0) {
                        if (this.seenrocks.length <= this.units.length) {
                            if (this.units[t].fruiting == 1) { //lmao pollinator
                                if (this.units[t].index == this.units[t].realPath.length - 1) { //lmao pollinator
                                    if (Math.random() < .00125 || this.units.length > this.seenrocks.length) { //.5
                                        // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]

                                        let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                        let u = 0
                                        while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                            u++
                                            block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                        }
                                        this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * 1.01
                                        this.units[t].ultrabreak = block
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                    }
                                }
                            }
                        } else {
                            if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {
                                if (Math.random() < .00125 || this.units.length > this.seenrocks.length) { //.5
                                    if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                                    } else {
                                        // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                        let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                        let u = 0
                                        while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                            u++
                                            block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                        }

                                        this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * 1.01
                                        this.units[t].ultrabreak = block
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                    }
                                }
                            }
                        }
                    }
                }

                for (let t = 0; t < this.units.length; t++) {

                    index = -1
                    if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {

                        if (this.units[t].hotrockrepathlimit <= 0) {
                            let max = 999999999
                            let drytrack = 0
                            for (let h = 0; h < sandmap.hotrocks.length; h++) {
                                if (sandmap.hotrocks[h].walkable == true && sandmap.hotrocks[h].occupied == false && this.blocks[sandmap.hotrocks[h].t][sandmap.hotrocks[h].k].markdraw == 1) {
                                    const link = (new LineOP(this.units[t].tile, sandmap.hotrocks[h])).hypotenuse()
                                    if (link < max) {
                                        max = link
                                        index = h
                                        if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                                        } else {

                                            this.units[t].ultrabreak = sandmap.hotrocks[index]
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            drytrack = Math.floor((this.units[t].movespeed + 1) * (max * .4))
                                        }
                                    }
                                }
                            }
                            if (drytrack != 0) {
                                this.units[t].hotrockrepathlimit = drytrack
                            }
                        }
                    }
                }
            }


            if (this.defending >= 5) {
                this.defending = 0
                this.defenseforce = 1
                if (this.defenseforce > 0) {
                    // //////////console.log(this.buildings, "bef")
                    this.buildings.sort((a, b) => ((new LineOP(a.tile, this.attackedAt).hypotenuse()) < (new LineOP(b.tile, this.attackedAt)).hypotenuse()) ? 1 : -1)
                    // //////////console.log(this.buildings, "ant")


                    for (let t = this.buildings.length - 1; t > 0; t--) { //reversal for prox
                        if (this.buildings[t].slime == 1) {
                            if (Math.random() < .5) {
                                if (this.hotrock > 295 && Math.random() < .7) {
                                    this.buildings[t].makeSporeseer()
                                } else {

                                    if (this.hotrock > 275) {
                                        this.buildings[t].makeVizier()
                                    }
                                }
                            } else {
                                if (Math.random() < .5) {
                                    if (Math.random() < .5) {
                                        if (Math.random() < .5) {
                                            if (Math.random() < .5) {
                                                if (this.hotrock > 275) {
                                                    // this.buildings[t].makeFruitingbuddy()

                                                    this.buildings[t].makeMycoknight()
                                                }
                                            } else {
                                                if (Math.random() < .5) {
                                                    if (this.hotrock > 275 && Math.random() < .7) {
                                                        this.buildings[t].makeSporeseer()
                                                    } else {
                                                        if (this.hotrock > 275) {
                                                            this.buildings[t].makeVizier()
                                                        }
                                                    }
                                                } else {
                                                    if (this.hotrock > 355) {
                                                        this.buildings[t].makeMycoknight()
                                                    }
                                                }
                                            }
                                        } else {
                                            if (Math.random() < .5) {
                                                if (this.hotrock > 275 && Math.random() < .7) {
                                                    this.buildings[t].makeSporeseer()
                                                } else {
                                                    if (this.hotrock > 275) {
                                                        this.buildings[t].makeVizier()
                                                    }
                                                }
                                            } else {
                                                if (this.hotrock > 355) {
                                                    this.buildings[t].makeMycoknight()
                                                }
                                            }
                                        }
                                    } else {
                                        if (Math.random() < .5) {
                                            if (this.hotrock > 275 && Math.random() < .7) {
                                                this.buildings[t].makeSporeseer()
                                            } else {
                                                if (this.hotrock > 275) {
                                                    this.buildings[t].makeVizier()
                                                }
                                            }
                                        } else {
                                            if (this.hotrock > 355) {
                                                this.buildings[t].makeMycoknight()
                                            }
                                        }
                                    }
                                } else {
                                    if (this.hotrock > 355) {
                                        this.buildings[t].makeMycoknight()
                                    }
                                }
                            }
                        }
                    }
                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].fruiting == 1) {
                            if (Math.random() < 17 / this.units.length) { //2
                                if (this.units[t].defensepathlimit <= 0) {
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                    this.units[t].ultrabreak = this.attackedAt
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }
                            }
                        }

                        if (this.units[t].mycoknight == 1) {
                            if (Math.random() < 17 / this.units.length) { //2
                                if (this.units[t].defensepathlimit <= 0) {
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                    this.units[t].ultrabreak = this.attackedAt
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }
                            }
                        }

                        if (this.units[t].seer == 1) {
                            if (Math.random() < 17 / this.units.length) { //2
                                if (this.units[t].defensepathlimit <= 0) {
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                    this.units[t].ultrabreak = this.attackedAt
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }
                            }
                        }
                        if (this.units[t].sporevizir == 1) { //was busted
                            if (Math.random() < 17 / this.units.length) { //2
                                if (this.units[t].index == this.units[t].realPath.length - 1) {
                                    if (this.units[t].defensepathlimit <= 0) {
                                        this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01
                                        this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed

                                        this.units[t].ultrabreak = this.attackedAt
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                    }
                                }
                            }
                        }
                    }
                } else {

                }
            } else {
                let j = 0

                let fruitcount = 0

                for (let t = this.units.length - 1; t > 0; t--) {
                    if (this.units[t].fruiting == 1) {
                        fruitcount++
                    }
                }
                for (let t = this.buildings.length - 1; t > 0; t--) { //reversal for prox
                    if (this.buildings[t].slime == 1) {
                        if (this.buildings[t].tile.hotrock >= 1) {
                            if (this.buildings[t].tile.occupied == false) {
                                if (this.units.length < this.seenrocks.length) {
                                    if (this.hotrock > 100) {
                                        if (fruitcount < this.units.length * .35) {
                                            this.buildings[t].makeFruitingbuddy()
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                if ((Math.random() < (.0095 * this.clickrate * this.hotrock)) || this.hotrock > 350) { //holy wowie, this was a comma //25 _9
                    for (let t = this.buildings.length - 1; t > 0; t--) { //reversal for prox
                        if (this.buildings[t].slime == 1) {
                            if (Math.random() < 3 / this.buildings.length || this.hotrock > 450) {  //.5
                                //////////console.log(this.seenrocks.length, this.units.length)
                                if (((this.hotrock > 170 + (this.buildings.length * .5) || this.seenrocks.length <= this.units.length) && (Math.random() < (3 / this.units.length))) || this.hotrock > 550) {
                                    // this.buildings[t].makeFruitingbuddy()

                                    this.buildings[t].makeSporeseer()
                                    j++
                                    if (j > 5) { //6
                                        break
                                    }
                                    if (Math.random() < .1) {
                                        break
                                    }
                                } else if ((this.hotrock > 180 + (this.buildings.length * 2) || this.seenrocks.length <= this.units.length) && (Math.random() < (17 / this.units.length))) {
                                    if (Math.random() < 3 / this.buildings.length) {  //.5
                                        this.buildings[t].makeSporeseer()
                                        j++
                                        if (j > 5) { //6
                                            break
                                        }
                                    } else {
                                        if (this.hotrock > 280) {
                                            if (Math.random() < 3 / this.buildings.length) {  //.5
                                                this.buildings[t].makeVizier()
                                            }
                                        }
                                        j++
                                        if (j > 5) { //6
                                            break
                                        }
                                    }
                                    if (Math.random() < .1) {
                                        break
                                    }
                                } else if ((this.hotrock > 380 + (this.buildings.length * 1) || this.seenrocks.length <= this.units.length) && (Math.random() < (50 / this.units.length))) {

                                    this.buildings[t].makeMycoknight()
                                    j++
                                    if (j > 5) { //6
                                        break
                                    }

                                }
                            }
                        }
                    }
                }
            }




        }
        campaignLibrilbianAI() {

            if (this.defending >= 1) {
                if (this.defending > 1) {
                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].pollinator == 1) {
                            if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < 180) {
                                this.units[t].metamorphpufffellow()
                            }
                        }
                    }
                }
                this.defending = 0
                this.defenseforce = 0
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].pufffellow == 1) {
                        this.defenseforce++
                    }
                    if (this.units[t].podman == 1) {
                        this.defenseforce += 1.5
                    }
                    if (this.units[t].goliophyte == 1) {
                        this.defenseforce += 2
                    }
                }
                if (this.defenseforce > 0) {

                    for (let t = 0; t < this.units.length; t++) {
                        if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < 200) { //14


                            if (this.units[t].defensepathlimit <= 0) {
                                this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01
                                this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                this.units[t].ultrabreak = this.attackedAt
                                this.units[t].ultrawalk = 0
                                this.units[t].start = this.units[t].tile
                            }
                        }
                    }
                } else {

                }
            }

        }
        librilbianAI() {

            this.chunk++
            let index = -1
            let j = 0


            if (this.chunk % this.clickrate == 0) {
                //this.units.sort((a, b) => (Math.random() > .5) ? 1 : -1)
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].pollinator == 1) {
                        if (this.units[t].health <= (this.units[t].maxhealth * .55)) {
                            this.units[t].metamorphpufffellow()
                        }
                    }
                }
            }


            if (Math.random() < .1) { //new
                for (let t = 0; t < this.units.length; t++) {

                    if (!(this.units[t].attacksplatter > 0)) {

                        if (this.units[t].pufffellow == 1) {
                            if (Math.random() < .97) {
                                //this.units[t].attackmoveunit()
                                //test case 123456
                                this.units[t].attackmove()
                                this.units[t].attacksplatter = this.units[t].movespeed
                            } else {
                                this.units[t].attackmove()
                                this.units[t].attacksplatter = this.units[t].movespeed
                            }
                        }
                    } else {
                        this.units[t].attacksplatter--
                    }
                }
            } //end new


            // //////////console.log("adwa",campaignController.mission )


            if (campaignController.mission == 5) {
                //campaign AI   
                // //////////console.log("dwad")
                // //////////console.log("freq")
                if (this.defending >= 1) {
                    // //////////console.log("freq2")
                    if (this.defending > 1) {
                        // //////////console.log("freq3")

                        for (let t = 0; t < this.units.length; t++) {
                            if (this.units[t].pollinator == 1) {
                                // //////////console.log(this.units[t].tile, this.attackedAt)
                                if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < 180) { //44
                                    //////////console.log("hit")
                                    this.units[t].metamorphpufffellow()
                                }
                            }
                        }
                    }
                    this.defending = 0
                    this.defenseforce = 0
                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].pufffellow == 1) {
                            this.defenseforce++
                        }
                        if (this.units[t].podman == 1) {
                            this.defenseforce += 1.5
                        }
                        if (this.units[t].goliophyte == 1) {
                            this.defenseforce += 2
                        }
                    }
                    if (this.defenseforce > 0) {

                        for (let t = 0; t < this.buildings.length; t++) {

                            if (this.buildings[t].bulbplant == 2) {
                                if (Math.random() < .5) {
                                    if (this.hotrock > 140) {
                                        this.buildings[t].makeLibrilbianpodman()
                                    }
                                } else {
                                    if (Math.random() < .5) {
                                        if (Math.random() < .5) {
                                            if (this.hotrock > 140) {
                                                this.buildings[t].makeLibrilbianpodman()
                                            }
                                        } else {
                                            if (Math.random() < .5) {
                                                if (this.hotrock > 95 && Math.random() < .07) { //.7
                                                    this.buildings[t].makeLibrilbianpufffellow()
                                                }
                                            } else {
                                                if (this.hotrock > 355) {
                                                    this.buildings[t].makeLibrilbiangoliophyte()
                                                }
                                            }
                                        }
                                    } else {
                                        if (this.hotrock > 355) {
                                            this.buildings[t].makeLibrilbiangoliophyte()
                                        }
                                    }
                                }
                            }
                        }
                        for (let t = 0; t < this.units.length; t++) {
                            if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < 140) { //14


                                if (this.units[t].podman == 1) {

                                    if (Math.random() < 7 / this.defenseforce) { //2
                                        // if (this.units[t].index == this.units[t].realPath.length - 1) {

                                        if (this.units[t].defensepathlimit <= 0) {
                                            this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01
                                            this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                            this.units[t].ultrabreak = this.attackedAt
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                        }
                                        // }
                                    }
                                }

                                if (this.units[t].goliophyte == 1) {
                                    if (Math.random() < 7 / this.defenseforce) { //2
                                        // if (this.units[t].index == this.units[t].realPath.length - 1) {

                                        if (this.units[t].defensepathlimit <= 0) {
                                            this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01
                                            this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed

                                            this.units[t].ultrabreak = this.attackedAt
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                        }
                                    }
                                }

                                if (this.units[t].pufffellow == 1) {
                                    if (Math.random() < 7 / this.defenseforce) { //2
                                        // if (this.units[t].index == this.units[t].realPath.length - 1) {

                                        if (this.units[t].defensepathlimit <= 0) {
                                            this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01
                                            this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed


                                            this.units[t].ultrabreak = this.attackedAt
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                        }
                                    }
                                }

                            }
                        }
                    } else {

                    }
                }

            } else {

                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].pollinator == 1) {
                        if (this.units.length >= this.seenrocks.length && (this.units[t].health / this.units[t].maxhealth) > .3) { //seen

                            if (this.units[t].hotrockrepathlimit <= 0) {
                                // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                let u = 0
                                while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                    u++
                                    block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                }

                                this.units[t].hotrockrepathlimit = 64 * (this.units[t].movespeed + 1)

                                this.units[t].ultrabreak = block
                                this.units[t].ultrawalk = 0
                                this.units[t].start = this.units[t].tile
                            }
                        }
                    }
                }
                //normal AI
                // //////////console.log(campaignController.mission)
                if (this.defending >= 32) {
                    if (this.defending > 39) {
                        for (let t = 0; t < this.units.length; t++) {
                            if (this.units[t].pollinator == 1) {
                                if (Math.random() < (this.hotrock / 2000)) {
                                    this.units[t].metamorphpufffellow()
                                    if (sandmap.players.indexOf(this) == sandmap.turn) {
                                        if (Math.random() < soundspamdrop) {
                                            soundCancel()
                                            pollinatoraudio.play()
                                        }
                                    }
                                }
                            }
                        }
                    }
                    this.defending = 0
                    this.defenseforce = 0
                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].pufffellow == 1) {
                            this.defenseforce++
                        }
                        if (this.units[t].podman == 1) {
                            this.defenseforce += 1.5
                        }
                        if (this.units[t].goliophyte == 1) {
                            this.defenseforce += 2
                        }
                    }
                    if (this.defenseforce > 0) {

                        for (let t = 0; t < this.buildings.length; t++) {

                            if (this.buildings[t].bulbplant == 2) {
                                if (Math.random() < .5) {
                                    if (this.hotrock > 140) {
                                        this.buildings[t].makeLibrilbianpodman()
                                    }
                                } else {
                                    if (Math.random() < .5) {
                                        if (Math.random() < .5) {
                                            if (this.hotrock > 140) {
                                                this.buildings[t].makeLibrilbianpodman()
                                            }
                                        } else {
                                            if (Math.random() < .5) {
                                                if (this.hotrock > 95 && Math.random() < .07) { //.7
                                                    this.buildings[t].makeLibrilbianpufffellow()
                                                }
                                            } else {
                                                if (this.hotrock > 355) {
                                                    this.buildings[t].makeLibrilbiangoliophyte()
                                                }
                                            }
                                        }
                                    } else {
                                        if (this.hotrock > 355) {
                                            this.buildings[t].makeLibrilbiangoliophyte()
                                        }
                                    }
                                }
                            }
                        }
                        for (let t = 0; t < this.units.length; t++) {
                            if (this.units[t].podman == 1) {
                                if (Math.random() < 7 / this.defenseforce) { //2
                                    // if (this.units[t].index == this.units[t].realPath.length - 1) {

                                    if (this.units[t].defensepathlimit <= 0) {
                                        this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                        this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01

                                        this.units[t].ultrabreak = this.attackedAt
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                    }
                                }
                            }

                            if (this.units[t].goliophyte == 1) {
                                if (Math.random() < 7 / this.defenseforce) { //2
                                    // if (this.units[t].index == this.units[t].realPath.length - 1) {

                                    if (this.units[t].defensepathlimit <= 0) {
                                        this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                        this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01

                                        this.units[t].ultrabreak = this.attackedAt
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                    }
                                }
                            }

                            if (this.units[t].pufffellow == 1) {
                                if (Math.random() < 7 / this.defenseforce) { //2
                                    // if (this.units[t].index == this.units[t].realPath.length - 1) {

                                    if (this.units[t].defensepathlimit <= 0) {
                                        this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                        this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01

                                        this.units[t].ultrabreak = this.attackedAt
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                    }
                                }
                            }
                        }
                    } else {

                    }
                }


            }




            if (this.chunk % this.clickrate == 0) {
                this.workerlength = 0
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].pollinator == 1) {
                        this.workerlength++
                    }
                }
                for (let t = 0; t < this.buildings.length; t++) {
                    if (this.buildings[t].bulbplant == 2) {
                        if (Math.random() < .13) { //5
                            if (this.hotrock > 140) {
                                this.buildings[t].makeLibrilbianpodman()
                            }
                        } else {
                            if (Math.random() < .03) { //.5
                                if (Math.random() < .5) {
                                    if (this.hotrock > 140) {
                                        this.buildings[t].makeLibrilbianpodman()
                                    }
                                } else {
                                    if (Math.random() < .05) { //.5
                                        if (this.hotrock > 95 && Math.random() < .07) {  // 100% //.7
                                            this.buildings[t].makeLibrilbianpufffellow()
                                        }
                                    } else {
                                        if (this.hotrock > 355) {
                                            this.buildings[t].makeLibrilbiangoliophyte()
                                        }
                                    }
                                }
                            } else {
                                if (this.hotrock > 355) {
                                    this.buildings[t].makeLibrilbiangoliophyte()
                                }
                            }
                        }
                    }
                    if (this.buildings[t].bulbplant == 1) {
                        if (this.workerlength <= (unitcap * .3)) { // 8
                            if (this.hotrock > 90) {
                                this.buildings[t].makeLibrilbianpollinator()
                            }
                        }
                    }
                }
            }


            if (this.units.length > this.racksflag || this.hotrock * .0035 > this.racksflag) {
                if (this.racks > 0) {
                    this.racksflag += 5
                }
                if (Math.random() < .4) {
                    this.racks = 0
                }
                this.lab = 0
            }

            let breakbuilding = 0
            for (let t = 0; t < this.buildings.length; t++) {
                if (this.buildings[t].bulbplant == 1) {
                    breakbuilding = 1
                }
            }

            if (this.racks == 0 && (breakbuilding == 0 || Math.random() < .5)) {
                const length = this.buildings.length
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].realPath.length - 1 == this.units[t].index) {
                        // if (this.units[t].suffocating > 0 || (this.racks !== 1 && this.hotrock > 400)) {
                        if (Math.random() < .5) {
                            if (Math.random() < .5) {
                                this.buildBarracks(sandmap.blocks[Math.max(this.units[t].tile.t - Math.floor(Math.random() * 5), 0)][this.units[t].tile.k])
                            } else {
                                this.buildBarracks(sandmap.blocks[Math.min(this.units[t].tile.t + Math.floor(Math.random() * 5), (worldscale - 1))][this.units[t].tile.k])
                            }
                        } else {
                            if (Math.random() < .5) {
                                this.buildBarracks(sandmap.blocks[this.units[t].tile.t][Math.min(this.units[t].tile.k + Math.floor(Math.random() * 5), (worldscale - 1))])
                            } else {
                                this.buildBarracks(sandmap.blocks[this.units[t].tile.t][Math.max(this.units[t].tile.k - Math.floor(Math.random() * 5), 0)])
                            }
                        }
                        if (this.buildings.length > length) {
                            break
                        }
                    }
                    // }
                }
            } else if (this.lab == 0) {
                let podcount = 0
                for (let t = 0; t < this.buildings.length; t++) {
                    if (this.buildings[t].bulbplant == 2) {
                        if (this.buildings[t].que != 1) {
                            podcount++
                        }
                    }
                }
                if (podcount == 0) {

                    const length = this.buildings.length
                    for (let t = 0; t < this.buildings.length; t++) {
                        // if (this.buildings[t].realPath.length - 1 == this.buildings[t].index) {
                        // if (this.units[t].suffocating > 0 || (this.racks !== 1 && this.hotrock > 400)) {
                        if (Math.random() < .5) {
                            if (Math.random() < .5) {
                                this.buildMachineLab(sandmap.blocks[Math.max(this.buildings[t].tile.t - Math.floor(Math.random() * 5), 0)][this.buildings[t].tile.k])
                            } else {
                                this.buildMachineLab(sandmap.blocks[Math.min(this.buildings[t].tile.t + Math.floor(Math.random() * 5), (worldscale - 1))][this.buildings[t].tile.k])
                            }
                        } else {
                            if (Math.random() < .5) {
                                this.buildMachineLab(sandmap.blocks[this.buildings[t].tile.t][Math.min(this.buildings[t].tile.k + Math.floor(Math.random() * 5), (worldscale - 1))])
                            } else {
                                this.buildMachineLab(sandmap.blocks[this.buildings[t].tile.t][Math.max(this.buildings[t].tile.k - Math.floor(Math.random() * 5), 0)])
                            }
                        }
                        if (this.buildings.length > length) {
                            break
                        }
                    }
                    // }
                    // }
                }
            }


            if (this.chunk % this.clickrate == 0) {
                for (let t = 0; t < this.units.length; t++) {
                    index = -1
                    // if (this.units[t].realPath.length - 1 == this.units[t].index) { //} || this.units[t].realPath[this.units[t].index].walkable !== true) {
                    if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {

                        if (this.units[t].hotrockrepathlimit <= 0) {
                            let max = 999999999
                            let drytrack = 0
                            for (let h = 0; h < sandmap.hotrocks.length; h++) {
                                if (sandmap.hotrocks[h].walkable == true && sandmap.hotrocks[h].occupied == false && this.blocks[sandmap.hotrocks[h].t][sandmap.hotrocks[h].k].markdraw == 1) {
                                    const link = (new LineOP(this.units[t].tile, sandmap.hotrocks[h])).hypotenuse()
                                    // //////////console.log(link)
                                    if (link < max) {
                                        max = link
                                        index = h
                                        if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                                        } else {

                                            this.units[t].ultrabreak = sandmap.hotrocks[index]
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            drytrack = Math.floor((this.units[t].movespeed + 1) * (max * .1))
                                        }
                                    }
                                }
                            }
                            if (drytrack != 0) {
                                this.units[t].hotrockrepathlimit = drytrack
                            }
                        }
                    }
                }
            }



        }

        alternateLibrilbianAI() {

            this.chunk++
            let index = -1
            let j = 0


            if (this.chunk % this.clickrate == 0) {
                //this.units.sort((a, b) => (Math.random() > .5) ? 1 : -1)
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].pollinator == 1) {
                        if (this.units[t].health <= (this.units[t].maxhealth * .55)) {
                            this.units[t].metamorphpufffellow()
                        }
                    }
                }








                if (this.defending >= 1) {

                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].pollinator == 1) {
                            if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < (100) && (this.units[t].health < 365)) { //200 distance //300 health
                                if (this.units.length > 0) { //lol

                                    let block = sandmap.blocks[Math.min(Math.max(this.units[0].tile.t - (Math.sign(Math.random() - .5)), 0), worldscale - 1)][Math.min(Math.max(this.units[0].tile.k - (Math.sign(Math.random() - .5)), 0), worldscale - 1)]


                                    for (let g = 0; g < this.units.length; g++) {
                                        if (Math.abs(this.units[g].tile.x - this.attackedAt.x) + Math.abs(this.units[g].tile.y - this.attackedAt.y) > (140)) {
                                            let vec = new Vector(this.units[t].body, this.units[g].body.x - this.units[t].body.x, this.units[g].body.y - this.units[t].body.y)
                                            if (vec.isToward(this.attackedAt)) {
                                            } else {
                                                block = sandmap.blocks[Math.min(Math.max(this.units[g].tile.t - (Math.sign(Math.random() - .5)), 0), worldscale - 1)][Math.min(Math.max(this.units[g].tile.k - (Math.sign(Math.random() - .5)), 0), worldscale - 1)]
                                                break
                                            }
                                        }
                                    }
                                    // if (this.units[t].hotrockrepathlimit <= 0) {
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * 1.01
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed
                                    this.units[t].ultrabreak = block
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                    // }


                                } else {

                                    if (Math.abs(this.units[t].tile.x - this.units[t].realPath[this.units[t].realPath.length - 1].x) + Math.abs(this.units[t].tile.y - this.units[t].realPath[this.units[t].realPath.length - 1].y) < (worldscale * .25 * 10)) {
                                        let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                        let u = 0
                                        while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1) || (Math.abs(this.units[t].tile.x - block.x) + Math.abs(this.units[t].tile.y - block.y) < (worldscale * .25 * 10))) && u < 1000) {
                                            u++
                                            block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                        }
                                        // 

                                        // if (this.units[t].hotrockrepathlimit <= 0) {
                                        this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * 1.01
                                        this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed
                                        this.units[t].ultrabreak = block
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                        // }


                                    } else {

                                    }

                                }
                            }
                        }
                    }
                }

                let unitcountersee = 0
                let buildingsseecount = 0
                let lastseen = {}
                let healthMeter = 999999999
                let epowercount = 0
                for(let d = 1;d<sandmap.players.length;d++){

                const indexer = Math.abs((sandmap.players.indexOf(this) + d)%sandmap.players.length)

                for (let t = 0; t < sandmap.players[indexer].buildings.length; t++) {
                    if (this.blocks[sandmap.players[indexer].buildings[t].tile.t][sandmap.players[indexer].buildings[t].tile.k].markdraw == 1) { //can see this unit
                        buildingsseecount++
                        if (healthMeter > sandmap.players[indexer].buildings[t].health) {
                            lastseen = sandmap.blocks[sandmap.players[indexer].buildings[t].tile.t][sandmap.players[indexer].buildings[t].tile.k]
                        }
                    }
                }

                for (let t = 0; t < sandmap.players[indexer].units.length; t++) {
                    if (this.blocks[sandmap.players[indexer].units[t].tile.t][sandmap.players[indexer].units[t].tile.k].markdraw == 1) {//can see this building
                        unitcountersee++
                        if (healthMeter > sandmap.players[indexer].units[t].health) {
                            healthMeter = sandmap.players[indexer].units[t].health
                            lastseen = sandmap.blocks[sandmap.players[indexer].units[t].tile.t][sandmap.players[indexer].units[t].tile.k]
                        }
                        epowercount += sandmap.players[indexer].units[t].health //add up their health (not super fair to players, as they only get the healthbar graphic)
                    }
                }
            }

                let powercount = 0
                for (let t = 0; t < this.units.length; t++) {
                    if ((unitcountersee > 0 || buildingsseecount > 0) && (this.units[t].health > 400)) { //calculate strength of current army
                        if ((this.units[t].health > this.units[t].maxhealth * .25)) {
                            // if (!(this.units[t].defendsplatter > 0)) {
                            powercount += this.units[t].health
                            // }
                        }
                    }
                }

                if (this.units.length > 0) {
                    for (let t = 0; t < this.units.length; t++) {
                        if ((unitcountersee > 0 || buildingsseecount > 0) && (this.units[t].health > 400)) {
                            if ((this.units[t].health > this.units[t].maxhealth * .25)) {
                                if (!(this.units[t].defendsplatter > 0)) {
                                    // if(!(this.units[t].isInRange(this.units[t].attacktarget && this.units[t].attacktarget.health > 0))){
                                    if (epowercount <= powercount) {
                                        let gj = 0
                                        while (lastseen.walkable == false) {
                                            if (gj > 100) {
                                                break
                                            }
                                            lastseen = sandmap.blocks[Math.min(Math.max(lastseen.t - (Math.sign(Math.random() - .5)), 0), worldscale - 1)][Math.min(Math.max(lastseen.k - (Math.sign(Math.random() - .5)), 0), worldscale - 1)]
                                        }
                                        this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - lastseen.t) + Math.abs(this.units[t].tile.k - lastseen.k)) * this.units[t].movespeed * .5
                                        this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - lastseen.t) + Math.abs(this.units[t].tile.k - lastseen.k)) * this.units[t].movespeed) * 1
                                        this.units[t].ultrabreak = lastseen
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                        this.units[t].defendsplatter = this.units[t].movespeed * 9 //prevent spam
                                    } else {
                                        this.units[t].defendsplatter--
                                    }
                                    // }
                                } else {
                                    this.units[t].defendsplatter--
                                }
                            } else {
                                this.units[t].defendsplatter--
                            }
                        } else {
                            this.units[t].defendsplatter--
                        }
                    }
                }

                for (let t = 0; t < this.units.length; t++) {
                    this.units[t].smartAttack()
                }




            }


            if (Math.random() < .1) { //new
                for (let t = 0; t < this.units.length; t++) {

                    if (!(this.units[t].attacksplatter > 0)) {

                        if (this.units[t].pufffellow == 1) {
                            if (Math.random() < .97) {
                                //this.units[t].attackmoveunit()
                                //test case 123456
                                this.units[t].attackmove()
                                this.units[t].attacksplatter = this.units[t].movespeed
                            } else {
                                this.units[t].attackmove()
                                this.units[t].attacksplatter = this.units[t].movespeed
                            }
                        }
                    } else {
                        this.units[t].attacksplatter--
                    }
                }
            } //end new


            // //////////console.log("adwa",campaignController.mission )


            if (campaignController.mission == 5) {
                //campaign AI   
                // //////////console.log("dwad")
                // //////////console.log("freq")
                if (this.defending >= 1) {
                    // //////////console.log("freq2")
                    if (this.defending > 1) {
                        // //////////console.log("freq3")

                        for (let t = 0; t < this.units.length; t++) {
                            if (this.units[t].pollinator == 1) {
                                // //////////console.log(this.units[t].tile, this.attackedAt)
                                if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < 180) { //44
                                    //////////console.log("hit")
                                    this.units[t].metamorphpufffellow()
                                }
                            }
                        }
                    }
                    this.defending = 0
                    this.defenseforce = 0
                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].pufffellow == 1) {
                            this.defenseforce++
                        }
                        if (this.units[t].podman == 1) {
                            this.defenseforce += 1.5
                        }
                        if (this.units[t].goliophyte == 1) {
                            this.defenseforce += 2
                        }
                    }
                    if (this.defenseforce > 0) {

                        for (let t = 0; t < this.buildings.length; t++) {

                            if (this.buildings[t].bulbplant == 2) {
                                if (Math.random() < .5) {
                                    if (this.hotrock > 140) {
                                        this.buildings[t].makeLibrilbianpodman()
                                    }
                                } else {
                                    if (Math.random() < .5) {
                                        if (Math.random() < .5) {
                                            if (this.hotrock > 140) {
                                                this.buildings[t].makeLibrilbianpodman()
                                            }
                                        } else {
                                            if (Math.random() < .5) {
                                                if (this.hotrock > 95 && Math.random() < .07) { //.7
                                                    this.buildings[t].makeLibrilbianpufffellow()
                                                }
                                            } else {
                                                if (this.hotrock > 355) {
                                                    this.buildings[t].makeLibrilbiangoliophyte()
                                                }
                                            }
                                        }
                                    } else {
                                        if (this.hotrock > 355) {
                                            this.buildings[t].makeLibrilbiangoliophyte()
                                        }
                                    }
                                }
                            }
                        }
                        for (let t = 0; t < this.units.length; t++) {
                            if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < 140) { //14


                                if (this.units[t].podman == 1) {

                                    if (Math.random() < 7 / this.defenseforce) { //2
                                        // if (this.units[t].index == this.units[t].realPath.length - 1) {

                                        if (this.units[t].defensepathlimit <= 0) {
                                            this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01
                                            this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                            this.units[t].ultrabreak = this.attackedAt
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                        }
                                        // }
                                    }
                                }

                                if (this.units[t].goliophyte == 1) {
                                    if (Math.random() < 7 / this.defenseforce) { //2
                                        // if (this.units[t].index == this.units[t].realPath.length - 1) {

                                        if (this.units[t].defensepathlimit <= 0) {
                                            this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01
                                            this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed

                                            this.units[t].ultrabreak = this.attackedAt
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                        }
                                    }
                                }

                                if (this.units[t].pufffellow == 1) {
                                    if (Math.random() < 7 / this.defenseforce) { //2
                                        // if (this.units[t].index == this.units[t].realPath.length - 1) {

                                        if (this.units[t].defensepathlimit <= 0) {
                                            this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01
                                            this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed


                                            this.units[t].ultrabreak = this.attackedAt
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                        }
                                    }
                                }

                            }
                        }
                    } else {

                    }
                }

            } else {

                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].pollinator == 1) {
                        if (this.units.length >= this.seenrocks.length && (this.units[t].health / this.units[t].maxhealth) > .3) { //seen

                            if (this.units[t].hotrockrepathlimit <= 0) {
                                // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                let u = 0
                                while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                    u++
                                    block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                }

                                this.units[t].hotrockrepathlimit = 64 * (this.units[t].movespeed + 1)

                                this.units[t].ultrabreak = block
                                this.units[t].ultrawalk = 0
                                this.units[t].start = this.units[t].tile
                            }
                        }
                    }
                }
                //normal AI
                // //////////console.log(campaignController.mission)
                if (this.defending >= 32) {
                    if (this.defending > 39) {
                        for (let t = 0; t < this.units.length; t++) {
                            if (this.units[t].pollinator == 1) {
                                if (Math.random() < (this.hotrock / 2000)) {
                                    this.units[t].metamorphpufffellow()
                                    if (sandmap.players.indexOf(this) == sandmap.turn) {
                                        if (Math.random() < soundspamdrop) {
                                            soundCancel()
                                            pollinatoraudio.play()
                                        }
                                    }
                                }
                            }
                        }
                    }
                    this.defending = 0
                    this.defenseforce = 0
                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].pufffellow == 1) {
                            this.defenseforce++
                        }
                        if (this.units[t].podman == 1) {
                            this.defenseforce += 1.5
                        }
                        if (this.units[t].goliophyte == 1) {
                            this.defenseforce += 2
                        }
                    }
                    if (this.defenseforce > 0) {

                        for (let t = 0; t < this.buildings.length; t++) {

                            if (this.buildings[t].bulbplant == 2) {
                                if (Math.random() < .5) {
                                    if (this.hotrock > 140) {
                                        this.buildings[t].makeLibrilbianpodman()
                                    }
                                } else {
                                    if (Math.random() < .5) {
                                        if (Math.random() < .5) {
                                            if (this.hotrock > 140) {
                                                this.buildings[t].makeLibrilbianpodman()
                                            }
                                        } else {
                                            if (Math.random() < .5) {
                                                if (this.hotrock > 95 && Math.random() < .07) { //.7
                                                    this.buildings[t].makeLibrilbianpufffellow()
                                                }
                                            } else {
                                                if (this.hotrock > 355) {
                                                    this.buildings[t].makeLibrilbiangoliophyte()
                                                }
                                            }
                                        }
                                    } else {
                                        if (this.hotrock > 355) {
                                            this.buildings[t].makeLibrilbiangoliophyte()
                                        }
                                    }
                                }
                            }
                        }
                        for (let t = 0; t < this.units.length; t++) {
                            if (this.units[t].podman == 1) {
                                if (Math.random() < 7 / this.defenseforce) { //2
                                    // if (this.units[t].index == this.units[t].realPath.length - 1) {

                                    if (this.units[t].defensepathlimit <= 0) {
                                        this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                        this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01

                                        this.units[t].ultrabreak = this.attackedAt
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                    }
                                }
                            }

                            if (this.units[t].goliophyte == 1) {
                                if (Math.random() < 7 / this.defenseforce) { //2
                                    // if (this.units[t].index == this.units[t].realPath.length - 1) {

                                    if (this.units[t].defensepathlimit <= 0) {
                                        this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                        this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01

                                        this.units[t].ultrabreak = this.attackedAt
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                    }
                                }
                            }

                            if (this.units[t].pufffellow == 1) {
                                if (Math.random() < 7 / this.defenseforce) { //2
                                    // if (this.units[t].index == this.units[t].realPath.length - 1) {

                                    if (this.units[t].defensepathlimit <= 0) {
                                        this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                        this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01

                                        this.units[t].ultrabreak = this.attackedAt
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                    }
                                }
                            }
                        }
                    } else {

                    }
                }


            }




            if (this.chunk % this.clickrate == 0) {
                this.workerlength = 0
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].pollinator == 1) {
                        this.workerlength++
                    }
                }
                for (let t = 0; t < this.buildings.length; t++) {
                    if (this.buildings[t].bulbplant == 2) {
                        if (Math.random() < .13) { //5
                            if (this.hotrock > 140) {
                                this.buildings[t].makeLibrilbianpodman()
                            }
                        } else {
                            if (Math.random() < .03) { //.5
                                if (Math.random() < .5) {
                                    if (this.hotrock > 140) {
                                        this.buildings[t].makeLibrilbianpodman()
                                    }
                                } else {
                                    if (Math.random() < .05) { //.5
                                        if (this.hotrock > 95 && Math.random() < .07) {  // 100% //.7
                                            this.buildings[t].makeLibrilbianpufffellow()
                                        }
                                    } else {
                                        if (this.hotrock > 355) {
                                            this.buildings[t].makeLibrilbiangoliophyte()
                                        }
                                    }
                                }
                            } else {
                                if (this.hotrock > 355) {
                                    this.buildings[t].makeLibrilbiangoliophyte()
                                }
                            }
                        }
                    }
                    if (this.buildings[t].bulbplant == 1) {
                        if (this.workerlength <= (unitcap * .3)) { // 8
                            if (this.hotrock > 90) {
                                this.buildings[t].makeLibrilbianpollinator()
                            }
                        }
                    }
                }
            }


            if (this.units.length > this.racksflag || this.hotrock * .0035 > this.racksflag) {
                if (this.racks > 0) {
                    this.racksflag += 5
                }
                if (Math.random() < .4) {
                    this.racks = 0
                }
                this.lab = 0
            }

            let breakbuilding = 0
            for (let t = 0; t < this.buildings.length; t++) {
                if (this.buildings[t].bulbplant == 1) {
                    breakbuilding = 1
                }
            }

            if (this.racks == 0 && (breakbuilding == 0 || Math.random() < .5)) {
                const length = this.buildings.length
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].realPath.length - 1 == this.units[t].index) {
                        // if (this.units[t].suffocating > 0 || (this.racks !== 1 && this.hotrock > 400)) {
                        if (Math.random() < .5) {
                            if (Math.random() < .5) {
                                this.buildBarracks(sandmap.blocks[Math.max(this.units[t].tile.t - Math.floor(Math.random() * 5), 0)][this.units[t].tile.k])
                            } else {
                                this.buildBarracks(sandmap.blocks[Math.min(this.units[t].tile.t + Math.floor(Math.random() * 5), (worldscale - 1))][this.units[t].tile.k])
                            }
                        } else {
                            if (Math.random() < .5) {
                                this.buildBarracks(sandmap.blocks[this.units[t].tile.t][Math.min(this.units[t].tile.k + Math.floor(Math.random() * 5), (worldscale - 1))])
                            } else {
                                this.buildBarracks(sandmap.blocks[this.units[t].tile.t][Math.max(this.units[t].tile.k - Math.floor(Math.random() * 5), 0)])
                            }
                        }
                        if (this.buildings.length > length) {
                            break
                        }
                    }
                    // }
                }
            } else if (this.lab == 0) {
                let podcount = 0
                let scount = 0
                for (let t = 0; t < this.buildings.length; t++) {
                    if (this.buildings[t].bulbplant == 2) {
                        scount++
                        if (this.buildings[t].que != 1) {
                            podcount++
                        }
                    }
                }
                if (podcount == 0 && scount < this.units.length ) {

                    const length = this.buildings.length
                    for (let t = 0; t < this.buildings.length; t++) {
                        // if (this.buildings[t].realPath.length - 1 == this.buildings[t].index) {
                        // if (this.units[t].suffocating > 0 || (this.racks !== 1 && this.hotrock > 400)) {
                        if (Math.random() < .5) {
                            if (Math.random() < .5) {
                                this.buildMachineLab(sandmap.blocks[Math.max(this.buildings[t].tile.t - Math.floor(Math.random() * 5), 0)][this.buildings[t].tile.k])
                            } else {
                                this.buildMachineLab(sandmap.blocks[Math.min(this.buildings[t].tile.t + Math.floor(Math.random() * 5), (worldscale - 1))][this.buildings[t].tile.k])
                            }
                        } else {
                            if (Math.random() < .5) {
                                this.buildMachineLab(sandmap.blocks[this.buildings[t].tile.t][Math.min(this.buildings[t].tile.k + Math.floor(Math.random() * 5), (worldscale - 1))])
                            } else {
                                this.buildMachineLab(sandmap.blocks[this.buildings[t].tile.t][Math.max(this.buildings[t].tile.k - Math.floor(Math.random() * 5), 0)])
                            }
                        }
                        if (this.buildings.length > length) {
                            break
                        }
                    }
                    // }
                    // }
                }
            }


            if (this.chunk % this.clickrate == 0) {
                for (let t = 0; t < this.units.length; t++) {
                    index = -1
                    // if (this.units[t].realPath.length - 1 == this.units[t].index) { //} || this.units[t].realPath[this.units[t].index].walkable !== true) {
                    if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {

                        if (this.units[t].hotrockrepathlimit <= 0) {
                            let max = 999999999
                            let drytrack = 0
                            for (let h = 0; h < sandmap.hotrocks.length; h++) {
                                if (sandmap.hotrocks[h].walkable == true && sandmap.hotrocks[h].occupied == false && this.blocks[sandmap.hotrocks[h].t][sandmap.hotrocks[h].k].markdraw == 1) {
                                    const link = (new LineOP(this.units[t].tile, sandmap.hotrocks[h])).hypotenuse()
                                    // //////////console.log(link)
                                    if (link < max) {
                                        max = link
                                        index = h
                                        if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                                        } else {

                                            this.units[t].ultrabreak = sandmap.hotrocks[index]
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            drytrack = Math.floor((this.units[t].movespeed + 1) * (max * .1))
                                        }
                                    }
                                }
                            }
                            if (drytrack != 0) {
                                this.units[t].hotrockrepathlimit = drytrack
                            }
                        }
                    }
                }
            }



        }
        huntAlternateHamartanAI() {


            if (this.chunk % this.clickrate == 0) {



                if (this.defending >= 1) {

                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].hamartanworker == 1) {
                            if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < (100) && (this.units[t].health < 365)) { //200 distance //300 health
                                if (this.units.length > 0) { //lol

                                    let block = sandmap.blocks[Math.min(Math.max(this.units[0].tile.t - (Math.sign(Math.random() - .5)), 0), worldscale - 1)][Math.min(Math.max(this.units[0].tile.k - (Math.sign(Math.random() - .5)), 0), worldscale - 1)]


                                    for (let g = 0; g < this.units.length; g++) {
                                        if (Math.abs(this.units[g].tile.x - this.attackedAt.x) + Math.abs(this.units[g].tile.y - this.attackedAt.y) > (140)) {
                                            let vec = new Vector(this.units[t].body, this.units[g].body.x - this.units[t].body.x, this.units[g].body.y - this.units[t].body.y)
                                            if (vec.isToward(this.attackedAt)) {
                                            } else {
                                                block = sandmap.blocks[Math.min(Math.max(this.units[g].tile.t - (Math.sign(Math.random() - .5)), 0), worldscale - 1)][Math.min(Math.max(this.units[g].tile.k - (Math.sign(Math.random() - .5)), 0), worldscale - 1)]
                                                break
                                            }
                                        }
                                    }
                                    // if (this.units[t].hotrockrepathlimit <= 0) {
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * 1.01
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed
                                    this.units[t].ultrabreak = block
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                    // }


                                } else {

                                    if (Math.abs(this.units[t].tile.x - this.units[t].realPath[this.units[t].realPath.length - 1].x) + Math.abs(this.units[t].tile.y - this.units[t].realPath[this.units[t].realPath.length - 1].y) < (worldscale * .25 * 10)) {
                                        let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                        let u = 0
                                        while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1) || (Math.abs(this.units[t].tile.x - block.x) + Math.abs(this.units[t].tile.y - block.y) < (worldscale * .25 * 10))) && u < 1000) {
                                            u++
                                            block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                        }
                                        // 

                                        // if (this.units[t].hotrockrepathlimit <= 0) {
                                        this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * 1.01
                                        this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed
                                        this.units[t].ultrabreak = block
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                        // }


                                    } else {

                                    }

                                }
                            }
                        }
                    }
                }

                let unitcountersee = 0
                let buildingsseecount = 0
                let lastseen = {}
                let epowercount = 0
                let healthMeter = 999999999

                for(let d = 1;d<sandmap.players.length;d++){
                const indexer = Math.abs((sandmap.players.indexOf(this) + d)%sandmap.players.length)

                for (let t = 0; t < sandmap.players[indexer].buildings.length; t++) {
                    if (this.blocks[sandmap.players[indexer].buildings[t].tile.t][sandmap.players[indexer].buildings[t].tile.k].markdraw == 1) { //can see this unit
                        buildingsseecount++
                        if (healthMeter > sandmap.players[indexer].buildings[t].health) {
                            lastseen = sandmap.blocks[sandmap.players[indexer].buildings[t].tile.t][sandmap.players[indexer].buildings[t].tile.k]
                        }
                    }
                }

                for (let t = 0; t < sandmap.players[indexer].units.length; t++) {
                    if (this.blocks[sandmap.players[indexer].units[t].tile.t][sandmap.players[indexer].units[t].tile.k].markdraw == 1) {//can see this building
                        unitcountersee++
                        if (healthMeter > sandmap.players[indexer].units[t].health) {
                            healthMeter = sandmap.players[indexer].units[t].health
                            lastseen = sandmap.blocks[sandmap.players[indexer].units[t].tile.t][sandmap.players[indexer].units[t].tile.k]
                        }
                        epowercount += sandmap.players[indexer].units[t].health //add up their health (not super fair to players, as they only get the healthbar graphic)
                    }
                }
            }
                let powercount = 0
                for (let t = 0; t < this.units.length; t++) {
                    if ((unitcountersee > 0 || buildingsseecount > 0) && (this.units[t].health > 400)) { //calculate strength of current army
                        if ((this.units[t].health > this.units[t].maxhealth * .25)) {
                            // if (!(this.units[t].defendsplatter > 0)) {
                            powercount += this.units[t].health
                            // }
                        }
                    }
                }

                if (this.units.length > 0) {
                    for (let t = 0; t < this.units.length; t++) {
                        if ((unitcountersee > 0 || buildingsseecount > 0) && (this.units[t].health > 400)) {
                            if ((this.units[t].health > this.units[t].maxhealth * .25)) {
                                if (!(this.units[t].defendsplatter > 0)) {
                                    // if(!(this.units[t].isInRange(this.units[t].attacktarget && this.units[t].attacktarget.health > 0))){
                                    if (epowercount <= powercount) {
                                        let gj = 0
                                        while (lastseen.walkable == false) {
                                            if (gj > 100) {
                                                break
                                            }
                                            lastseen = sandmap.blocks[Math.min(Math.max(lastseen.t - (Math.sign(Math.random() - .5)), 0), worldscale - 1)][Math.min(Math.max(lastseen.k - (Math.sign(Math.random() - .5)), 0), worldscale - 1)]
                                        }
                                        this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - lastseen.t) + Math.abs(this.units[t].tile.k - lastseen.k)) * this.units[t].movespeed * .5
                                        this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - lastseen.t) + Math.abs(this.units[t].tile.k - lastseen.k)) * this.units[t].movespeed) * 1
                                        this.units[t].ultrabreak = lastseen
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                        this.units[t].defendsplatter = this.units[t].movespeed * 9 //prevent spam
                                    } else {
                                        this.units[t].defendsplatter--
                                    }
                                    // }
                                } else {
                                    this.units[t].defendsplatter--
                                }
                            } else {
                                this.units[t].defendsplatter--
                            }
                        } else {
                            this.units[t].defendsplatter--
                        }
                    }
                }

                for (let t = 0; t < this.units.length; t++) {
                    this.units[t].smartAttack()
                }


                //this.units.sort((a, b) => (Math.random() > .5) ? 1 : -1)

                let workercount = 0
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].hamartanworker == 1) {
                        workercount++
                    }
                }


                let stuck = 0
                for (let t = 0; t < this.buildings.length; t++) {
                    if (this.buildings[t].assembler == 3) {
                        stuck++
                    }
                }



                for (let t = 0; t < this.buildings.length; t++) {
                    if (this.buildings[t].assembler == 2) {
                        if (this.seenrocks.length <= this.units.length) { //seen
                            if (this.hotrock > 75) { //135 //115
                                this.buildings[t].makeHamartanscout()
                                break
                            }
                        }
                    }

                    if (this.buildings[t].assembler == 1) {
                        // if (this.seen.length <= this.units.length) { //? this is like saying fill the whole map before considering making any soldiers lmao
                        if (this.hotrock > 175 && Math.random() < .95) { //235 //200 .75
                            this.buildings[t].makeHamartansoldier()
                        }
                        // }
                    }
                    if (this.buildings[t].assembler == 3) {
                        if (Math.random() < .12 - (this.units.length * .0012) && (workercount / this.units.length) < (1 - (this.units.length / unitcap))) { //.1  //NEW && (workercount/this.units.length) < .75 NEW
                            if (this.hotrock > 135) { //220 //170 //145
                                this.buildings[t].makeHamartanworker()
                            }
                        }
                        if (Math.random() < (this.units.length * .01) + (this.hotrock * .0025)) {  // - unitslength not + //too frequent too early //45 not 15 //0001
                            if (this.hotrock > 340) {
                                if (this.buildings[t].que == 1) {
                                    if (this.hotrock > 400) { //700
                                        stuck--
                                        if (stuck == 0) {
                                            this.racks = 0
                                            //////////console.log("stuck effect")
                                        }
                                    }
                                } else {
                                    this.buildings[t].makeHamartaninvader()
                                }
                            }
                        }
                        if (Math.random() < 1 / (this.buildings.length * 2)) {
                            break
                        }
                    }
                }
            }


            if (this.defending >= 1) {
                for (let t = 0; t < this.units.length; t++) {

                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].isRangeTo(this.attackedAt, Math.ceil(worldscale * .5))) {
                            if (this.units[t].hamartaninvader == 1) {
                                if (this.units[t].defensepathlimit <= 0) {
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed * .75
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * .8
                                    this.units[t].ultrabreak = this.attackedAt
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }
                            }
                            if (this.units[t].hamartansoldier == 1) { // was just soldier
                                if (this.units[t].defensepathlimit <= 0) {
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed * .75
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * .8
                                    this.units[t].ultrabreak = this.attackedAt
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }
                            }
                        }
                    }
                }

            }

            if (this.defending >= 32 || (this.defending > 0 && this.defending < 10)) {
                this.defending = 0
                this.defenseforce = 0
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].hamartansoldier == 1) { // was just soldier
                        this.defenseforce++
                    }
                    if (this.units[t].hamartaninvader == 1) {
                        this.defenseforce += 2
                    }
                }
                if (this.defenseforce > 0) {

                    for (let t = 0; t < this.buildings.length; t++) {
                        if (this.buildings[t].assembler == 1) {
                            if (this.hotrock > 175 && Math.random() < .95) { //235  //200 .75
                                this.buildings[t].makeHamartansoldier()
                            }
                        }

                        if (this.buildings[t].assembler == 2) {
                            if (this.hotrock > 340) {
                                this.buildings[t].makeHamartaninvader()
                            }
                        }
                    }

                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].hamartaninvader == 1) {
                            if (Math.random() < 7 / this.defenseforce) { //2
                                if (this.units[t].defensepathlimit <= 0) {
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed * .75
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * .8

                                    this.units[t].ultrabreak = this.attackedAt
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }
                            }
                        }

                        if (this.units[t].hamartansoldier == 1) { // was just soldier
                            if (Math.random() < 7 / this.defenseforce) { //2
                                if (this.units[t].defensepathlimit <= 0) {
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed * .75
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * .8

                                    this.units[t].ultrabreak = this.attackedAt
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }
                            }
                        }
                    }
                } else {

                }
            }


            if (this.units.length == 3) {
                let tpos = 0
                let kpos = 0

                for (let t = 0; t < this.units.length; t++) {
                    tpos += this.units[t].tile.t
                    kpos += this.units[t].tile.k
                }
                tpos = Math.round(tpos / 3)
                kpos = Math.round(kpos / 3)

                let tile = sandmap.blocks[tpos][kpos]
                if (tile.occupied == true) {
                    if (kpos < worldscale) {
                        tile = sandmap.blocks[tpos][kpos + 1]
                    } else {
                        if (tpos < worldscale) {
                            tile = sandmap.blocks[tpos + 1][kpos]
                        }
                    }
                }
                let count = 0
                for (let t = 0; t < this.units.length; t++) {
                    const link = new LineOP(this.units[t].tile, tile)
                    if (((this.units[t].suffocating > 0 && (this.units[t].health / this.units[t].maxhealth) < .995) || this.hotrock >= 380) && link.hypotenuse() <= 119) { //975
                        count++
                    }
                }
                if (count == 3) {
                    this.buildWallHamartans(tile, 1)
                } else if (count == 0 || ((count == 1 || count == 2) && this.hotrock > 390)) {
                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].realPath.length - 1 == this.units[t].index) {
                            if ((this.units[t].suffocating > 0 && (this.units[t].health / this.units[t].maxhealth) < .9) || (this.racks !== 1 && this.hotrock > 340)) { //400
                                if (Math.random() < .5) {
                                    if (Math.random() < .5) {
                                        this.buildWallHamartans(sandmap.blocks[Math.max(this.units[t].tile.t - 2, 0)][this.units[t].tile.k])
                                    } else {
                                        this.buildWallHamartans(sandmap.blocks[Math.min(this.units[t].tile.t + 2, (worldscale - 1))][this.units[t].tile.k])
                                    }
                                } else {
                                    if (Math.random() < .5) {
                                        this.buildWallHamartans(sandmap.blocks[this.units[t].tile.t][Math.min(this.units[t].tile.k + 2, (worldscale - 1))])
                                    } else {
                                        this.buildWallHamartans(sandmap.blocks[this.units[t].tile.t][Math.max(this.units[t].tile.k - 2, 0)])
                                    }
                                }
                                break
                            }
                        }
                    }
                }

            } else {
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].realPath.length - 1 == this.units[t].index) {
                        if ((this.units[t].suffocating > 0 && (this.units[t].health / this.units[t].maxhealth) < .9) || (this.racks !== 1 && this.hotrock > 340)) { //400
                            if (Math.random() < .5) {
                                if (Math.random() < .5) {
                                    this.buildWallHamartans(sandmap.blocks[Math.max(this.units[t].tile.t - 2, 0)][this.units[t].tile.k])
                                } else {
                                    this.buildWallHamartans(sandmap.blocks[Math.min(this.units[t].tile.t + 2, (worldscale - 1))][this.units[t].tile.k])
                                }
                            } else {
                                if (Math.random() < .5) {
                                    this.buildWallHamartans(sandmap.blocks[this.units[t].tile.t][Math.min(this.units[t].tile.k + 2, (worldscale - 1))])
                                } else {
                                    this.buildWallHamartans(sandmap.blocks[this.units[t].tile.t][Math.max(this.units[t].tile.k - 2, 0)])
                                }
                            }
                            break
                        }
                    }
                }
            }


            let index
            let j = 0
            this.chunk++
            if (this.chunk % this.clickrate == 0) {



                if (Math.random() < .3) {

                    let wet = 0
                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].hamartanscout == 1) {
                            wet = 1
                            break
                        }
                    }

                    if (wet == 0) {
                        for (let t = 0; t < this.buildings.length; t++) {
                            if (this.buildings[t].assembler == 2) {
                                if (this.hotrock >= 75) { //135 //115
                                    this.buildings[t].makeHamartanscout()
                                }
                            }
                        }
                    }


                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].hamartanscout == 1 || wet == 0) {
                            // if (this.units[t].realPath.length - 1 == this.units[t].index) {
                            if (this.units.length >= this.seenrocks.length - 3 && (this.units[t].health / this.units[t].maxhealth) > .3) { //seen //5
                                if (this.units[t].hotrockrepathlimit <= 0 || (this.units[t].hamartanscout == 1 && this.units[t].defensepathlimit <= 0)) {
                                    // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                    let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                    let u = 0
                                    while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                        u++
                                        block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                    }
                                    this.units[t].ultrabreak = block
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                    let dlockdi = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k))
                                    this.units[t].hotrockrepathlimit = Math.max(dlockdi, 15) * (this.units[t].movespeed)
                                    this.units[t].defensepathlimit = (this.units[t].movespeed) * (worldscale * .125)
                                }
                            }
                            // }
                        }
                    }
                    const reasonableChance = ((this.units.length / unitcap) * .03)

                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].tile.hotrock <= 0) {
                            if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                            } else {
                                if (Math.random() < reasonableChance) {
                                    if (this.units[t].hamartanworker == 1) {
                                    } else {
                                        if (this.units[t].hotrockrepathlimit <= 0) {
                                            // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                            let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                            let u = 0
                                            while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                                u++
                                                block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                            }
                                            this.units[t].ultrabreak = block
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            // this.units[t].hotrockrepathlimit = worldscale*(this.units[t].movespeed)

                                            let dlockdi = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k))
                                            this.units[t].hotrockrepathlimit = Math.max(dlockdi, 15) * (this.units[t].movespeed)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                for (let t = 0; t < this.units.length; t++) {
                    // if (this.units[t].realPath.length - 1 == this.units[ t].index) { //} || this.units[t].realPath[this.units[t].index].walkable !== true) {
                    if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {
                        if (this.units[t].hotrockrepathlimit <= 0) {
                            let max = 999999999
                            let drytrack = 0
                            for (let h = 0; h < sandmap.hotrocks.length; h++) {
                                if (sandmap.hotrocks[h].walkable == true && sandmap.hotrocks[h].occupied == false && this.blocks[sandmap.hotrocks[h].t][sandmap.hotrocks[h].k].markdraw == 1) {
                                    const link = (new LineOP(this.units[t].tile, sandmap.hotrocks[h])).hypotenuse()
                                    // //////////console.log(link)
                                    if (link < max) {
                                        max = link
                                        index = h
                                        if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                                        } else {
                                            this.units[t].ultrabreak = sandmap.hotrocks[index]
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            drytrack = Math.floor((this.units[t].movespeed + 1) * (max * .1))
                                        }
                                    }
                                }
                            }
                            if (drytrack != 0) {
                                this.units[t].hotrockrepathlimit = drytrack
                            }
                        }

                    }
                }
            }

        }
        alternateHamartanAI() {


            if (this.chunk % this.clickrate == 0) {

                //this.units.sort((a, b) => (Math.random() > .5) ? 1 : -1)

                let workercount = 0
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].hamartanworker == 1) {
                        workercount++
                    }
                }


                let stuck = 0
                for (let t = 0; t < this.buildings.length; t++) {
                    if (this.buildings[t].assembler == 3) {
                        stuck++
                    }
                }



                for (let t = 0; t < this.buildings.length; t++) {
                    if (this.buildings[t].assembler == 2) {
                        if (this.seenrocks.length <= this.units.length) { //seen
                            if (this.hotrock > 75) { //135 //115
                                this.buildings[t].makeHamartanscout()
                                break
                            }
                        }
                    }

                    if (this.buildings[t].assembler == 1) {
                        // if (this.seen.length <= this.units.length) { //? this is like saying fill the whole map before considering making any soldiers lmao
                        if (this.hotrock > 175 && Math.random() < .95) { //235 //200 .75
                            this.buildings[t].makeHamartansoldier()
                        }
                        // }
                    }
                    if (this.buildings[t].assembler == 3) {
                        if (Math.random() < .12 - (this.units.length * .0012) && (workercount / this.units.length) < (1 - (this.units.length / unitcap))) { //.1  //NEW && (workercount/this.units.length) < .75 NEW
                            if (this.hotrock > 135) { //220 //170 //145
                                this.buildings[t].makeHamartanworker()
                            }
                        }
                        if (Math.random() < (this.units.length * .01) + (this.hotrock * .003)) {  // - unitslength not + //too frequent too early //45 not 15 //0001 //25
                            if (this.hotrock > 340) {
                                if (this.buildings[t].que == 1) {
                                    if (this.hotrock > 400) { //700
                                        stuck--
                                        if (stuck == 0) {
                                            this.racks = 0
                                            //////////console.log("stuck effect")
                                        }
                                    }
                                } else {
                                    this.buildings[t].makeHamartaninvader()
                                }
                            }
                        }
                        if (Math.random() < 1 / (this.buildings.length * 2)) {
                            break
                        }
                    }
                }
            }


            if (this.defending >= 1) {
                for (let t = 0; t < this.units.length; t++) {

                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].isRangeTo(this.attackedAt, Math.ceil(worldscale * .5))) {
                            if (this.units[t].hamartaninvader == 1) {
                                if (this.units[t].defensepathlimit <= 0) {
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01
                                    this.units[t].ultrabreak = this.attackedAt
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }
                            }
                            if (this.units[t].hamartansoldier == 1) { // was just soldier
                                if (this.units[t].defensepathlimit <= 0) {
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01
                                    this.units[t].ultrabreak = this.attackedAt
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }
                            }
                        }
                    }
                }

            }

            if (this.defending >= 32 || (this.defending > 0 && this.defending < 10)) {
                this.defending = 0
                this.defenseforce = 0
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].hamartansoldier == 1) { // was just soldier
                        this.defenseforce++
                    }
                    if (this.units[t].hamartaninvader == 1) {
                        this.defenseforce += 2
                    }
                }
                if (this.defenseforce > 0) {

                    for (let t = 0; t < this.buildings.length; t++) {
                        if (this.buildings[t].assembler == 1) {
                            if (this.hotrock > 175 && Math.random() < .95) { //235  //200 .75
                                this.buildings[t].makeHamartansoldier()
                            }
                        }

                        if (this.buildings[t].assembler == 2) {
                            if (this.hotrock > 340) {
                                this.buildings[t].makeHamartaninvader()
                            }
                        }
                    }

                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].hamartaninvader == 1) {
                            if (Math.random() < 7 / this.defenseforce) { //2
                                if (this.units[t].defensepathlimit <= 0) {
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01

                                    this.units[t].ultrabreak = this.attackedAt
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }
                            }
                        }

                        if (this.units[t].hamartansoldier == 1) { // was just soldier
                            if (Math.random() < 7 / this.defenseforce) { //2
                                if (this.units[t].defensepathlimit <= 0) {
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01

                                    this.units[t].ultrabreak = this.attackedAt
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }
                            }
                        }
                    }
                } else {

                }
            }


            if (this.units.length == 3) {
                let tpos = 0
                let kpos = 0

                for (let t = 0; t < this.units.length; t++) {
                    tpos += this.units[t].tile.t
                    kpos += this.units[t].tile.k
                }
                tpos = Math.round(tpos / 3)
                kpos = Math.round(kpos / 3)

                let tile = sandmap.blocks[tpos][kpos]
                if (tile.occupied == true) {
                    if (kpos < worldscale) {
                        tile = sandmap.blocks[tpos][kpos + 1]
                    } else {
                        if (tpos < worldscale) {
                            tile = sandmap.blocks[tpos + 1][kpos]
                        }
                    }
                }
                let count = 0
                for (let t = 0; t < this.units.length; t++) {
                    const link = new LineOP(this.units[t].tile, tile)
                    if (((this.units[t].suffocating > 0 && (this.units[t].health / this.units[t].maxhealth) < .995) || this.hotrock >= 380) && link.hypotenuse() <= 119) { //975
                        count++
                    }
                }
                if (count == 3) {
                    this.buildWallHamartans(tile, 1)
                } else if (count == 0 || ((count == 1 || count == 2) && this.hotrock > 390)) {
                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].realPath.length - 1 == this.units[t].index) {
                            if ((this.units[t].suffocating > 0 && (this.units[t].health / this.units[t].maxhealth) < .9) || (this.racks !== 1 && this.hotrock > 340)) { //400
                                if (Math.random() < .5) {
                                    if (Math.random() < .5) {
                                        this.buildWallHamartans(sandmap.blocks[Math.max(this.units[t].tile.t - 1, 0)][this.units[t].tile.k])
                                    } else {
                                        this.buildWallHamartans(sandmap.blocks[Math.min(this.units[t].tile.t + 1, (worldscale - 1))][this.units[t].tile.k])
                                    }
                                } else {
                                    if (Math.random() < .5) {
                                        this.buildWallHamartans(sandmap.blocks[this.units[t].tile.t][Math.min(this.units[t].tile.k + 1, (worldscale - 1))])
                                    } else {
                                        this.buildWallHamartans(sandmap.blocks[this.units[t].tile.t][Math.max(this.units[t].tile.k - 1, 0)])
                                    }
                                }
                                break
                            }
                        }
                    }
                }

            } else {
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].realPath.length - 1 == this.units[t].index) {
                        if ((this.units[t].suffocating > 0 && (this.units[t].health / this.units[t].maxhealth) < .9) || (this.racks !== 1 && this.hotrock > 340)) { //400
                            if (Math.random() < .5) {
                                if (Math.random() < .5) {
                                    this.buildWallHamartans(sandmap.blocks[Math.max(this.units[t].tile.t - 1, 0)][this.units[t].tile.k])
                                } else {
                                    this.buildWallHamartans(sandmap.blocks[Math.min(this.units[t].tile.t + 1, (worldscale - 1))][this.units[t].tile.k])
                                }
                            } else {
                                if (Math.random() < .5) {
                                    this.buildWallHamartans(sandmap.blocks[this.units[t].tile.t][Math.min(this.units[t].tile.k + 1, (worldscale - 1))])
                                } else {
                                    this.buildWallHamartans(sandmap.blocks[this.units[t].tile.t][Math.max(this.units[t].tile.k - 1, 0)])
                                }
                            }
                            break
                        }
                    }
                }
            }


            let index
            let j = 0
            this.chunk++
            if (this.chunk % this.clickrate == 0) {



                if (Math.random() < .3) {

                    let wet = 0
                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].hamartanscout == 1) {
                            wet = 1
                            break
                        }
                    }

                    if (wet == 0) {
                        for (let t = 0; t < this.buildings.length; t++) {
                            if (this.buildings[t].assembler == 2) {
                                if (this.hotrock >= 75) { //135 //115
                                    this.buildings[t].makeHamartanscout()
                                }
                            }
                        }
                    }


                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].hamartanscout == 1 || wet == 0) {
                            // if (this.units[t].realPath.length - 1 == this.units[t].index) {
                            if (this.units.length >= this.seenrocks.length - 3 && (this.units[t].health / this.units[t].maxhealth) > .3) { //seen //5
                                if (this.units[t].hotrockrepathlimit <= 0 || (this.units[t].hamartanscout == 1 && this.units[t].defensepathlimit <= 0)) {
                                    // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                    let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                    let u = 0
                                    while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                        u++
                                        block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                    }
                                    this.units[t].ultrabreak = block
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                    let dlockdi = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k))
                                    this.units[t].hotrockrepathlimit = Math.max(dlockdi, 15) * (this.units[t].movespeed)
                                    this.units[t].defensepathlimit = (this.units[t].movespeed) * (worldscale * .125)
                                }
                            }
                            // }
                        }
                    }
                    const reasonableChance = ((this.units.length / unitcap) * .03)

                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].tile.hotrock <= 0) {
                            if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                            } else {
                                if (Math.random() < reasonableChance) {
                                    if (this.units[t].hamartanworker == 1) {
                                    } else {
                                        if (this.units[t].hotrockrepathlimit <= 0) {
                                            // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                            let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                            let u = 0
                                            while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                                u++
                                                block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                            }
                                            this.units[t].ultrabreak = block
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            // this.units[t].hotrockrepathlimit = worldscale*(this.units[t].movespeed)

                                            let dlockdi = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k))
                                            this.units[t].hotrockrepathlimit = Math.max(dlockdi, 15) * (this.units[t].movespeed)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                for (let t = 0; t < this.units.length; t++) {
                    // if (this.units[t].realPath.length - 1 == this.units[ t].index) { //} || this.units[t].realPath[this.units[t].index].walkable !== true) {
                    if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {
                        if (this.units[t].hotrockrepathlimit <= 0) {
                            let max = 999999999
                            let drytrack = 0
                            for (let h = 0; h < sandmap.hotrocks.length; h++) {
                                if (sandmap.hotrocks[h].walkable == true && sandmap.hotrocks[h].occupied == false && this.blocks[sandmap.hotrocks[h].t][sandmap.hotrocks[h].k].markdraw == 1) {
                                    const link = (new LineOP(this.units[t].tile, sandmap.hotrocks[h])).hypotenuse()
                                    // //////////console.log(link)
                                    if (link < max) {
                                        max = link
                                        index = h
                                        if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                                        } else {
                                            this.units[t].ultrabreak = sandmap.hotrocks[index]
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            drytrack = Math.floor((this.units[t].movespeed + 1) * (max * .1))
                                        }
                                    }
                                }
                            }
                            if (drytrack != 0) {
                                this.units[t].hotrockrepathlimit = drytrack
                            }
                        }

                    }
                }
            }

        }
        hamartanAI() {


            if (this.chunk % this.clickrate == 0) {


                let workercount = 0
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].hamartanworker == 1) {
                        workercount++
                    }
                }


                let stuck = 0
                for (let t = 0; t < this.buildings.length; t++) {
                    if (this.buildings[t].assembler == 3) {
                        stuck++
                    }
                }



                for (let t = 0; t < this.buildings.length; t++) {
                    if (this.buildings[t].assembler == 2) {
                        if (this.seenrocks.length <= this.units.length) { //seen
                            if (this.hotrock > 75) { //135 //115
                                this.buildings[t].makeHamartanscout()
                                break
                            }
                        }
                    }

                    if (this.buildings[t].assembler == 1) {
                        // if (this.seen.length <= this.units.length) { //? this is like saying fill the whole map before considering making any soldiers lmao
                        if (this.hotrock > 175 && Math.random() < .95) { //235 //200 .75
                            this.buildings[t].makeHamartansoldier()
                        }
                        // }
                    }
                    if (this.buildings[t].assembler == 3) {
                        if (Math.random() < .12 - (this.units.length * .005) && (workercount / this.units.length) < .85) { //.1  //NEW && (workercount/this.units.length) < .75 NEW
                            if (this.hotrock > 135) { //220 //170 //145
                                this.buildings[t].makeHamartanworker()
                            }
                        }
                        if (Math.random() < (this.units.length * .01) + (this.hotrock * .0025)) {  // - unitslength not + //too frequent too early //45 not 15 //0001
                            if (this.hotrock > 340) {
                                if (this.buildings[t].que == 1) {
                                    if (this.hotrock > 400) { //700
                                        stuck--
                                        if (stuck == 0) {
                                            this.racks = 0
                                            //////////console.log("stuck effect")
                                        }
                                    }
                                } else {
                                    this.buildings[t].makeHamartaninvader()
                                }
                            }
                        }
                        if (Math.random() < 1 / (this.buildings.length * 2)) {
                            break
                        }
                    }
                }
            }



            if (this.defending >= 32 || (this.defending > 0 && this.defending < 10)) {
                this.defending = 0
                this.defenseforce = 0
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].hamartansoldier == 1) { // was just soldier
                        this.defenseforce++
                    }
                    if (this.units[t].hamartaninvader == 1) {
                        this.defenseforce += 2
                    }
                }
                if (this.defenseforce > 0) {

                    for (let t = 0; t < this.buildings.length; t++) {
                        if (this.buildings[t].assembler == 1) {
                            if (this.hotrock > 175 && Math.random() < .95) { //235  //200 .75
                                this.buildings[t].makeHamartansoldier()
                            }
                        }

                        if (this.buildings[t].assembler == 2) {
                            if (this.hotrock > 340) {
                                this.buildings[t].makeHamartaninvader()
                            }
                        }
                    }

                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].hamartaninvader == 1) {
                            if (Math.random() < 7 / this.defenseforce) { //2
                                if (this.units[t].defensepathlimit <= 0) {
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01

                                    this.units[t].ultrabreak = this.attackedAt
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }
                            }
                        }

                        if (this.units[t].hamartansoldier == 1) { // was just soldier
                            if (Math.random() < 7 / this.defenseforce) { //2
                                if (this.units[t].defensepathlimit <= 0) {
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.01

                                    this.units[t].ultrabreak = this.attackedAt
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }
                            }
                        }
                    }
                } else {

                }
            }


            if (this.units.length == 3) {
                let tpos = 0
                let kpos = 0

                for (let t = 0; t < this.units.length; t++) {
                    tpos += this.units[t].tile.t
                    kpos += this.units[t].tile.k
                }
                tpos = Math.round(tpos / 3)
                kpos = Math.round(kpos / 3)

                let tile = sandmap.blocks[tpos][kpos]
                if (tile.occupied == true) {
                    if (kpos < worldscale) {
                        tile = sandmap.blocks[tpos][kpos + 1]
                    } else {
                        if (tpos < worldscale) {
                            tile = sandmap.blocks[tpos + 1][kpos]
                        }
                    }
                }
                let count = 0
                for (let t = 0; t < this.units.length; t++) {
                    const link = new LineOP(this.units[t].tile, tile)
                    if (((this.units[t].suffocating > 0 && (this.units[t].health / this.units[t].maxhealth) < .995) || this.hotrock >= 380) && link.hypotenuse() <= 119) { //975
                        count++
                    }
                }
                if (count == 3) {
                    this.buildWall(tile, 1)
                } else if (count == 0 || ((count == 1 || count == 2) && this.hotrock > 390)) {
                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].realPath.length - 1 == this.units[t].index) {
                            if ((this.units[t].suffocating > 0 && (this.units[t].health / this.units[t].maxhealth) < .9) || (this.racks !== 1 && this.hotrock > 340)) { //400
                                if (Math.random() < .5) {
                                    if (Math.random() < .5) {
                                        this.buildWall(sandmap.blocks[Math.max(this.units[t].tile.t - 1, 0)][this.units[t].tile.k])
                                    } else {
                                        this.buildWall(sandmap.blocks[Math.min(this.units[t].tile.t + 1, (worldscale - 1))][this.units[t].tile.k])
                                    }
                                } else {
                                    if (Math.random() < .5) {
                                        this.buildWall(sandmap.blocks[this.units[t].tile.t][Math.min(this.units[t].tile.k + 1, (worldscale - 1))])
                                    } else {
                                        this.buildWall(sandmap.blocks[this.units[t].tile.t][Math.max(this.units[t].tile.k - 1, 0)])
                                    }
                                }
                                break
                            }
                        }
                    }
                }

            } else {
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].realPath.length - 1 == this.units[t].index) {
                        if ((this.units[t].suffocating > 0 && (this.units[t].health / this.units[t].maxhealth) < .9) || (this.racks !== 1 && this.hotrock > 340)) { //400
                            if (Math.random() < .5) {
                                if (Math.random() < .5) {
                                    this.buildWall(sandmap.blocks[Math.max(this.units[t].tile.t - 1, 0)][this.units[t].tile.k])
                                } else {
                                    this.buildWall(sandmap.blocks[Math.min(this.units[t].tile.t + 1, (worldscale - 1))][this.units[t].tile.k])
                                }
                            } else {
                                if (Math.random() < .5) {
                                    this.buildWall(sandmap.blocks[this.units[t].tile.t][Math.min(this.units[t].tile.k + 1, (worldscale - 1))])
                                } else {
                                    this.buildWall(sandmap.blocks[this.units[t].tile.t][Math.max(this.units[t].tile.k - 1, 0)])
                                }
                            }
                            break
                        }
                    }
                }
            }


            let index
            let j = 0
            this.chunk++
            if (this.chunk % this.clickrate == 0) {



                if (Math.random() < .3) {

                    let wet = 0
                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].hamartanscout == 1) {
                            wet = 1
                            break
                        }
                    }

                    if (wet == 0) {
                        for (let t = 0; t < this.buildings.length; t++) {
                            if (this.buildings[t].assembler == 2) {
                                if (this.hotrock >= 75) { //135 //115
                                    this.buildings[t].makeHamartanscout()
                                }
                            }
                        }
                    }


                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].hamartanscout == 1 || wet == 0) {
                            // if (this.units[t].realPath.length - 1 == this.units[t].index) {
                            if (this.units.length >= this.seenrocks.length + 0 && (this.units[t].health / this.units[t].maxhealth) > .3) { //seen //5
                                if (this.units[t].hotrockrepathlimit <= 0) {
                                    // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                    let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                    let u = 0
                                    while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                        u++
                                        block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                    }
                                    this.units[t].ultrabreak = block
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                    let dlockdi = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k))
                                    this.units[t].hotrockrepathlimit = Math.max(dlockdi, 15) * (this.units[t].movespeed)
                                }
                            }
                            // }
                        }
                    }
                    const reasonableChance = ((this.units.length / unitcap) * .03)

                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].tile.hotrock <= 0) {
                            if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                            } else {
                                if (Math.random() < reasonableChance) {
                                    if (this.units[t].hamartanworker == 1) {
                                    } else {
                                        if (this.units[t].hotrockrepathlimit <= 0) {
                                            // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                            let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                            let u = 0
                                            while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                                u++
                                                block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                            }
                                            this.units[t].ultrabreak = block
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            // this.units[t].hotrockrepathlimit = worldscale*(this.units[t].movespeed)

                                            let dlockdi = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k))
                                            this.units[t].hotrockrepathlimit = Math.max(dlockdi, 15) * (this.units[t].movespeed)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                for (let t = 0; t < this.units.length; t++) {
                    // if (this.units[t].realPath.length - 1 == this.units[ t].index) { //} || this.units[t].realPath[this.units[t].index].walkable !== true) {
                    if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {
                        if (this.units[t].hotrockrepathlimit <= 0) {
                            let max = 999999999
                            let drytrack = 0
                            for (let h = 0; h < sandmap.hotrocks.length; h++) {
                                if (sandmap.hotrocks[h].walkable == true && sandmap.hotrocks[h].occupied == false && this.blocks[sandmap.hotrocks[h].t][sandmap.hotrocks[h].k].markdraw == 1) {
                                    const link = (new LineOP(this.units[t].tile, sandmap.hotrocks[h])).hypotenuse()
                                    // //////////console.log(link)
                                    if (link < max) {
                                        max = link
                                        index = h
                                        if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                                        } else {
                                            this.units[t].ultrabreak = sandmap.hotrocks[index]
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            drytrack = Math.floor((this.units[t].movespeed + 1) * (max * .1))
                                        }
                                    }
                                }
                            }
                            if (drytrack != 0) {
                                this.units[t].hotrockrepathlimit = drytrack
                            }
                        }

                    }
                }
            }

        }
        colditzlerAI() {

            let index = sandmap.hotrocks.length + 1
            this.chunk++
            let j = 0


            if (true) {
                let j = 0

                if (this.defending >= 10) { //18
                    for (let t = this.units.length - 1; t >= 0; t--) {
                        if (this.units[t].nymph == 2) {
                            this.units[t].metamorph2()
                        }
                    }
                    for (let t = this.units.length - 1; t >= 0; t--) {
                        if (this.units[t].nymph == 1) {
                            this.units[t].metamorph1()
                        }
                    }
                }

                if (this.defending >= 32) { //25 not 32 because they favor early advantage // screwing with this?
                    this.defending = 0
                    this.defenseforce = 0
                    for (let t = this.units.length - 1; t >= 0; t--) {
                        if (this.units[t].nymph == 2) {
                            this.defenseforce++
                        }
                        if (this.units[t].nymph == 2) {
                            this.units[t].metamorph2()
                        }
                        if (this.units[t].nymph == 1) {
                            this.units[t].metamorph1()
                        }
                        if (this.units[t].imago == 2) {
                            if (this.units[t].tile.ice == 1 || this.units[t].tile.builtOn == 1) {
                            } else {
                                this.units[t].submerged = 0 //1?
                            }
                        }
                    }
                    if (this.defenseforce > 0) {
                        for (let t = 0; t < this.units.length; t++) {
                            if (!(this.units[t].defendsplatter > 0)) {

                                if (this.units[t].nymph == 2) {
                                    if (Math.random() < 7 / this.defenseforce) { //2
                                        // if (this.units[t].index == this.units[t].realPath.length - 1) {

                                        this.units[t].ultrabreak = this.attackedAt
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                        this.units[t].defendsplatter = this.units[t].movespeed
                                        // }
                                    }
                                } else {
                                    if (this.units[t].nymph !== 1) {
                                        if ((this.units[t].imago == 1) && (this.units[t].health <= (this.units[t].maxhealth * .25))) { //.9 //Math.random() < .4
                                            continue
                                        }
                                        // if (this.units[t].index == this.units[t].realPath.length - 1) {

                                        this.units[t].ultrabreak = this.attackedAt
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                        this.units[t].defendsplatter = this.units[t].movespeed
                                        // }
                                    }
                                }

                            } else {

                                this.units[t].defendsplatter--
                            }
                        }
                    } else {
                        for (let t = 0; t < this.units.length; t++) {

                            if (!(this.units[t].defendsplatter > 0)) {


                                // if (Math.random() < 7 / this.defenseforce) { //div by zero lol
                                if (this.units[t].nymph !== 1) {
                                    if ((this.units[t].imago == 1) && (this.units[t].health <= (this.units[t].maxhealth * .25))) { //.9 //Math.random() < .4
                                        continue
                                    }
                                    if (this.units[t].index == this.units[t].realPath.length - 1) {

                                        this.units[t].ultrabreak = this.attackedAt
                                        this.units[t].ultrawalk = 0
                                        this.units[t].defendsplatter = this.units[t].movespeed
                                        this.units[t].start = this.units[t].tile
                                    }
                                }
                                // }
                            } else {

                                this.units[t].defendsplatter--
                            }
                        }

                    }
                }

                if (this.chunk % this.clickrate == 0) {
                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].realPath.length - 1 == this.units[t].index) { //} || this.units[t].realPath[this.units[t].index].walkable !== true) {
                            if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {
                                let max = 999999999
                                for (let h = 0; h < sandmap.hotrocks.length; h++) {
                                    if (sandmap.hotrocks[h].walkable == true && sandmap.hotrocks[h].occupied == false && this.blocks[sandmap.hotrocks[h].t][sandmap.hotrocks[h].k].markdraw == 1) {
                                        const link = (new LineOP(this.units[t].tile, sandmap.hotrocks[h])).hypotenuse()
                                        // //////////console.log(link)
                                        if (link < max) {
                                            max = link
                                            index = h
                                        }
                                    }
                                }

                                if (typeof sandmap.hotrocks[index] !== "undefined") {
                                    if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                                        // if(((Math.abs(this.units[t].attacktarget.tile.x-this.units[t].tile.x) > (this.units[t].sight*10))  && (Math.abs(this.units[t].attacktarget.tile.y-this.units[t].tile.y) > (this.units[t].sight*10)))){
                                        //     this.units[t].ultrabreak = sandmap.hotrocks[index]
                                        //     this.units[t].ultrawalk = 0
                                        //     this.units[t].start = this.units[t].tile
                                        // }else{
                                        //     //////////console.log(":?")
                                        //     if(this.units[t].nymph == 1){
                                        //     //////////console.log(":?!!!")
                                        //         this.units[t].ultrabreak = sandmap.hotrocks[index]
                                        //         this.units[t].ultrawalk = 0
                                        //         this.units[t].start = this.units[t].tile
                                        //     }
                                        // }
                                    } else {
                                        j++


                                        this.units[t].ultrabreak = sandmap.hotrocks[index]
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                        if (j > 11) { //6
                                            break
                                        }
                                    }
                                } else {
                                    if (Math.random() < (1 / this.units.length)) {
                                        if (this.seen.length > 0) {
                                            // const block = this.seen[Math.floor(Math.random() * this.seen.length)]
                                            const block = this.seen[this.seen.length - 1]
                                            if (block.occupied == true) {
                                                const blockbackup = this.seen[(Math.floor(this.seen.length * Math.random()))]


                                                this.units[t].ultrabreak = blockbackup
                                                this.units[t].ultrawalk = 0
                                                this.units[t].start = this.units[t].tile
                                            } else {

                                                this.units[t].ultrabreak = block
                                                this.units[t].ultrawalk = 0
                                                this.units[t].start = this.units[t].tile
                                            }
                                        }
                                    }
                                }
                            }
                        } else if (typeof this.units[t].realPath[this.units[t].index + 1] !== "undefined") {
                            if (this.units[t].realPath[this.units[t].index + 1].walkable !== true) {
                                if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {
                                    let max = 999999999
                                    for (let h = 0; h < sandmap.hotrocks.length; h++) {
                                        if (sandmap.hotrocks[h].walkable == true && sandmap.hotrocks[h].occupied == false && this.blocks[sandmap.hotrocks[h].t][sandmap.hotrocks[h].k].markdraw == 1) {
                                            const link = (new LineOP(this.units[t].tile, sandmap.hotrocks[h])).hypotenuse()
                                            // //////////console.log(link)
                                            if (link < max) {
                                                max = link
                                                index = h
                                            }
                                        }
                                    }

                                    if (typeof sandmap.hotrocks[index] !== "undefined") {
                                        if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {

                                            // if(((Math.abs(this.units[t].attacktarget.tile.x-this.units[t].tile.x) > (this.units[t].sight*10))  && (Math.abs(this.units[t].attacktarget.tile.y-this.units[t].tile.y) > (this.units[t].sight*10)))){
                                            //     this.units[t].ultrabreak = sandmap.hotrocks[index]
                                            //     this.units[t].ultrawalk = 0
                                            //     this.units[t].start = this.units[t].tile
                                            // }else{
                                            //     //////////console.log(":?!")
                                            //     if(this.units[t].nymph == 1){
                                            //     //////////console.log(":?!!!?")
                                            //         this.units[t].ultrabreak = sandmap.hotrocks[index]
                                            //         this.units[t].ultrawalk = 0
                                            //         this.units[t].start = this.units[t].tile
                                            //     }
                                            // }
                                        } else {
                                            j++


                                            this.units[t].ultrabreak = sandmap.hotrocks[index]
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            if (j > 11) { //6
                                                break
                                            }
                                        }
                                    } else {
                                        if (Math.random() < .03) {
                                            if (this.seen.length > 0) {
                                                // const block = this.seen[Math.floor(Math.random() * this.seen.length)]
                                                const block = this.seen[this.seen.length - 1]
                                                if (block.occupied == true) {
                                                    const blockbackup = this.seen[(Math.floor(this.seen.length * Math.random()))]


                                                    this.units[t].ultrabreak = blockbackup
                                                    this.units[t].ultrawalk = 0
                                                    this.units[t].start = this.units[t].tile
                                                } else {

                                                    this.units[t].ultrabreak = block
                                                    this.units[t].ultrawalk = 0
                                                    this.units[t].start = this.units[t].tile
                                                }
                                            }
                                        } else {
                                            if (this.units[t].nymph == 1) {
                                                if (Math.random() < .02 * this.clickrate) { //.01
                                                    // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]

                                                    let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                                    let u = 0
                                                    while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                                        u++
                                                        block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                                    }

                                                    this.units[t].ultrabreak = block
                                                    this.units[t].ultrawalk = 0
                                                    this.units[t].start = this.units[t].tile
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                if (Math.random() < .25) { //.1
                    for (let t = 0; t < this.units.length; t++) {
                        if (!(this.units[t].attacksplatter > 0)) {

                            if (this.units[t].attacktarget.health <= 0) {

                                if (Math.random() < .1) {
                                    if (this.units[t].nymph == 1) {
                                        this.units[t].attackmove()
                                        this.units[t].attacksplatter = this.units[t].movespeed
                                    }
                                }

                                if (Math.random() < .98) {
                                    if (this.units[t].nymph == 2) {
                                        //this.units[t].attackmoveunit()
                                        //test case 123456
                                        this.units[t].attackmove()
                                        this.units[t].attacksplatter = this.units[t].movespeed
                                    }
                                } else {
                                    if (this.units[t].nymph == 2) {
                                        this.units[t].attackmove()
                                        this.units[t].attacksplatter = this.units[t].movespeed
                                    }
                                }
                                if (this.units[t].imago == 2) {
                                    if (this.units[t].tile.sourcerock >= 1) {
                                        this.units[t].submerged = 1
                                    }
                                    if (Math.random() < .98) {
                                        //this.units[t].attackmoveunit()
                                        //test case 123456
                                        this.units[t].attackmove()
                                        this.units[t].attacksplatter = this.units[t].movespeed
                                    } else {
                                        this.units[t].attackmove()
                                        this.units[t].attacksplatter = this.units[t].movespeed
                                    }
                                }
                            }

                        } else {
                            this.units[t].attacksplatter--
                        }



                    }
                }

                // if (Math.random() < (this.units.length * .001)) {
                let n = 0
                let k = 0
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].nymph == 1) {
                        n++
                    }
                    if (this.units[t].nymph == 2) {
                        k++
                    }
                }
                if (n / k > 5 && (n > 12 || (this.hotrock > 400 && n > 9)) && (((Math.random() * this.units.length) * .02) > .3)) {
                    for (let t = this.units.length - 1; t >= 0; t--) {
                        if (this.units[t].nymph == 1) {
                            this.units[t].metamorph1()
                            break
                        }
                    }
                } else {
                    if (Math.random() < (5 / this.units.length)) { //.3 //1
                        for (let t = this.units.length - 1; t >= 0; t--) {
                            if (this.units[t].imago == 1 || this.units[t].imago == 2) {
                                this.units[t].makeNymph()
                                if (Math.random() < .05) {
                                    break
                                }
                            }
                        }
                    }
                }
                // }

                // if (Math.random() < (this.units.length * .0009)) {
                if (this.units.length * 60 > this.hotrock) {

                    for (let t = 0; t < this.units.length; t++) {
                        if (Math.random() < .5) {
                            if (this.units[t].nymph == 2) {
                                this.units[t].metamorph2()
                                break
                            }
                        } else {
                            if (this.units[t].nymph == 2) {
                                this.units[t].metamorph3()
                                break
                            }
                        }
                    }

                }
                // }


                // if (this.units.length > 25) {
                //     if (this.attacktimeout <= 0) {
                //         this.aimode = 1
                //         this.attacktimeout = 3000
                //     }
                //     this.attacktimeout--
                // }
            }



        }

        retreatAlternatecolditzlerAI() {

            this.defenseLimit--
            if (this.nymphstop > -2) {
                this.nymphstop--
            }
            let index = sandmap.hotrocks.length + 1
            this.chunk++
            let j = 0

            if (this.chunk % this.clickrate == 0) {
                //this.units.sort((a, b) => (Math.random() > .5) ? 1 : -1)
            } else {
                return
            }


            let unitcountersee = 0
            let buildingsseecount = 0
            let lastseen = {}
            let epowercount = 0
            let healthMeter = 999999999
            for(let d = 1;d<sandmap.players.length;d++){
            const indexer = Math.abs((sandmap.players.indexOf(this) + d)%sandmap.players.length)

            for (let t = 0; t < sandmap.players[indexer].buildings.length; t++) {
                if (this.blocks[sandmap.players[indexer].buildings[t].tile.t][sandmap.players[indexer].buildings[t].tile.k].markdraw == 1) { //can see this unit
                    buildingsseecount++
                    if (healthMeter > sandmap.players[indexer].buildings[t].health) {
                        lastseen = sandmap.blocks[sandmap.players[indexer].buildings[t].tile.t][sandmap.players[indexer].buildings[t].tile.k]
                    }
                }
            }

            for (let t = 0; t < sandmap.players[indexer].units.length; t++) {
                if (this.blocks[sandmap.players[indexer].units[t].tile.t][sandmap.players[indexer].units[t].tile.k].markdraw == 1) {//can see this building
                    unitcountersee++
                    if (healthMeter > sandmap.players[indexer].units[t].health) {
                        healthMeter = sandmap.players[indexer].units[t].health
                        lastseen = sandmap.blocks[sandmap.players[indexer].units[t].tile.t][sandmap.players[indexer].units[t].tile.k]
                    }
                    epowercount += sandmap.players[indexer].units[t].health //add up their health (not super fair to players, as they only get the healthbar graphic)
                }
            }
        }

            let powercount = 0
            for (let t = 0; t < this.units.length; t++) {
                if ((unitcountersee > 0 || buildingsseecount > 0) && (this.units[t].health > 400)) { //calculate strength of current army
                    if ((this.units[t].health > this.units[t].maxhealth * .25)) {
                        if (!(this.units[t].defendsplatter > 0)) {
                            powercount += this.units[t].health
                        }
                    }
                }
            }

            if (this.units.length > 0) {
                for (let t = 0; t < this.units.length; t++) {
                    if ((unitcountersee > 0 || buildingsseecount > 0) && (this.units[t].health > 400)) {
                        if (this.units[t].imago == 2) {
                            if (this.units[t].tile.ice == 1 || this.units[t].tile.builtOn == 1) {
                            } else {
                                this.units[t].submerged = 0 //1?
                            }
                        }
                        if ((this.units[t].health > this.units[t].maxhealth * .25)) {
                            if (!(this.units[t].defendsplatter > 0)) {
                                if (!(this.units[t].isInRange(this.units[t].attacktarget && this.units[t].attacktarget.health > 0))) {
                                    if ((epowercount*2) <= powercount) {
                                        let gj = 0
                                        while (lastseen.walkable == false) {
                                            if (gj > 100) {
                                                break
                                            }
                                            lastseen = sandmap.blocks[Math.min(Math.max(lastseen.t - (Math.sign(Math.random() - .5)), 0), worldscale - 1)][Math.min(Math.max(lastseen.k - (Math.sign(Math.random() - .5)), 0), worldscale - 1)]
                                        }
                                        this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - lastseen.t) + Math.abs(this.units[t].tile.k - lastseen.k)) * this.units[t].movespeed * 1
                                        this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - lastseen.t) + Math.abs(this.units[t].tile.k - lastseen.k)) * this.units[t].movespeed) * 1
                                        this.units[t].ultrabreak = lastseen
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                        this.units[t].defendsplatter = this.units[t].movespeed * 10 //prevent spam
                                    }
                                }
                            } else {
                                this.units[t].defendsplatter--
                            }
                        }
                    }
                }
            }

            for (let t = 0; t < this.units.length; t++) {
                this.units[t].smartAttack()
            }


            if (true) {
                let j = 0

                let imagocount = 0
                let scucount = 0
                let nymphcount = 0
                let unitx = 0
                let unity = 0

                for (let t = this.units.length - 1; t >= 0; t--) {
                    if (this.units[t].nymph == 2) {
                        scucount++
                    }
                    if (this.units[t].imago >= 1) {
                        imagocount++
                    }
                    if (this.units[t].nymph == 1) {
                        nymphcount++
                    }
                    unitx += this.units[t].body.x
                    unity += this.units[t].body.y
                }
                unitx /= this.units.length
                unity /= this.units.length


                if (this.defending >= 1) {
                    this.nymphstop += 10

                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].nymph == 1 || this.units[t].nymph == 2 || (imagocount <= 1 && (this.units[t].imago == 1 || this.units[t].imago == 2))) {
                            if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < (140) && (this.units[t].health < 365 || (this.units[t].health < 400 && imagocount <= 1))) { //200 distance //300 health
                                if (this.units.length > 0) { //lol

                                    let block = sandmap.blocks[Math.min(Math.max(this.units[0].tile.t - (Math.sign(Math.random() - .5)), 0), worldscale - 1)][Math.min(Math.max(this.units[0].tile.k - (Math.sign(Math.random() - .5)), 0), worldscale - 1)]


                                    for (let g = 0; g < this.units.length; g++) {
                                        if (Math.abs(this.units[g].tile.x - this.attackedAt.x) + Math.abs(this.units[g].tile.y - this.attackedAt.y) > (140)) {
                                            let vec = new Vector(this.units[t].body, this.units[g].body.x - this.units[t].body.x, this.units[g].body.y - this.units[t].body.y)
                                            if (vec.isToward(this.attackedAt)) {
                                            } else {
                                                block = sandmap.blocks[Math.min(Math.max(this.units[g].tile.t - (Math.sign(Math.random() - .5)), 0), worldscale - 1)][Math.min(Math.max(this.units[g].tile.k - (Math.sign(Math.random() - .5)), 0), worldscale - 1)]
                                                break
                                            }
                                        }
                                    }
                                    // if (this.units[t].hotrockrepathlimit <= 0) {
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * 1.01
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed
                                    this.units[t].ultrabreak = block
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                    // }


                                } else {

                                    if (Math.abs(this.units[t].tile.x - this.units[t].realPath[this.units[t].realPath.length - 1].x) + Math.abs(this.units[t].tile.y - this.units[t].realPath[this.units[t].realPath.length - 1].y) < (worldscale * .25 * 10)) {
                                        let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                        let u = 0
                                        while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1) || (Math.abs(this.units[t].tile.x - block.x) + Math.abs(this.units[t].tile.y - block.y) < (worldscale * .25 * 10))) && u < 1000) {
                                            u++
                                            block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                        }
                                        // 

                                        // if (this.units[t].hotrockrepathlimit <= 0) {
                                        this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * 1.01
                                        this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed
                                        this.units[t].ultrabreak = block
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                        // }


                                    } else {

                                    }

                                }
                            }
                        }
                    }
                }


                let disset = 0

                for (let t = this.units.length - 1; t >= 0; t--) {
                    disset += Math.abs(unitx - this.units[t].body.x)
                    disset += Math.abs(unity - this.units[t].body.y)
                }
                disset /= this.units.length
                // //////////console.log(disset, "disset")
                if (this.defending >= 1) { //18

                    //////////console.log(disset, "disset")
                    if (scucount > 0) {
                        if (imagocount > 0) {
                            if (nymphcount < scucount) {
                                for (let t = this.units.length - 1; t >= 0; t--) {
                                    if (this.units[t].nymph == 2) {
                                        let taker = 0
                                        taker += Math.abs(unitx - this.units[t].body.x)
                                        taker += Math.abs(unity - this.units[t].body.y)
                                        //////////console.log(taker, "taker")
                                        if (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k) <= (worldscale * .5)) {
                                            // if(taker > disset){
                                            this.units[t].metamorph2()
                                            // }
                                        }
                                    }
                                }
                            } else {
                                for (let t = this.units.length - 1; t >= 0; t--) {
                                    if (this.units[t].nymph == 1) {
                                        let taker = 0
                                        taker += Math.abs(unitx - this.units[t].body.x)
                                        taker += Math.abs(unity - this.units[t].body.y)
                                        //////////console.log(taker, "taker")
                                        if (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k) <= (worldscale * .5)) {
                                            // if(taker > disset){
                                            this.units[t].metamorph1()
                                            this.nymphstop += 2
                                            // }
                                        }
                                    }
                                }
                            }
                        } else {
                            for (let t = this.units.length - 1; t >= 0; t--) {
                                if (this.units[t].nymph == 2) {
                                    let taker = 0
                                    taker += Math.abs(unitx - this.units[t].body.x)
                                    taker += Math.abs(unity - this.units[t].body.y)
                                    //////////console.log(taker, "taker")
                                    if (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k) <= (worldscale * .5)) {
                                        // if(taker > disset){
                                        this.units[t].metamorph2()
                                        // }
                                    }
                                }
                            }
                        }
                    } else {
                        for (let t = this.units.length - 1; t >= 0; t--) {
                            if (this.units[t].nymph == 1) {
                                let taker = 0
                                taker += Math.abs(unitx - this.units[t].body.x)
                                taker += Math.abs(unity - this.units[t].body.y)
                                //////////console.log(taker, "taker")
                                if (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k) <= (worldscale * .65)) { //5
                                    // if(taker > disset){
                                    this.units[t].metamorph1()
                                    this.nymphstop += 2
                                    // }
                                }
                            }
                        }
                    }




                }
                if (this.defending >= 32 && !(this.defenseLimit > 0)) { //25 not 32 because they favor early advantage // screwing with this?
                    this.defending = 0
                    this.defenseforce = 0
                    this.defenseLimit = 151
                    for (let t = this.units.length - 1; t >= 0; t--) {
                        if (this.units[t].nymph == 2) {
                            if (this.units[t].health >= 300) {
                                this.defenseforce++
                            }
                        }
                        // if (this.units[t].nymph == 2) {
                        //     this.units[t].metamorph2()
                        // }
                        // if (this.units[t].nymph == 1) {
                        //     this.units[t].metamorph1()
                        // }
                        if (this.units[t].imago == 2) {
                            if (this.units[t].tile.ice == 1 || this.units[t].tile.builtOn == 1) {
                                this.units[t].submerged = 0 //1?
                            }
                        }
                    }
                    if (this.defenseforce > 0) {
                        for (let t = 0; t < this.units.length; t++) {
                            if (!(this.units[t].defendsplatter > 0)) {

                                if (this.units[t].nymph == 2 && imagocount > 0 && (imagocount >= scucount) && this.units[t].health >= 300) {
                                    // if (Math.random() < 7 / this.defenseforce) { //2 //7 //10  //4
                                    // if (this.units[t].index == this.units[t].realPath.length - 1) {

                                    if (this.units[t].defensepathlimit <= 0) {
                                        this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                        this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 2
                                        this.units[t].ultrabreak = this.attackedAt
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                        this.units[t].defendsplatter = (this.units[t].movespeed * 3)
                                        // }
                                        // }
                                    }
                                } else {
                                    if (this.units[t].nymph !== 1) {
                                        if ((this.units[t].imago == 1 || this.units[t].imago == 2) && (this.units[t].health <= (this.units[t].maxhealth * .25))) { //.9 //Math.random() < .4
                                            continue
                                        }
                                        // if (this.units[t].index == this.units[t].realPath.length - 1) {
                                        if (imagocount > 2) {
                                            if (this.units[t].defensepathlimit <= 0) {
                                                if (this.units[t].health >= 300) {
                                                    imagocount--
                                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 2.8
                                                    this.units[t].ultrabreak = this.attackedAt
                                                    this.units[t].ultrawalk = 0
                                                    this.units[t].start = this.units[t].tile
                                                    this.units[t].defendsplatter = 10 //this.units[t].movespeed
                                                }
                                            }
                                        }
                                        // }
                                    }
                                }

                            } else {

                                this.units[t].defendsplatter--
                            }
                        }
                    } else {
                        for (let t = 0; t < this.units.length; t++) {

                            if (!(this.units[t].defendsplatter > 0)) {


                                // if (Math.random() < 7 / this.defenseforce) { //div by zero lol
                                if (this.units[t].nymph !== 1) {
                                    if ((this.units[t].imago == 1) && (this.units[t].health <= (this.units[t].maxhealth * .25))) { //.9 //Math.random() < .4
                                        continue
                                    }
                                    if (this.units[t].index == this.units[t].realPath.length - 1) {
                                        if (this.units[t].defensepathlimit <= 0) {
                                            if (this.units[t].health >= 300) {
                                                this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                                this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 2.8
                                                this.units[t].ultrabreak = this.attackedAt
                                                this.units[t].ultrawalk = 0
                                                this.units[t].start = this.units[t].tile
                                                this.units[t].defendsplatter = 0 //this.units[t].movespeed
                                            }
                                        }
                                    }
                                }
                                // }
                            } else {

                                this.units[t].defendsplatter--
                            }
                        }

                    }
                }

                if (this.chunk % this.clickrate == 0) {


                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].nymph == 2) {
                            if (this.hotrock >= 240) {
                                if (this.units[t].health / this.units[t].maxhealth <= .6) {
                                    if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                                    } else {
                                        if (this.units[t].tile.hotrock >= 1) {
                                            this.units[t].metamorph2()
                                        }
                                        // //////////console.log("hit")
                                    }
                                }
                            }
                        }
                    }
                    // const reasonableChance = ((this.units.length/unitcap) * 3)

                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].index >= this.units[t].realPath.length - Math.ceil(this.units.length * .25)) {
                            this.units[t].hotrockrepathlimit -= this.units[t].movespeed
                            this.units[t].defensepathlimit -= this.units[t].movespeed
                        }
                    }

                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].tile.hotrock <= 0 || this.seenrocks.length < this.units.length) {
                            if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                            } else {
                                // if(Math.random() < reasonableChance  || this.seenrocks.length < this.units.length){
                                if ((this.units[t].nymph == 1 && !(this.seenrocks.length < this.units.length && (imagocount == 0 && scucount == 0)))) {
                                    if (this.units[t].tile.hotrock <= 0) {
                                        if (this.units[t].hotrockrepathlimit <= 0) {
                                            // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                            let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                            let u = 0
                                            while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                                u++
                                                block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                            }
                                            this.units[t].ultrabreak = block
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            let dlockdi = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k))
                                            this.units[t].hotrockrepathlimit = (Math.max(dlockdi, 2) * (this.units[t].movespeed)) * 2
                                        }
                                    }
                                } else {
                                    if (this.units[t].hotrockrepathlimit <= 0) {
                                        // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]

                                        let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                        let u = 0
                                        while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                            u++
                                            block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                        }
                                        this.units[t].ultrabreak = block
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                        let dlockdi = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k))
                                        this.units[t].hotrockrepathlimit = Math.max(dlockdi, 5) * (2)
                                    }
                                }
                                // }
                            }
                        }
                    }

                    // for (let t = 0; t < this.units.length; t++) {
                    //     if (this.units[t].nymph == 1) {
                    //         if(this.units[t].hotrockrepathlimit <= 0){
                    //             const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]

                    //             this.units[t].ultrabreak = block
                    //             this.units[t].ultrawalk = 0
                    //             this.units[t].start = this.units[t].tile
                    //         }
                    //         }
                    // }


                    for (let t = 0; t < this.units.length; t++) {
                        // if (this.units[t].realPath.length - 1 == this.units[ t].index) { //} || this.units[t].realPath[this.units[t].index].walkable !== true) {
                        if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {
                            if (this.units[t].hotrockrepathlimit <= 0) {
                                let max = 999999999
                                let drytrack = 0
                                for (let h = 0; h < sandmap.hotrocks.length; h++) {
                                    if (sandmap.hotrocks[h].walkable == true && sandmap.hotrocks[h].occupied == false && this.blocks[sandmap.hotrocks[h].t][sandmap.hotrocks[h].k].markdraw == 1) {
                                        const link = (new LineOP(this.units[t].tile, sandmap.hotrocks[h])).hypotenuse()
                                        // //////////console.log(link)
                                        if (link < max) {
                                            max = link
                                            index = h
                                            if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                                            } else {
                                                this.units[t].ultrabreak = sandmap.hotrocks[index]
                                                this.units[t].ultrawalk = 0
                                                this.units[t].start = this.units[t].tile
                                                drytrack = Math.floor((this.units[t].movespeed) * (max * .1))
                                            }
                                        }
                                    }
                                }
                                if (drytrack != 0) {
                                    this.units[t].hotrockrepathlimit = drytrack
                                }
                            }

                        }
                    }



                }

                if (Math.random() < .25) { //.1
                    for (let t = 0; t < this.units.length; t++) {
                        if (!(this.units[t].attacksplatter > 0)) {

                            if (this.units[t].attacktarget.health <= 0 || !this.units[t].isInRange(this.units[t].attacktarget)) {

                                this.units[t].attackmove()
                                this.units[t].attacksplatter = this.units[t].movespeed

                                if (this.units[t].imago == 2) {
                                    if (this.units[t].tile.sourcerock >= 1) {
                                        this.units[t].submerged = 1
                                    }
                                }
                            }

                        } else {
                            this.units[t].attacksplatter--
                        }



                    }
                }

                // if (Math.random() < (this.units.length * .001)) {
                let n = 0
                let k = 0
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].nymph == 1) {
                        n++
                    }
                    if (this.units[t].nymph == 2) {
                        k++
                    }
                }
                if (((n / k > 5 && (n > 12 || (this.hotrock > 290 && n > 9)) && (((Math.random() * this.units.length) * .02) > 1)) || (imagocount == 0 && scucount == 0)) && ((imagocount * .3) >= scucount)) {
                    for (let t = this.units.length - 1; t >= 0; t--) {
                        if (this.units[t].nymph == 1) {
                            this.units[t].metamorph1()
                            // break
                        }
                    }
                } else {
                    if (this.hotrock > 700) {
                        this.nymphstop = 0
                    }
                    // if (Math.random() < (5 / this.units.length)) { //.3 //1
                    if (nymphcount < (this.units.length * .8) || (this.units.length - 7) < this.seenrocks.length || this.hotrock > 289) {
                        for (let t = this.units.length - 1; t >= 0; t--) {
                            if (this.units[t].imago == 1 || this.units[t].imago == 2) {
                                if (this.nymphstop <= 0) {
                                    this.units[t].makeNymph()
                                }
                                if (Math.random() < .05) {
                                    break
                                }
                            }
                        }
                    }
                    // }
                }
                // }

                if (500 < this.hotrock && scucount > imagocount) {
                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].nymph == 2) {
                            this.units[t].metamorph2()
                        }
                    }
                }

                if ((this.units.length * .5) + 240 < this.hotrock) {

                    for (let t = 0; t < this.units.length; t++) {
                        if (Math.random() < .5) {
                            if (this.units[t].nymph == 2) {
                                this.units[t].metamorph2()
                                break
                            }
                        } else {
                            if (this.units[t].nymph == 2) {
                                this.units[t].metamorph3()
                                break
                            }
                        }
                    }

                }
                // }
                if ((this.units.length * 5) + 440 < this.hotrock) {

                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].nymph == 1) {
                            this.units[t].metamorph1()
                            break
                        }
                    }

                }


                // if (this.units.length > 25) {
                //     if (this.attacktimeout <= 0) {
                //         this.aimode = 1
                //         this.attacktimeout = 3000
                //     }
                //     this.attacktimeout--
                // }
            }



        }
        alternatecolditzlerAI() {

            this.defenseLimit--
            this.nymphstop--
            let index = sandmap.hotrocks.length + 1
            this.chunk++
            let j = 0

            if (this.chunk % this.clickrate == 0) {
                //this.units.sort((a, b) => (Math.random() > .5) ? 1 : -1)
            } else {
                return
            }



            // if (this.defending >= 1) {

            //     for (let t = 0; t < this.units.length; t++) {
            //         if (this.units[t].nymph == 1 || this.units[t].nymph == 2) {
            //             if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < 200 && this.units[t].health < 300) {
            //                 if (this.units.length > 0) { //lol

            //                     let block = sandmap.blocks[Math.min(Math.max(this.units[0].tile.t-(Math.sign(Math.random()-.5)),0),worldscale-1)][Math.min(Math.max(this.units[0].tile.k-(Math.sign(Math.random()-.5)),0),worldscale-1)]


            //                     for(let g = 0;g<this.units.length;g++){
            //                         if(Math.abs(this.units[g].tile.x - this.attackedAt.x) + Math.abs(this.units[g].tile.y - this.attackedAt.y) > 300){
            //                             block = sandmap.blocks[Math.min(Math.max(this.units[g].tile.t-(Math.sign(Math.random()-.5)),0),worldscale-1)][Math.min(Math.max(this.units[g].tile.k-(Math.sign(Math.random()-.5)),0),worldscale-1)]
            //                             break
            //                         }
            //                     }
            //                     // if (this.units[t].hotrockrepathlimit <= 0) {
            //                     this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * 1.01
            //                     this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed
            //                     this.units[t].ultrabreak = block
            //                     this.units[t].ultrawalk = 0
            //                     this.units[t].start = this.units[t].tile
            //                     // }


            //                 } else {

            //                     if (Math.abs(this.units[t].tile.x - this.units[t].realPath[this.units[t].realPath.length - 1].x) + Math.abs(this.units[t].tile.y - this.units[t].realPath[this.units[t].realPath.length - 1].y) < (worldscale * .25 * 10)) {
            //                         let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
            //                         let u = 0
            //                         while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1) || (Math.abs(this.units[t].tile.x - block.x) + Math.abs(this.units[t].tile.y - block.y) < (worldscale * .25 * 10))) && u < 1000) {
            //                             u++
            //                             block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
            //                         }
            //                         // 

            //                         // if (this.units[t].hotrockrepathlimit <= 0) {
            //                         this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * 1.01
            //                         this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed
            //                         this.units[t].ultrabreak = block
            //                         this.units[t].ultrawalk = 0
            //                         this.units[t].start = this.units[t].tile
            //                         // }


            //                     } else {

            //                     }

            //                 }
            //             }
            //         }
            //     }
            // }


            if (true) {
                let j = 0

                let imagocount = 0
                let scucount = 0
                let nymphcount = 0
                let unitx = 0
                let unity = 0

                for (let t = this.units.length - 1; t >= 0; t--) {
                    if (this.units[t].nymph == 2) {
                        scucount++
                    }
                    if (this.units[t].imago >= 1) {
                        imagocount++
                    }
                    if (this.units[t].nymph == 1) {
                        nymphcount++
                    }
                    unitx += this.units[t].body.x
                    unity += this.units[t].body.y
                }
                unitx /= this.units.length
                unity /= this.units.length

                let disset = 0

                for (let t = this.units.length - 1; t >= 0; t--) {
                    disset += Math.abs(unitx - this.units[t].body.x)
                    disset += Math.abs(unity - this.units[t].body.y)
                }
                disset /= this.units.length
                // //////////console.log(disset, "disset")
                if (this.defending >= 1) { //18

                    //////////console.log(disset, "disset")
                    if (scucount > 0) {
                        if (imagocount > 0) {
                            if (nymphcount < scucount) {
                                for (let t = this.units.length - 1; t >= 0; t--) {
                                    if (this.units[t].nymph == 2) {
                                        let taker = 0
                                        taker += Math.abs(unitx - this.units[t].body.x)
                                        taker += Math.abs(unity - this.units[t].body.y)
                                        //////////console.log(taker, "taker")
                                        if (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k) <= (worldscale * .5)) {
                                            // if(taker > disset){
                                            this.units[t].metamorph2()
                                            // }
                                        }
                                    }
                                }
                            } else {
                                for (let t = this.units.length - 1; t >= 0; t--) {
                                    if (this.units[t].nymph == 1) {
                                        let taker = 0
                                        taker += Math.abs(unitx - this.units[t].body.x)
                                        taker += Math.abs(unity - this.units[t].body.y)
                                        //////////console.log(taker, "taker")
                                        if (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k) <= (worldscale * .5)) {
                                            // if(taker > disset){
                                            this.units[t].metamorph1()
                                            this.nymphstop += 2
                                            // }
                                        }
                                    }
                                }
                            }
                        } else {
                            for (let t = this.units.length - 1; t >= 0; t--) {
                                if (this.units[t].nymph == 2) {
                                    let taker = 0
                                    taker += Math.abs(unitx - this.units[t].body.x)
                                    taker += Math.abs(unity - this.units[t].body.y)
                                    //////////console.log(taker, "taker")
                                    if (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k) <= (worldscale * .5)) {
                                        // if(taker > disset){
                                        this.units[t].metamorph2()
                                        // }
                                    }
                                }
                            }
                        }
                    } else {
                        for (let t = this.units.length - 1; t >= 0; t--) {
                            if (this.units[t].nymph == 1) {
                                let taker = 0
                                taker += Math.abs(unitx - this.units[t].body.x)
                                taker += Math.abs(unity - this.units[t].body.y)
                                //////////console.log(taker, "taker")
                                if (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k) <= (worldscale * .65)) { //5
                                    // if(taker > disset){
                                    this.units[t].metamorph1()
                                    this.nymphstop += 2
                                    // }
                                }
                            }
                        }
                    }




                }
                if (this.defending >= 32 && !(this.defenseLimit > 0)) { //25 not 32 because they favor early advantage // screwing with this?
                    this.defending = 0
                    this.defenseforce = 0
                    this.defenseLimit = 151
                    for (let t = this.units.length - 1; t >= 0; t--) {
                        if (this.units[t].nymph == 2) {
                            this.defenseforce++
                        }
                        // if (this.units[t].nymph == 2) {
                        //     this.units[t].metamorph2()
                        // }
                        // if (this.units[t].nymph == 1) {
                        //     this.units[t].metamorph1()
                        // }
                        if (this.units[t].imago == 2) {
                            if (this.units[t].tile.ice == 1 || this.units[t].tile.builtOn == 1) {
                                this.units[t].submerged = 0 //1?
                            }
                        }
                    }
                    if (this.defenseforce > 0) {
                        for (let t = 0; t < this.units.length; t++) {
                            if (!(this.units[t].defendsplatter > 0)) {

                                if (this.units[t].nymph == 2 && imagocount > 0 && (imagocount >= scucount)) {
                                    // if (Math.random() < 7 / this.defenseforce) { //2 //7 //10  //4
                                    // if (this.units[t].index == this.units[t].realPath.length - 1) {

                                    if (this.units[t].defensepathlimit <= 0) {
                                        this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                        this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 2
                                        this.units[t].ultrabreak = this.attackedAt
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                        this.units[t].defendsplatter = this.units[t].movespeed
                                        // }
                                        // }
                                    }
                                } else {
                                    if (this.units[t].nymph !== 1) {
                                        if ((this.units[t].imago == 1 || this.units[t].imago == 2) && (this.units[t].health <= (this.units[t].maxhealth * .25))) { //.9 //Math.random() < .4
                                            continue
                                        }
                                        // if (this.units[t].index == this.units[t].realPath.length - 1) {
                                        if (imagocount > 2) {
                                            if (this.units[t].defensepathlimit <= 0) {
                                                imagocount--
                                                this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                                this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 2.8
                                                this.units[t].ultrabreak = this.attackedAt
                                                this.units[t].ultrawalk = 0
                                                this.units[t].start = this.units[t].tile
                                                this.units[t].defendsplatter = 0 //this.units[t].movespeed
                                            }
                                        }
                                        // }
                                    }
                                }

                            } else {

                                this.units[t].defendsplatter--
                            }
                        }
                    } else {
                        for (let t = 0; t < this.units.length; t++) {

                            if (!(this.units[t].defendsplatter > 0)) {


                                // if (Math.random() < 7 / this.defenseforce) { //div by zero lol
                                if (this.units[t].nymph !== 1) {
                                    if ((this.units[t].imago == 1) && (this.units[t].health <= (this.units[t].maxhealth * .25))) { //.9 //Math.random() < .4
                                        continue
                                    }
                                    if (this.units[t].index == this.units[t].realPath.length - 1) {
                                        if (this.units[t].defensepathlimit <= 0) {
                                            this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                            this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 2.8
                                            this.units[t].ultrabreak = this.attackedAt
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            this.units[t].defendsplatter = 0 //this.units[t].movespeed
                                        }
                                    }
                                }
                                // }
                            } else {

                                this.units[t].defendsplatter--
                            }
                        }

                    }
                }

                if (this.chunk % this.clickrate == 0) {


                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].nymph == 2) {
                            if (this.hotrock >= 240) {
                                if (this.units[t].health / this.units[t].maxhealth <= .6) {
                                    if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                                    } else {
                                        if (this.units[t].tile.hotrock >= 1) {
                                            this.units[t].metamorph2()
                                        }
                                        // //////////console.log("hit")
                                    }
                                }
                            }
                        }
                    }
                    // const reasonableChance = ((this.units.length/unitcap) * 3)

                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].index >= this.units[t].realPath.length - Math.ceil(this.units.length * .25)) {
                            this.units[t].hotrockrepathlimit -= this.units[t].movespeed
                            this.units[t].defensepathlimit -= this.units[t].movespeed
                        }
                    }

                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].tile.hotrock <= 0 || this.seenrocks.length < this.units.length) {
                            if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                            } else {
                                // if(Math.random() < reasonableChance  || this.seenrocks.length < this.units.length){
                                if ((this.units[t].nymph == 1 && !(this.seenrocks.length < this.units.length && (imagocount == 0 && scucount == 0)))) {
                                    if (this.units[t].tile.hotrock <= 0) {
                                        if (this.units[t].hotrockrepathlimit <= 0) {
                                            // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                            let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                            let u = 0
                                            while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                                u++
                                                block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                            }
                                            this.units[t].ultrabreak = block
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            let dlockdi = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k))
                                            this.units[t].hotrockrepathlimit = (Math.max(dlockdi, 2) * (this.units[t].movespeed)) * 2
                                        }
                                    }
                                } else {
                                    if (this.units[t].hotrockrepathlimit <= 0) {
                                        // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]

                                        let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                        let u = 0
                                        while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                            u++
                                            block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                        }
                                        this.units[t].ultrabreak = block
                                        this.units[t].ultrawalk = 0
                                        this.units[t].start = this.units[t].tile
                                        let dlockdi = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k))
                                        this.units[t].hotrockrepathlimit = Math.max(dlockdi, 5) * (2)
                                    }
                                }
                                // }
                            }
                        }
                    }

                    // for (let t = 0; t < this.units.length; t++) {
                    //     if (this.units[t].nymph == 1) {
                    //         if(this.units[t].hotrockrepathlimit <= 0){
                    //             const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]

                    //             this.units[t].ultrabreak = block
                    //             this.units[t].ultrawalk = 0
                    //             this.units[t].start = this.units[t].tile
                    //         }
                    //         }
                    // }


                    for (let t = 0; t < this.units.length; t++) {
                        // if (this.units[t].realPath.length - 1 == this.units[ t].index) { //} || this.units[t].realPath[this.units[t].index].walkable !== true) {
                        if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {
                            if (this.units[t].hotrockrepathlimit <= 0) {
                                let max = 999999999
                                let drytrack = 0
                                for (let h = 0; h < sandmap.hotrocks.length; h++) {
                                    if (sandmap.hotrocks[h].walkable == true && sandmap.hotrocks[h].occupied == false && this.blocks[sandmap.hotrocks[h].t][sandmap.hotrocks[h].k].markdraw == 1) {
                                        const link = (new LineOP(this.units[t].tile, sandmap.hotrocks[h])).hypotenuse()
                                        // //////////console.log(link)
                                        if (link < max) {
                                            max = link
                                            index = h
                                            if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {
                                            } else {
                                                this.units[t].ultrabreak = sandmap.hotrocks[index]
                                                this.units[t].ultrawalk = 0
                                                this.units[t].start = this.units[t].tile
                                                drytrack = Math.floor((this.units[t].movespeed) * (max * .1))
                                            }
                                        }
                                    }
                                }
                                if (drytrack != 0) {
                                    this.units[t].hotrockrepathlimit = drytrack
                                }
                            }

                        }
                    }



                }

                if (Math.random() < .25) { //.1
                    for (let t = 0; t < this.units.length; t++) {
                        if (!(this.units[t].attacksplatter > 0)) {

                            if (this.units[t].attacktarget.health <= 0 || !this.units[t].isInRange(this.units[t].attacktarget)) {

                                this.units[t].attackmove()
                                this.units[t].attacksplatter = this.units[t].movespeed

                                if (this.units[t].imago == 2) {
                                    if (this.units[t].tile.sourcerock >= 1) {
                                        this.units[t].submerged = 1
                                    }
                                }
                            }

                        } else {
                            this.units[t].attacksplatter--
                        }



                    }
                }

                // if (Math.random() < (this.units.length * .001)) {
                let n = 0
                let k = 0
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].nymph == 1) {
                        n++
                    }
                    if (this.units[t].nymph == 2) {
                        k++
                    }
                }
                if (((n / k > 5 && (n > 12 || (this.hotrock > 290 && n > 9)) && (((Math.random() * this.units.length) * .02) > 1)) || (imagocount == 0 && scucount == 0)) && ((imagocount * .3) >= scucount)) {
                    for (let t = this.units.length - 1; t >= 0; t--) {
                        if (this.units[t].nymph == 1) {
                            this.units[t].metamorph1()
                            // break
                        }
                    }
                } else {
                    if (this.hotrock > 700) {
                        this.nymphstop = 0
                    }
                    // if (Math.random() < (5 / this.units.length)) { //.3 //1
                    if (nymphcount < (this.units.length * .8) || (this.units.length - 7) < this.seenrocks.length || this.hotrock > 289) {
                        for (let t = this.units.length - 1; t >= 0; t--) {
                            if (this.units[t].imago == 1 || this.units[t].imago == 2) {
                                if (this.nymphstop <= 0) {
                                    this.units[t].makeNymph()
                                }
                                if (Math.random() < .05) {
                                    break
                                }
                            }
                        }
                    }
                    // }
                }
                // }

                if (500 < this.hotrock && scucount > imagocount) {
                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].nymph == 2) {
                            this.units[t].metamorph2()
                        }
                    }
                }

                if ((this.units.length * .5) + 240 < this.hotrock) {

                    for (let t = 0; t < this.units.length; t++) {
                        if (Math.random() < .5) {
                            if (this.units[t].nymph == 2) {
                                this.units[t].metamorph2()
                                break
                            }
                        } else {
                            if (this.units[t].nymph == 2) {
                                this.units[t].metamorph3()
                                break
                            }
                        }
                    }

                }
                // }
                if ((this.units.length * 5) + 440 < this.hotrock) {

                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].nymph == 1) {
                            this.units[t].metamorph1()
                            break
                        }
                    }

                }


                // if (this.units.length > 25) {
                //     if (this.attacktimeout <= 0) {
                //         this.aimode = 1
                //         this.attacktimeout = 3000
                //     }
                //     this.attacktimeout--
                // }
            }



        }
        alternateHumanAI() {
            this.nymphstop--

            let dronecheckcount = 0
            for (let t = 0; t < this.units.length; t++) {
                if (this.units[t].drone == 1) {
                    dronecheckcount++
                }
            }


            // const indexer = Math.abs((sandmap.players.indexOf(this) - 1)
            // let unitcountersee = 0
            // let buildingsseecount = 0
            // let lastseen = {}

            // for(let t = 0;t<sandmap.players[indexer].buildings.length;t++){
            //     if (this.blocks[sandmap.players[indexer].buildings[t].tile.t][sandmap.players[indexer].buildings[t].tile.k].markdraw == 1) {
            //         buildingsseecount++
            //         lastseen = sandmap.blocks[sandmap.players[indexer].buildings[t].tile.t][sandmap.players[indexer].buildings[t].tile.k]
            //     }
            // }
            // for(let t = 0;t<sandmap.players[indexer].units.length;t++){
            //     if (this.blocks[sandmap.players[indexer].units[t].tile.t][sandmap.players[indexer].units[t].tile.k].markdraw == 1) {
            //         unitcountersee++
            //         lastseen = sandmap.blocks[sandmap.players[indexer].units[t].tile.t][sandmap.players[indexer].units[t].tile.k]
            //     }
            // }


            // this.defenseforce = 0
            // for (let t = 0; t < this.units.length; t++) {
            //     if (this.units[t].infantry == 1) {
            //         this.defenseforce++
            //     }
            //     if (this.units[t].infantry == 2) {
            //         this.defenseforce+=2
            //     }
            // }


            // if((unitcountersee > 0 || buildingsseecount > 0) && this.defenseforce >= unitcap*.33){
            //     // this.attackedAt = lastseen
            //     for(let t = 0;t<this.units.length;t++){
            //         if(!(this.units[t].defendsplatter > 0)){
            //             if(this.units[t].infantry == 1 || this.units[t].infantry == 2){
            //                 this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t-this.attackedAt.t) + Math.abs(this.units[t].tile.k-this.attackedAt.k)) * this.units[t].movespeed * .1
            //                 this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t-this.attackedAt.t) + Math.abs(this.units[t].tile.k-this.attackedAt.k)) * this.units[t].movespeed) * .1
            //                 this.units[t].ultrabreak = lastseen
            //                 this.units[t].ultrawalk = 0
            //                 this.units[t].start = this.units[t].tile
            //                 this.units[t].defendsplatter = this.units[t].movespeed
            //             }
            //             }else{
            //                 this.units[t].defendsplatter--
            //             }
            //     }
            // }

            for (let t = 0; t < this.units.length; t++) {

                // this.units[t].defendsplatter--
                if (this.units[t].harvester == 1) {
                    this.units[t].hotrockrepathlimit -= this.units[t].movespeed
                }
            }



            if (dronecheckcount < (worldscale / 64)) {
                for (let t = 0; t < this.buildings.length; t++) {
                    if (this.buildings[t].barracks == 2) {
                        this.buildings[t].makeScout()
                        break
                    }
                }
            }
            for (let t = 0; t < this.units.length; t++) {
                this.units[t].dronesplatter--
                if (this.units[t].drone == 1 && !(this.units[t].dronesplatter > 0)) {
                    if (!(this.units[t].droneage > 0)) {
                        this.units[t].droneage = worldscale
                    }
                    // if (typeof this.units[t].realPath[this.units[t].index + 1] == "undefined") {
                    if (this.units[t].realPath.length > this.units[t].index) {
                        if (campaignController.mission == -1) {
                            // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]

                            let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                            let u = 0
                            while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                u++
                                block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                            }
                            // //////////console.log("fixes")
                            this.units[t].ultrabreak = block
                            this.units[t].ultrawalk = 0
                            this.units[t].start = this.units[t].tile
                            this.units[t].dronesplatter = 20 + this.units[t].droneage
                            this.units[t].droneage += Math.ceil(Math.floor(Math.sqrt(worldscale)) * .25)
                            this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed
                            this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * 1.1

                        }
                    }
                }
            }



            // if (this.hotrock > (this.racksflag * 75)) {
            //     //////////console.log("earthoid effect")
            //     if (this.racks == 1) {
            //         this.racksflag += 4
            //     }
            //     this.racks = 0
            //     this.lab = 0
            // }


            if (campaignController.mission <= 4 && campaignController.mission > -1) {
                // //////////console.log("firs")
                if (this.defending >= 1) {
                    // //////////console.log("2")
                    this.defending = 0
                    this.defenseforce = 0
                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].infantry == 1) {
                            this.defenseforce++
                        }
                    }
                    for (let t = 0; t < this.buildings.length; t++) {
                        if (this.buildings[t].barracks == 1) {
                            if (this.hotrock > 40) { // 40??
                                this.buildings[t].makeInfantry()
                            }
                        }
                    }
                    if (this.defenseforce > 0) {
                        for (let t = 0; t < this.units.length; t++) {

                            if (!(this.units[t].defendsplatter > 0)) {
                                // //////////console.log(Math.abs(this.units[t].tile.x-this.attackedAt.x) + Math.abs(this.units[t].tile.y-this.attackedAt.y), Math.abs(this.units[t].tile.x-this.attackedAt.x), Math.abs(this.units[t].tile.y-this.attackedAt.y))
                                if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < (170)) { //36
                                    // //////////console.log("thrhr")
                                    // //////////console.log(this.units[t].cooloff)
                                    if (this.units[t].cooloff <= 0) {
                                        this.units[t].cooloff = 1
                                        // 
                                        this.units[t].ultrabreak = this.attackedAt
                                        this.units[t].ultrawalk = 0
                                        this.units[t].defendsplatter = this.units[t].movespeed
                                        this.units[t].start = this.units[t].tile
                                    } else {
                                        this.units[t].cooloff = 0
                                    }

                                }
                            } else {
                                this.units[t].defendsplatter--
                            }
                        }
                    } else {

                    }
                }
            } else {

                if (this.defending >= 32) { //32
                    this.defenseforce = 0
                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].infantry == 1) {
                            this.defenseforce++
                        }
                        if (this.units[t].infantry == 2) {
                            this.defenseforce += 2
                        }
                        if (this.units[t].harvester == 1) {
                            this.defenseforce += .7
                        }
                    }
                    for (let t = 0; t < this.buildings.length; t++) {
                        if (this.buildings[t].barracks == 1) {
                            if (this.hotrock >= 90) { // 40??
                                if (this.hotrock < 400) { // 40??
                                    this.buildings[t].makeInfantry()
                                    this.nymphstop += 1
                                } else {
                                    this.buildings[t].makeSniper()
                                    this.nymphstop += 1
                                }
                            }
                        }
                    }
                    if (this.defenseforce > 0) {
                        for (let t = 0; t < this.units.length; t++) {
                            if (!(this.units[t].defendsplatter > 0)) {

                                if (this.units[t].infantry == 1) {
                                    if (Math.random() < 5 / this.defenseforce) { //2
                                        // if (this.units[t].index == this.units[t].realPath.length - 1) {

                                        if (this.units[t].defensepathlimit <= 0) {
                                            this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                            this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.1
                                            this.units[t].ultrabreak = this.attackedAt
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            this.units[t].defendsplatter = this.units[t].movespeed
                                        }
                                        // }
                                    }
                                }
                                if (this.units[t].infantry == 2) {
                                    if (Math.random() < 10 / this.defenseforce) { //2
                                        // if (this.units[t].index == this.units[t].realPath.length - 1) {

                                        if (this.units[t].defensepathlimit <= 0) {
                                            this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                            this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.1
                                            this.units[t].ultrabreak = this.attackedAt
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            this.units[t].defendsplatter = this.units[t].movespeed
                                        }
                                        // }
                                    }
                                }
                                if (this.units[t].harvester == 1) {
                                    if (Math.random() < 7 / this.defenseforce) { //2 //1
                                        // if (this.units[t].index == this.units[t].realPath.length - 1) {

                                        if (this.units[t].defensepathlimit <= 0) {
                                            this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                            this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.1
                                            this.units[t].ultrabreak = this.attackedAt
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            this.units[t].defendsplatter = this.units[t].movespeed
                                        }
                                        // }
                                    }
                                }
                            } else {
                                this.units[t].defendsplatter--
                            }
                        }
                    } else {
                        //should only happen if its only drones
                        for (let t = 0; t < this.units.length; t++) {
                            if (Math.random() < 7 / this.defenseforce) { //2
                                if (this.units[t].harvester == 1 && Math.random() < .4) { //} && this.defending < 25) { //.9  // new && this.defending < 50
                                    continue
                                }

                                // if (this.units[t].index == this.units[t].realPath.length - 1) {

                                if (this.units[t].defensepathlimit <= 0) {
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.attackedAt.t) + Math.abs(this.units[t].tile.k - this.attackedAt.k)) * this.units[t].movespeed) * 1.1

                                    this.units[t].ultrabreak = this.attackedAt
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }
                            }
                        }

                    }

                    this.defending = 0
                }
            }

            let rackswet = 0
            let labswet = 0
            for (let t = 0; t < this.buildings.length; t++) {
                if (this.buildings[t].barracks == 2) {
                    if (this.buildings[t].que != 1) {
                        labswet = 1
                    }
                }
                if (this.buildings[t].barracks == 1  || labswet == 0) {
                    if (this.buildings[t].que != 1 || labswet == 0) {
                        rackswet = 1
                    }
                }
            }
            if (rackswet == 0) {
                this.racks = 0
            }
            if (labswet == 0) {
                this.lab = 0
            }
            // if (Math.random() < .0001) {
            //     this.racks = 0
            //     this.lab = 0
            // }
            let index = 0
            this.chunk++
            if (this.aimode == 1) {
                let j = 0
                // if (Math.random() < this.units.length * .075) {
                this.aimode = 0
                // }
            } else if (this.aimode == 0) {
                let j = 0

                if (this.chunk % this.clickrate == 0) {

            for (let t = 0; t < this.units.length; t++) {
                this.units[t].smartAttack()
            }

                    //this.units.sort((a, b) => (Math.random() > .5) ? 1 : -1)
                    for (let t = 0; t < this.units.length; t++) {
                        this.units[t].hotrockrepathlimit *= .98
                    }

                    this.findBase() // to make an averagespace
                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].realPath.length - 1 == this.units[t].index) { //} || this.units[t].realPath[this.units[t].index].walkable !== true) {

                            if (this.units[t].health < (this.units[t].maxhealth * .09)) { //33
                                j++
                                const block = this.averageSpace.tile

                                if (this.units[t].hotrockrepathlimit <= 0) {
                                    this.units[t].defensepathlimit = (Math.abs(this.units[t].tile.t - this.averageSpace.tile.t) + Math.abs(this.units[t].tile.k - this.averageSpace.tile.k)) * this.units[t].movespeed
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.averageSpace.tile.t) + Math.abs(this.units[t].tile.k - this.averageSpace.tile.k)) * this.units[t].movespeed) * 1.1
                                    this.units[t].ultrabreak = block
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }
                                if (j > 11) { //6
                                    break
                                }
                            } else {
                                if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {
                                    let max = 999999999
                                    for (let h = 0; h < sandmap.hotrocks.length; h++) {
                                        if (this.blocks[sandmap.hotrocks[h].t][sandmap.hotrocks[h].k].markdraw == 1) {
                                            if (sandmap.hotrocks[h].walkable == true && sandmap.hotrocks[h].occupied == false) {
                                                const link = (new LineOP(this.units[t].tile, sandmap.hotrocks[h])).hypotenuse()
                                                // //////////console.log(link)
                                                if (link < max) {
                                                    max = link
                                                    index = h
                                                }
                                            }
                                        }
                                    }

                                    if (typeof sandmap.hotrocks[index] !== "undefined" && max < 999999999) {
                                        if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {

                                        } else {
                                            j++


                                            if (this.units[t].hotrockrepathlimit <= 0) {
                                                this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - sandmap.hotrocks[index].t) + Math.abs(this.units[t].tile.k - sandmap.hotrocks[index].k)) * this.units[t].movespeed) * 1.1
                                                this.units[t].ultrabreak = sandmap.hotrocks[index]
                                                this.units[t].ultrawalk = 0
                                                this.units[t].start = this.units[t].tile
                                            }
                                            if (j > 11) { //6
                                                break
                                            }
                                        }
                                    } else {
                                        if (this.units[t].drone == 1) { // && Math.random() < (.05 / this.units.length)
                                            if (this.units[t].health > (this.units[t].maxhealth * .33)) {
                                                // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                                let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                                let u = 0
                                                while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                                    u++
                                                    block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                                }

                                                if (this.units[t].hotrockrepathlimit <= 0) {
                                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * 1.1
                                                    this.units[t].ultrabreak = block
                                                    this.units[t].ultrawalk = 0
                                                    this.units[t].start = this.units[t].tile
                                                }
                                            } else {
                                                j++
                                                const block = this.averageSpace.tile

                                                if (this.units[t].hotrockrepathlimit <= 0) {
                                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * 1.1
                                                    this.units[t].ultrabreak = block
                                                    this.units[t].ultrawalk = 0
                                                    this.units[t].start = this.units[t].tile
                                                }
                                                if (j > 11) { //6
                                                    break
                                                }
                                            }
                                        } else if (Math.random() < (1 / this.units.length)) {
                                            if (this.units[t].health > (this.units[t].maxhealth * .33)) {
                                                if (this.seen.length > 0) {
                                                    j++
                                                    // const block = this.seen[Math.floor(Math.random() * this.seen.length)]
                                                    const block = this.seen[this.seen.length - 1]
                                                    if (block.occupied == true) {
                                                        const blockbackup = this.seen[(Math.floor(this.seen.length * Math.random()))]


                                                        if (this.units[t].hotrockrepathlimit <= 0) {
                                                            this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * 1.1
                                                            this.units[t].ultrabreak = blockbackup
                                                            this.units[t].ultrawalk = 0
                                                            this.units[t].start = this.units[t].tile
                                                        }
                                                    } else {

                                                        if (this.units[t].hotrockrepathlimit <= 0) {
                                                            this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * 1.1
                                                            this.units[t].ultrabreak = block
                                                            this.units[t].ultrawalk = 0
                                                            this.units[t].start = this.units[t].tile
                                                        }
                                                    }
                                                    if (j > 11) { //6
                                                        break
                                                    }
                                                }
                                            } else {
                                                j++
                                                const block = this.averageSpace.tile

                                                if (this.units[t].hotrockrepathlimit <= 0) {
                                                    this.units[t].defensepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * 1
                                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - block.t) + Math.abs(this.units[t].tile.k - block.k)) * this.units[t].movespeed) * 1.1
                                                    this.units[t].ultrabreak = block
                                                    this.units[t].ultrawalk = 0
                                                    this.units[t].start = this.units[t].tile
                                                }
                                                if (j > 11) { //6
                                                    break
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else if (typeof this.units[t].realPath[this.units[t].index + 1] !== "undefined") {
                            if (this.units[t].health < (this.units[t].maxhealth * .09)) { //33
                                j++
                                const block = this.averageSpace.tile

                                if (this.units[t].hotrockrepathlimit <= 0) {
                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - this.averageSpace.tile.t) + Math.abs(this.units[t].tile.k - this.averageSpace.tile.k)) * this.units[t].movespeed) * 1.1
                                    this.units[t].ultrabreak = block
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }
                                if (j > 11) { //6
                                    break
                                }
                            } else {
                                if (this.units[t].realPath[this.units[t].index + 1].walkable !== true) {
                                    if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {
                                        let max = 999999999
                                        for (let h = 0; h < sandmap.hotrocks.length; h++) {
                                            if (this.blocks[sandmap.hotrocks[h].t][sandmap.hotrocks[h].k].markdraw == 1) {
                                                if (sandmap.hotrocks[h].walkable == true && sandmap.hotrocks[h].occupied == false) {
                                                    const link = (new LineOP(this.units[t].tile, sandmap.hotrocks[h])).hypotenuse()
                                                    // //////////console.log(link)
                                                    if (link < max) {
                                                        max = link
                                                        index = h
                                                    }
                                                }
                                            }
                                        }

                                        if (typeof sandmap.hotrocks[index] !== "undefined" && max < 999999999) {
                                            if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {

                                            } else {
                                                j++

                                                if (this.units[t].hotrockrepathlimit <= 0) {
                                                    this.units[t].defensepathlimit = ((Math.abs(this.units[t].tile.t - sandmap.hotrocks[index].t) + Math.abs(this.units[t].tile.k - sandmap.hotrocks[index].k)) * this.units[t].movespeed) * 1
                                                    this.units[t].hotrockrepathlimit = ((Math.abs(this.units[t].tile.t - sandmap.hotrocks[index].t) + Math.abs(this.units[t].tile.k - sandmap.hotrocks[index].k)) * this.units[t].movespeed) * 1.1
                                                    this.units[t].ultrabreak = sandmap.hotrocks[index]
                                                    this.units[t].ultrawalk = 0
                                                    this.units[t].start = this.units[t].tile
                                                }
                                                if (j > 11) { //6
                                                    break
                                                }
                                            }
                                        } else {
                                            // if (Math.random() < (1 / this.units.length)) {
                                            if (this.seen.length > 0) {
                                                j++
                                                // const block = this.seen[Math.floor(Math.random() * this.seen.length)]
                                                const block = this.seen[this.seen.length - 1]
                                                if (block.occupied == true) {
                                                    const blockbackup = this.seen[(Math.floor(this.seen.length * Math.random()))]


                                                    this.units[t].ultrabreak = blockbackup
                                                    this.units[t].ultrawalk = 0
                                                    this.units[t].start = this.units[t].tile
                                                } else {

                                                    this.units[t].ultrabreak = block
                                                    this.units[t].ultrawalk = 0
                                                    this.units[t].start = this.units[t].tile
                                                }
                                                if (j > 11) { //6
                                                    break
                                                }
                                            }
                                            // }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }


                let dronecount = 0
                for (let t = 0; t < this.units.length; t++) {
                    if ((this.units[t].drone == 1)) {
                        dronecount++
                    }
                }
                // if (Math.random() < .01) {
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].infantry == 1) {
                        this.units[t].attackmove()
                    }
                    if ((this.units[t].drone == 1 || dronecount == 0) && !(this.units[t].dronesplatter > 0)) {
                        // if (typeof this.units[t].realPath[this.units[t].index + 1] == "undefined") {
                        if (this.units[t].realPath.length > this.units[t].index) {




                            if (Math.random() < (.0005 * this.clickrate) || this.seenrocks.length <= this.units.length) { // 03?
                                // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]

                                let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                let u = 0
                                while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                    u++
                                    block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                }
                                // //////////console.log("fixes")
                                this.units[t].ultrabreak = block
                                this.units[t].ultrawalk = 0
                                this.units[t].start = this.units[t].tile
                                this.units[t].dronesplatter = 20
                            }
                        }
                    } else {
                        this.units[t].dronesplatter--
                    }
                }
                // }

                if (Math.random() < (3 / this.units.length)) {  //.3
                    for (let t = 0; t < this.buildings.length; t++) {
                        if (this.buildings[t].barracks == 1) {
                            // if (Math.random() < .1 - (this.units.length * .005)) {
                            //     if (this.hotrock > 120) {
                            //         if (sandmap.players.indexOf(this) == 1) {
                            //             if (Math.random() < .15) {
                            //                 this.buildings[t].makeInfantry()
                            //             }
                            //         }
                            //     }
                            // }
                            if (Math.random() < (.13 + (this.units.length * .0045)) + (this.hotrock * .0001)) { // - not +
                                if (this.hotrock > 190) {
                                    if (this.units.length > 7) {
                                        this.buildings[t].makeSniper()

                                    }
                                }
                            }
                            if (Math.random() < .3) {
                                break
                            }
                        }
                    }
                    for (let t = 0; t < this.buildings.length; t++) {
                        if (this.buildings[t].barracks == 2) {
                            if (Math.random() < (.02) - (this.units.length * .008)) { //.1 //(.005 * this.clickrate)
                                if (this.hotrock > 70) {
                                    this.buildings[t].makeScout()
                                }
                            }
                            if (Math.random() < (.2 + (this.units.length * .003)) + (this.hotrock * .0001)) { //- to + //.1
                                if (this.hotrock > 160) { //200
                                    this.buildings[t].makeHarvester()
                                }
                            }

                            if (Math.random() < .3) {
                                break
                            }
                        }
                    }
                } else {

                    let infcount = 0
                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].infantry == 1) {
                            infcount++
                        }
                    }

                    if (this.hotrock > 195) {
                        this.nymphstop = 0
                    } else {
                        this.nymphstop *= .95
                    }
                    // if (sandmap.players.indexOf(this) == 0) {
                    for (let t = 0; t < this.buildings.length; t++) {
                        if (this.buildings[t].barracks == 1) {
                            if (infcount < (this.units.length * .15) || this.nymphstop > 0) { //005 //15
                                if (this.hotrock > 90 && this.hotrock < 200) { //200
                                    this.buildings[t].makeInfantry()
                                }
                                if (this.hotrock > 200) { //200
                                    this.buildings[t].makeSniper()
                                }
                            }
                        } else {
                            if (this.hotrock > 160) {
                                if (this.nymphstop <= 0 || Math.random() < .5) {
                                    this.buildings[t].makeHarvester()
                                }
                            }
                        }
                    }
                    // } else {
                    //     for (let  t = 0; t < this.buildings.length; t++) {
                    //         if (this.buildings[t].barracks == 1) {
                    //             if (Math.random() < .15) { //005 //15
                    //                 if (this.hotrock > 100) { //200
                    //                     this.buildings[t].makeInfantry()
                    //                 }
                    //             }
                    //         }
                    //     }
                    // }

                }

                if (true) {

                    if (this.baseMoveFlag == 1 && this.buildings.length > 15) {
                        this.baseMoveFlag = 0
                        if (this.averageSpace.dirs2 == 1) {
                        } else {
                            for (let x = this.averageSpace.tile.k; x < (worldscale - 1); x++) {
                                if (sandmap.blocks[this.averageSpace.tile.t][x + 1].faction == sandmap.players.indexOf(this)) {
                                    break
                                }
                                if (x < 0 || x > (worldscale - 1)) {
                                    continue
                                }
                                if ((Math.abs(this.averageSpace.tile.k - x) > 16)) {
                                    continue
                                }
                                if (this.blocks[this.averageSpace.tile.t][x + 1].markdraw != 1 || (Math.abs(this.averageSpace.tile.k - x) > 15)) {
                                    this.buildWall(sandmap.blocks[this.averageSpace.tile.t][x])
                                } else if (x == (worldscale - 2)) {
                                    this.buildWall(sandmap.blocks[this.averageSpace.tile.t][x])
                                }
                                if (debreak == 0) {
                                    break
                                }
                            }
                        }
                        if (this.averageSpace.dirs4 == 1) {
                        } else {
                            for (let x = this.averageSpace.tile.k; x > 1; x--) {
                                if (sandmap.blocks[this.averageSpace.tile.t][x + 1].faction == sandmap.players.indexOf(this)) {
                                    break
                                }
                                if (x < 0 || x > (worldscale - 1)) {
                                    continue
                                }
                                if ((Math.abs(this.averageSpace.tile.k - x) > 16)) {
                                    continue
                                }
                                if (this.blocks[this.averageSpace.tile.t][x - 1].markdraw != 1 || (Math.abs(this.averageSpace.tile.k - x) > 15)) {
                                    this.buildWall(sandmap.blocks[this.averageSpace.tile.t][x])
                                } else if (x == 2) {
                                    this.buildWall(sandmap.blocks[this.averageSpace.tile.t][x])
                                }
                                if (debreak == 0) {
                                    break
                                }
                            }
                        }
                        if (this.averageSpace.dirs3 == 1) {
                        } else {
                            for (let x = this.averageSpace.tile.t; x > 1; x--) {
                                if (sandmap.blocks[x + 1][this.averageSpace.tile.k].faction == sandmap.players.indexOf(this)) {
                                    break
                                }
                                if (x < 0 || x > (worldscale - 1)) {
                                    continue
                                }
                                if ((Math.abs(this.averageSpace.tile.t - x) > 16)) {
                                    continue
                                }
                                if (this.blocks[x - 1][this.averageSpace.tile.k].markdraw != 1 || (Math.abs(this.averageSpace.tile.t - x) > 15)) {
                                    this.buildWall(sandmap.blocks[x][this.averageSpace.tile.k])
                                } else if (x == 2) {
                                    this.buildWall(sandmap.blocks[x][this.averageSpace.tile.k])
                                }
                                if (debreak == 0) {
                                    break
                                }
                            }
                        }
                        if (this.averageSpace.dirs1 == 1) {
                        } else {
                            for (let x = this.averageSpace.tile.t; x < (worldscale - 1); x++) {
                                // if (sandmap.blocks[x ][this.averageSpace.tile.k].faction == sandmap.players.indexOf(this)){
                                //     break
                                // }
                                if (sandmap.blocks[x + 1][this.averageSpace.tile.k].faction == sandmap.players.indexOf(this)) {
                                    break
                                }
                                if (x < 0 || x > (worldscale - 1)) {
                                    continue
                                }
                                if ((Math.abs(this.averageSpace.tile.t - x) > 16)) {
                                    continue
                                }
                                if (this.blocks[x + 1][this.averageSpace.tile.k].markdraw != 1 || (Math.abs(this.averageSpace.tile.t - x) > 15)) {
                                    this.buildWall(sandmap.blocks[x][this.averageSpace.tile.k])
                                } else if (x == (worldscale - 2)) {
                                    this.buildWall(sandmap.blocks[x][this.averageSpace.tile.k])
                                }
                                if (debreak == 0) {
                                    break
                                }
                            }
                        }
                    }





                    //sliced in


                    if ((Math.random() * .13) && this.hotrock >= 10) {

                        for (let t = 0; t < this.units.length; t++) {
                            if (this.units[t].tile.sourcerock >= 1 || ((Math.random() * .03) && this.units[t].index < this.units[t].realPath.length - 1)) {

                            } else {
                                continue
                            }


                            const calcdeath = this.units[t].health / (((this.units[t].decayRate * this.units[t].decayingInTheWind * sandmap.windspeed)))

                            if (Math.abs(this.units[t].realPath.length - this.units[t].index) < 3 || Math.abs(this.units[t].realPath.length - this.units[t].index) > (calcdeath - (this.units[t].movespeed * 10))) {

                                // //////////console.log(this.units[t])

                            } else {
                                continue
                            }


                            if ((this.units[t].decayingInTheWind == 1 && this.units[t].drone != 1)) {
                                if (this.units[t].dirs2 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.k; x < (worldscale - 1); x++) {
                                            if (sandmap.blocks[this.units[t].tile.t][x + 1].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.k - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[this.units[t].tile.t][x + 1].markdraw != 1 || Math.abs(this.units[t].tile.k - x) > 15) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            } else if (x == (worldscale - 2)) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs4 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.k; x > 1; x--) {
                                            if (sandmap.blocks[this.units[t].tile.t][x - 1].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.k - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[this.units[t].tile.t][x - 1].markdraw != 1 || Math.abs(this.units[t].tile.k - x) > 15) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            } else if (x == 2) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs3 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.t; x > 1; x--) {
                                            if (sandmap.blocks[x - 1][this.units[t].tile.k].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.t - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[x - 1][this.units[t].tile.k].markdraw != 1 || Math.abs(this.units[t].tile.t - x) > 15) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            } else if (x == 2) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs1 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.t; x < (worldscale - 1); x++) {
                                            if (sandmap.blocks[x + 1][this.units[t].tile.k].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.t - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[x + 1][this.units[t].tile.k].markdraw != 1 || Math.abs(this.units[t].tile.t - x) > 15) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            } else if (x == (worldscale - 2)) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }


                            } else if ((this.units[t].decayingInTheWind > .51 && this.units[t].decayingInTheWind < .8 && this.units[t].drone != 1) || (this.units[t].decayingInTheWind > .51 && this.units[t].decayingInTheWind < .8 && this.units[t].drone == 1 && (Math.random() < (this.hotrock * .004)))) {
                                if (this.units[t].dirs2 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.k; x < (worldscale - 1); x++) {
                                            if (sandmap.blocks[this.units[t].tile.t][x + 1].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.k - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[this.units[t].tile.t][x + 1].markdraw != 1 || Math.abs(this.units[t].tile.k - x) > 15) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            } else if (x == (worldscale - 2)) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs4 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.k; x > 1; x--) {
                                            if (sandmap.blocks[this.units[t].tile.t][x - 1].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.k - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[this.units[t].tile.t][x - 1].markdraw != 1 || Math.abs(this.units[t].tile.k - x) > 15) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            } else if (x == 2) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs3 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.t; x > 1; x--) {
                                            if (sandmap.blocks[x - 1][this.units[t].tile.k].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.t - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[x - 1][this.units[t].tile.k].markdraw != 1 || Math.abs(this.units[t].tile.t - x) > 15) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            } else if (x == 2) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs1 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.t; x < (worldscale - 1); x++) {
                                            if (sandmap.blocks[x + 1][this.units[t].tile.k].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.t - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[x + 1][this.units[t].tile.k].markdraw != 1 || Math.abs(this.units[t].tile.t - x) > 15) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            } else if (x == (worldscale - 2)) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }



                            } else if ((this.units[t].decayingInTheWind > .27 && this.units[t].decayingInTheWind < .55 && this.units[t].drone != 1) || (this.units[t].decayingInTheWind > .27 && this.units[t].decayingInTheWind < .55 && this.units[t].drone == 1 && (Math.random() < (this.hotrock * .006)))) {
                                if (this.units[t].dirs2 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.k; x < (worldscale - 1); x++) {
                                            if (sandmap.blocks[this.units[t].tile.t][x + 1].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.k - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[this.units[t].tile.t][x + 1].markdraw != 1 || Math.abs(this.units[t].tile.k - x) > 15) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            } else if (x == (worldscale - 2)) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs4 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.k; x > 1; x--) {
                                            if (sandmap.blocks[this.units[t].tile.t][x - 1].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.k - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[this.units[t].tile.t][x - 1].markdraw != 1 || Math.abs(this.units[t].tile.k - x) > 15) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            } else if (x == 2) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs3 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.t; x > 1; x--) {
                                            if (sandmap.blocks[x - 1][this.units[t].tile.k].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.t - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[x - 1][this.units[t].tile.k].markdraw != 1 || Math.abs(this.units[t].tile.t - x) > 15) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            } else if (x == 2) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs1 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.t; x < (worldscale - 1); x++) {
                                            if (sandmap.blocks[x + 1][this.units[t].tile.k].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.t - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[x + 1][this.units[t].tile.k].markdraw != 1 || Math.abs(this.units[t].tile.t - x) > 15) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            } else if (x == (worldscale - 2)) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                            } else if ((this.units[t].decayingInTheWind >= .01 && this.units[t].decayingInTheWind < .3 && this.units[t].drone != 1) || (this.units[t].decayingInTheWind > .01 && this.units[t].decayingInTheWind < .3 && this.units[t].drone == 1 && (Math.random() < (this.hotrock * .008)))) {
                                if (this.units[t].dirs2 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.k; x < (worldscale - 1); x++) {
                                            if (sandmap.blocks[this.units[t].tile.t][x + 1].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.k - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[this.units[t].tile.t][x + 1].markdraw != 1 || Math.abs(this.units[t].tile.k - x) > 15) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            } else if (x == (worldscale - 2)) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs4 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.k; x > 1; x--) {
                                            if (sandmap.blocks[this.units[t].tile.t][x - 1].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.k - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[this.units[t].tile.t][x - 1].markdraw != 1 || Math.abs(this.units[t].tile.k - x) > 15) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            } else if (x == 2) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs3 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.t; x > 1; x--) {
                                            if (sandmap.blocks[x - 1][this.units[t].tile.k].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.t - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[x - 1][this.units[t].tile.k].markdraw != 1 || Math.abs(this.units[t].tile.t - x) > 15) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            } else if (x == 2) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs1 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.t; x < (worldscale - 1); x++) {
                                            if (sandmap.blocks[x + 1][this.units[t].tile.k].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.t - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[x + 1][this.units[t].tile.k].markdraw != 1 || Math.abs(this.units[t].tile.t - x) > 15) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            } else if (x == (worldscale - 2)) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                            } else {


                            }
                        }

                    }




                    //sliced in

                }

                if (this.units.length > 25) {
                    if (this.attacktimeout <= 0) {
                        this.aimode = 1
                        this.attacktimeout = 3000
                    }
                    this.attacktimeout--
                }
            }



        }
        campaignHumanAI() {
            // //////////console.log("firs")

            for (let t = 0; t < this.units.length; t++) {
                this.units[t].attackmove()
            }
            for (let t = 0; t < this.units.length; t++) {
                this.units[t].defendsplatter--
            }

            if (this.defending >= 1) {
                // //////////console.log("2")
                this.defending = 0
                this.defenseforce = 1
                // for (let t = 0; t < this.units.length; t++) {
                //     if (this.units[t].infantry == 1) {
                //         this.defenseforce++
                //     }
                // }
                if (this.defenseforce > 0) {
                    for (let t = 0; t < this.units.length; t++) {

                        // if(!(this.units[t].defendsplatter > 0)){
                        // //////////console.log(Math.abs(this.units[t].tile.x-this.attackedAt.x) + Math.abs(this.units[t].tile.y-this.attackedAt.y), Math.abs(this.units[t].tile.x-this.attackedAt.x), Math.abs(this.units[t].tile.y-this.attackedAt.y))
                        if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < (170)) { //36
                            // //////////console.log("thrhr")
                            // //////////console.log(this.units[t].cooloff)
                            // if (this.units[t].cooloff <= 0) {
                            // this.units[t].cooloff = 1
                            // 
                            this.units[t].ultrabreak = this.attackedAt
                            this.units[t].ultrawalk = 0
                            this.units[t].defendsplatter = this.units[t].movespeed
                            this.units[t].start = this.units[t].tile
                            // } else {
                            //     this.units[t].cooloff = 0
                            // }

                        }
                        // }else{
                        // }
                    }
                } else {

                }
            }
        }
        humanAI() {

            if (this.hotrock > (this.racksflag * 75)) {
                //////////console.log("earthoid effect")
                if (this.racks == 1) {
                    this.racksflag += 4
                }
                this.racks = 0
                this.lab = 0
            }


            if (campaignController.mission <= 4 && campaignController.mission > -1) {
                // //////////console.log("firs")
                if (this.defending >= 1) {
                    // //////////console.log("2")
                    this.defending = 0
                    this.defenseforce = 0
                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].infantry == 1) {
                            this.defenseforce++
                        }
                    }
                    for (let t = 0; t < this.buildings.length; t++) {
                        if (this.buildings[t].barracks == 1) {
                            if (this.hotrock > 40) { // 40??
                                this.buildings[t].makeInfantry()
                            }
                        }
                    }
                    if (this.defenseforce > 0) {
                        for (let t = 0; t < this.units.length; t++) {

                            if (!(this.units[t].defendsplatter > 0)) {
                                // //////////console.log(Math.abs(this.units[t].tile.x-this.attackedAt.x) + Math.abs(this.units[t].tile.y-this.attackedAt.y), Math.abs(this.units[t].tile.x-this.attackedAt.x), Math.abs(this.units[t].tile.y-this.attackedAt.y))
                                if (Math.abs(this.units[t].tile.x - this.attackedAt.x) + Math.abs(this.units[t].tile.y - this.attackedAt.y) < (170)) { //36
                                    // //////////console.log("thrhr")
                                    // //////////console.log(this.units[t].cooloff)
                                    if (this.units[t].cooloff <= 0) {
                                        this.units[t].cooloff = 1
                                        // 
                                        this.units[t].ultrabreak = this.attackedAt
                                        this.units[t].ultrawalk = 0
                                        this.units[t].defendsplatter = this.units[t].movespeed
                                        this.units[t].start = this.units[t].tile
                                    } else {
                                        this.units[t].cooloff = 0
                                    }

                                }
                            } else {
                                this.units[t].defendsplatter--
                            }
                        }
                    } else {

                    }
                }
            } else {

                if (this.defending >= 32) { //32
                    this.defenseforce = 0
                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].infantry == 1) {
                            this.defenseforce++
                        }
                    }
                    for (let t = 0; t < this.buildings.length; t++) {
                        if (this.buildings[t].barracks == 1) {
                            if (this.hotrock > 40) { // 40??
                                this.buildings[t].makeInfantry()
                            }
                        }
                    }
                    if (this.defenseforce > 0) {
                        for (let t = 0; t < this.units.length; t++) {
                            if (!(this.units[t].defendsplatter > 0)) {

                                if (this.units[t].infantry == 1) {
                                    if (Math.random() < 7 / this.defenseforce) { //2
                                        if (this.units[t].index == this.units[t].realPath.length - 1) {

                                            this.units[t].ultrabreak = this.attackedAt
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            this.units[t].defendsplatter = this.units[t].movespeed
                                        }
                                    }
                                }
                                if (this.units[t].infantry == 2) {
                                    if (Math.random() < 7 / this.defenseforce) { //2
                                        if (this.units[t].index == this.units[t].realPath.length - 1) {

                                            this.units[t].ultrabreak = this.attackedAt
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            this.units[t].defendsplatter = this.units[t].movespeed
                                        }
                                    }
                                }
                                if (this.units[t].harvester == 1) {
                                    if (Math.random() < 7 / this.defenseforce) { //2
                                        if (this.units[t].index == this.units[t].realPath.length - 1) {

                                            this.units[t].ultrabreak = this.attackedAt
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            this.units[t].defendsplatter = this.units[t].movespeed
                                        }
                                    }
                                }
                            } else {
                                this.units[t].defendsplatter--
                            }
                        }
                    } else {
                        for (let t = 0; t < this.units.length; t++) {
                            if (Math.random() < 7 / this.defenseforce) { //2
                                if (this.units[t].harvester == 1 && Math.random() < .4) { //} && this.defending < 25) { //.9  // new && this.defending < 50
                                    continue
                                }

                                if (this.units[t].index == this.units[t].realPath.length - 1) {

                                    this.units[t].ultrabreak = this.attackedAt
                                    this.units[t].ultrawalk = 0
                                    this.units[t].start = this.units[t].tile
                                }
                            }
                        }

                    }

                    this.defending = 0
                }
            }
            if (Math.random() < .0001) {
                this.racks = 0
                this.lab = 0
            }
            let index = 0
            this.chunk++
            if (this.aimode == 1) {
                let j = 0
                if (Math.random() < this.units.length * .075) {
                    this.aimode = 0
                }
            } else if (this.aimode == 0) {
                let j = 0

                if (this.chunk % this.clickrate == 0) {

                    this.findBase() // to make an averagespace
                    for (let t = 0; t < this.units.length; t++) {
                        if (this.units[t].realPath.length - 1 == this.units[t].index) { //} || this.units[t].realPath[this.units[t].index].walkable !== true) {

                            if (this.units[t].health < (this.units[t].maxhealth * .09)) { //33
                                j++
                                const block = this.averageSpace.tile

                                this.units[t].ultrabreak = block
                                this.units[t].ultrawalk = 0
                                this.units[t].start = this.units[t].tile
                                if (j > 11) { //6
                                    break
                                }
                            } else {
                                if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {
                                    let max = 999999999
                                    for (let h = 0; h < sandmap.hotrocks.length; h++) {
                                        if (this.blocks[sandmap.hotrocks[h].t][sandmap.hotrocks[h].k].markdraw == 1) {
                                            if (sandmap.hotrocks[h].walkable == true && sandmap.hotrocks[h].occupied == false) {
                                                const link = (new LineOP(this.units[t].tile, sandmap.hotrocks[h])).hypotenuse()
                                                // //////////console.log(link)
                                                if (link < max) {
                                                    max = link
                                                    index = h
                                                }
                                            }
                                        }
                                    }

                                    if (typeof sandmap.hotrocks[index] !== "undefined" && max < 999999999) {
                                        if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {

                                        } else {
                                            j++


                                            this.units[t].ultrabreak = sandmap.hotrocks[index]
                                            this.units[t].ultrawalk = 0
                                            this.units[t].start = this.units[t].tile
                                            if (j > 11) { //6
                                                break
                                            }
                                        }
                                    } else {
                                        if (this.units[t].drone == 1 && Math.random() < (.05 / this.units.length)) {
                                            if (this.units[t].health > (this.units[t].maxhealth * .33)) {
                                                // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                                let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                                let u = 0
                                                while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                                    u++
                                                    block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                                }

                                                this.units[t].ultrabreak = block
                                                this.units[t].ultrawalk = 0
                                                this.units[t].start = this.units[t].tile
                                            } else {
                                                j++
                                                const block = this.averageSpace.tile

                                                this.units[t].ultrabreak = block
                                                this.units[t].ultrawalk = 0
                                                this.units[t].start = this.units[t].tile
                                                if (j > 11) { //6
                                                    break
                                                }
                                            }
                                        } else if (Math.random() < (1 / this.units.length)) {
                                            if (this.units[t].health > (this.units[t].maxhealth * .33)) {
                                                if (this.seen.length > 0) {
                                                    j++
                                                    // const block = this.seen[Math.floor(Math.random() * this.seen.length)]
                                                    const block = this.seen[this.seen.length - 1]
                                                    if (block.occupied == true) {
                                                        const blockbackup = this.seen[(Math.floor(this.seen.length * Math.random()))]


                                                        this.units[t].ultrabreak = blockbackup
                                                        this.units[t].ultrawalk = 0
                                                        this.units[t].start = this.units[t].tile
                                                    } else {

                                                        this.units[t].ultrabreak = block
                                                        this.units[t].ultrawalk = 0
                                                        this.units[t].start = this.units[t].tile
                                                    }
                                                    if (j > 11) { //6
                                                        break
                                                    }
                                                }
                                            } else {
                                                j++
                                                const block = this.averageSpace.tile

                                                this.units[t].ultrabreak = block
                                                this.units[t].ultrawalk = 0
                                                this.units[t].start = this.units[t].tile
                                                if (j > 11) { //6
                                                    break
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else if (typeof this.units[t].realPath[this.units[t].index + 1] !== "undefined") {
                            if (this.units[t].health < (this.units[t].maxhealth * .09)) { //33
                                j++
                                const block = this.averageSpace.tile

                                this.units[t].ultrabreak = block
                                this.units[t].ultrawalk = 0
                                this.units[t].start = this.units[t].tile
                                if (j > 11) { //6
                                    break
                                }
                            } else {
                                if (this.units[t].realPath[this.units[t].index + 1].walkable !== true) {
                                    if (this.units[t].tile.hotrock != 1 && this.units[t].tile.hotrock != 2) {
                                        let max = 999999999
                                        for (let h = 0; h < sandmap.hotrocks.length; h++) {
                                            if (this.blocks[sandmap.hotrocks[h].t][sandmap.hotrocks[h].k].markdraw == 1) {
                                                if (sandmap.hotrocks[h].walkable == true && sandmap.hotrocks[h].occupied == false) {
                                                    const link = (new LineOP(this.units[t].tile, sandmap.hotrocks[h])).hypotenuse()
                                                    // //////////console.log(link)
                                                    if (link < max) {
                                                        max = link
                                                        index = h
                                                    }
                                                }
                                            }
                                        }

                                        if (typeof sandmap.hotrocks[index] !== "undefined" && max < 999999999) {
                                            if (this.units[t].attacktarget.health > 0 && this.units[t].isInRange(this.units[t].attacktarget.tile)) {

                                            } else {
                                                j++


                                                this.units[t].ultrabreak = sandmap.hotrocks[index]
                                                this.units[t].ultrawalk = 0
                                                this.units[t].start = this.units[t].tile
                                                if (j > 11) { //6
                                                    break
                                                }
                                            }
                                        } else {
                                            // if (Math.random() < (1 / this.units.length)) {
                                            if (this.seen.length > 0) {
                                                j++
                                                // const block = this.seen[Math.floor(Math.random() * this.seen.length)]
                                                const block = this.seen[this.seen.length - 1]
                                                if (block.occupied == true) {
                                                    const blockbackup = this.seen[(Math.floor(this.seen.length * Math.random()))]


                                                    this.units[t].ultrabreak = blockbackup
                                                    this.units[t].ultrawalk = 0
                                                    this.units[t].start = this.units[t].tile
                                                } else {

                                                    this.units[t].ultrabreak = block
                                                    this.units[t].ultrawalk = 0
                                                    this.units[t].start = this.units[t].tile
                                                }
                                                if (j > 11) { //6
                                                    break
                                                }
                                            }
                                            // }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // if (Math.random() < .01) {
                for (let t = 0; t < this.units.length; t++) {
                    if (this.units[t].infantry == 1) {
                        this.units[t].attackmove()
                    }
                    if (this.units[t].drone == 1 && !(this.units[t].dronesplatter > 0)) {
                        // if (typeof this.units[t].realPath[this.units[t].index + 1] == "undefined") {
                        if (this.units[t].realPath.length > this.units[t].index) {




                            if (Math.random() < (.0005 * this.clickrate) || this.seenrocks.length <= this.units.length) { // 03?
                                // const block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                let block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                let u = 0
                                while ((this.blocks[block.t][block.k].markdraw == 1 || (this.blocks[block.t][block.k].ice == 1)) && u < 1000) {
                                    u++
                                    block = sandmap.gridPoints[Math.floor(Math.random() * sandmap.gridPoints.length)]
                                }
                                // //////////console.log("fixes")
                                this.units[t].ultrabreak = block
                                this.units[t].ultrawalk = 0
                                this.units[t].start = this.units[t].tile
                                this.units[t].dronesplatter = 20
                            }
                        }
                    } else {
                        this.units[t].dronesplatter--
                    }
                }
                // }

                if (Math.random() < (3 / this.units.length)) {  //.3
                    for (let t = 0; t < this.buildings.length; t++) {
                        if (this.buildings[t].barracks == 1) {
                            // if (Math.random() < .1 - (this.units.length * .005)) {
                            //     if (this.hotrock > 120) {
                            //         if (sandmap.players.indexOf(this) == 1) {
                            //             if (Math.random() < .15) {
                            //                 this.buildings[t].makeInfantry()
                            //             }
                            //         }
                            //     }
                            // }
                            if (Math.random() < (.13 + (this.units.length * .0045)) + (this.hotrock * .0001)) { // - not +
                                if (this.hotrock > 190) {
                                    if (this.units.length > 7) {
                                        this.buildings[t].makeSniper()

                                    }
                                }
                            }
                            if (Math.random() < .3) {
                                break
                            }
                        }
                    }
                    for (let t = 0; t < this.buildings.length; t++) {
                        if (this.buildings[t].barracks == 2) {
                            if (Math.random() < (.005 * this.clickrate) - (this.units.length * .008)) { //.1
                                if (this.hotrock > 70) {
                                    this.buildings[t].makeScout()
                                }
                            }
                            if (Math.random() < (.2 + (this.units.length * .003)) + (this.hotrock * .0001)) { //- to + //.1
                                if (this.hotrock > 160) { //200
                                    this.buildings[t].makeHarvester()
                                }
                            }

                            if (Math.random() < .3) {
                                break
                            }
                        }
                    }
                } else {

                    // if (sandmap.players.indexOf(this) == 0) {
                    for (let t = 0; t < this.buildings.length; t++) {
                        if (this.buildings[t].barracks == 1) {
                            if (Math.random() < .01) { //005 //15
                                if (this.hotrock > 100) { //200
                                    this.buildings[t].makeInfantry()
                                }
                            }
                        } else {
                            if (this.hotrock > 160) {
                                this.buildings[t].makeHarvester()
                            }
                        }
                    }
                    // } else {
                    //     for (let  t = 0; t < this.buildings.length; t++) {
                    //         if (this.buildings[t].barracks == 1) {
                    //             if (Math.random() < .15) { //005 //15
                    //                 if (this.hotrock > 100) { //200
                    //                     this.buildings[t].makeInfantry()
                    //                 }
                    //             }
                    //         }
                    //     }
                    // }

                }

                if (true) {

                    if (this.baseMoveFlag == 1 && this.buildings.length > 15) {
                        this.baseMoveFlag = 0
                        if (this.averageSpace.dirs2 == 1) {
                        } else {
                            for (let x = this.averageSpace.tile.k; x < (worldscale - 1); x++) {
                                if (sandmap.blocks[this.averageSpace.tile.t][x + 1].faction == sandmap.players.indexOf(this)) {
                                    break
                                }
                                if (x < 0 || x > (worldscale - 1)) {
                                    continue
                                }
                                if ((Math.abs(this.averageSpace.tile.k - x) > 16)) {
                                    continue
                                }
                                if (this.blocks[this.averageSpace.tile.t][x + 1].markdraw != 1 || (Math.abs(this.averageSpace.tile.k - x) > 15)) {
                                    this.buildWall(sandmap.blocks[this.averageSpace.tile.t][x])
                                } else if (x == (worldscale - 2)) {
                                    this.buildWall(sandmap.blocks[this.averageSpace.tile.t][x])
                                }
                                if (debreak == 0) {
                                    break
                                }
                            }
                        }
                        if (this.averageSpace.dirs4 == 1) {
                        } else {
                            for (let x = this.averageSpace.tile.k; x > 1; x--) {
                                if (sandmap.blocks[this.averageSpace.tile.t][x + 1].faction == sandmap.players.indexOf(this)) {
                                    break
                                }
                                if (x < 0 || x > (worldscale - 1)) {
                                    continue
                                }
                                if ((Math.abs(this.averageSpace.tile.k - x) > 16)) {
                                    continue
                                }
                                if (this.blocks[this.averageSpace.tile.t][x - 1].markdraw != 1 || (Math.abs(this.averageSpace.tile.k - x) > 15)) {
                                    this.buildWall(sandmap.blocks[this.averageSpace.tile.t][x])
                                } else if (x == 2) {
                                    this.buildWall(sandmap.blocks[this.averageSpace.tile.t][x])
                                }
                                if (debreak == 0) {
                                    break
                                }
                            }
                        }
                        if (this.averageSpace.dirs3 == 1) {
                        } else {
                            for (let x = this.averageSpace.tile.t; x > 1; x--) {
                                if (sandmap.blocks[x + 1][this.averageSpace.tile.k].faction == sandmap.players.indexOf(this)) {
                                    break
                                }
                                if (x < 0 || x > (worldscale - 1)) {
                                    continue
                                }
                                if ((Math.abs(this.averageSpace.tile.t - x) > 16)) {
                                    continue
                                }
                                if (this.blocks[x - 1][this.averageSpace.tile.k].markdraw != 1 || (Math.abs(this.averageSpace.tile.t - x) > 15)) {
                                    this.buildWall(sandmap.blocks[x][this.averageSpace.tile.k])
                                } else if (x == 2) {
                                    this.buildWall(sandmap.blocks[x][this.averageSpace.tile.k])
                                }
                                if (debreak == 0) {
                                    break
                                }
                            }
                        }
                        if (this.averageSpace.dirs1 == 1) {
                        } else {
                            for (let x = this.averageSpace.tile.t; x < (worldscale - 1); x++) {
                                // if (sandmap.blocks[x ][this.averageSpace.tile.k].faction == sandmap.players.indexOf(this)){
                                //     break
                                // }
                                if (sandmap.blocks[x + 1][this.averageSpace.tile.k].faction == sandmap.players.indexOf(this)) {
                                    break
                                }
                                if (x < 0 || x > (worldscale - 1)) {
                                    continue
                                }
                                if ((Math.abs(this.averageSpace.tile.t - x) > 16)) {
                                    continue
                                }
                                if (this.blocks[x + 1][this.averageSpace.tile.k].markdraw != 1 || (Math.abs(this.averageSpace.tile.t - x) > 15)) {
                                    this.buildWall(sandmap.blocks[x][this.averageSpace.tile.k])
                                } else if (x == (worldscale - 2)) {
                                    this.buildWall(sandmap.blocks[x][this.averageSpace.tile.k])
                                }
                                if (debreak == 0) {
                                    break
                                }
                            }
                        }
                    }





                    //sliced in


                    if ((Math.random() * .13) && this.hotrock >= 10) {

                        for (let t = 0; t < this.units.length; t++) {
                            if (this.units[t].tile.sourcerock >= 1 || ((Math.random() * .03) && this.units[t].index < this.units[t].realPath.length - 1)) {

                            } else {
                                continue
                            }


                            const calcdeath = this.units[t].health / (((this.units[t].decayRate * this.units[t].decayingInTheWind * sandmap.windspeed)))

                            if (Math.abs(this.units[t].realPath.length - this.units[t].index) < 3 || Math.abs(this.units[t].realPath.length - this.units[t].index) > (calcdeath - (this.units[t].movespeed * 10))) {

                                // //////////console.log(this.units[t])

                            } else {
                                continue
                            }


                            if ((this.units[t].decayingInTheWind == 1 && this.units[t].drone != 1) || (this.units[t].decayingInTheWind == 1 && this.units[t].drone == 1 && (Math.random() < (this.hotrock * .002)))) {
                                if (this.units[t].dirs2 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.k; x < (worldscale - 1); x++) {
                                            if (sandmap.blocks[this.units[t].tile.t][x + 1].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.k - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[this.units[t].tile.t][x + 1].markdraw != 1 || Math.abs(this.units[t].tile.k - x) > 15) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            } else if (x == (worldscale - 2)) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs4 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.k; x > 1; x--) {
                                            if (sandmap.blocks[this.units[t].tile.t][x - 1].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.k - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[this.units[t].tile.t][x - 1].markdraw != 1 || Math.abs(this.units[t].tile.k - x) > 15) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            } else if (x == 2) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs3 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.t; x > 1; x--) {
                                            if (sandmap.blocks[x - 1][this.units[t].tile.k].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.t - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[x - 1][this.units[t].tile.k].markdraw != 1 || Math.abs(this.units[t].tile.t - x) > 15) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            } else if (x == 2) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs1 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.t; x < (worldscale - 1); x++) {
                                            if (sandmap.blocks[x + 1][this.units[t].tile.k].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.t - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[x + 1][this.units[t].tile.k].markdraw != 1 || Math.abs(this.units[t].tile.t - x) > 15) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            } else if (x == (worldscale - 2)) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }


                            } else if ((this.units[t].decayingInTheWind > .51 && this.units[t].decayingInTheWind < .8 && this.units[t].drone != 1) || (this.units[t].decayingInTheWind > .51 && this.units[t].decayingInTheWind < .8 && this.units[t].drone == 1 && (Math.random() < (this.hotrock * .004)))) {
                                if (this.units[t].dirs2 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.k; x < (worldscale - 1); x++) {
                                            if (sandmap.blocks[this.units[t].tile.t][x + 1].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.k - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[this.units[t].tile.t][x + 1].markdraw != 1 || Math.abs(this.units[t].tile.k - x) > 15) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            } else if (x == (worldscale - 2)) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs4 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.k; x > 1; x--) {
                                            if (sandmap.blocks[this.units[t].tile.t][x - 1].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.k - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[this.units[t].tile.t][x - 1].markdraw != 1 || Math.abs(this.units[t].tile.k - x) > 15) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            } else if (x == 2) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs3 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.t; x > 1; x--) {
                                            if (sandmap.blocks[x - 1][this.units[t].tile.k].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.t - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[x - 1][this.units[t].tile.k].markdraw != 1 || Math.abs(this.units[t].tile.t - x) > 15) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            } else if (x == 2) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs1 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.t; x < (worldscale - 1); x++) {
                                            if (sandmap.blocks[x + 1][this.units[t].tile.k].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.t - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[x + 1][this.units[t].tile.k].markdraw != 1 || Math.abs(this.units[t].tile.t - x) > 15) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            } else if (x == (worldscale - 2)) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }



                            } else if ((this.units[t].decayingInTheWind > .27 && this.units[t].decayingInTheWind < .55 && this.units[t].drone != 1) || (this.units[t].decayingInTheWind > .27 && this.units[t].decayingInTheWind < .55 && this.units[t].drone == 1 && (Math.random() < (this.hotrock * .006)))) {
                                if (this.units[t].dirs2 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.k; x < (worldscale - 1); x++) {
                                            if (sandmap.blocks[this.units[t].tile.t][x + 1].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.k - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[this.units[t].tile.t][x + 1].markdraw != 1 || Math.abs(this.units[t].tile.k - x) > 15) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            } else if (x == (worldscale - 2)) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs4 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.k; x > 1; x--) {
                                            if (sandmap.blocks[this.units[t].tile.t][x - 1].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.k - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[this.units[t].tile.t][x - 1].markdraw != 1 || Math.abs(this.units[t].tile.k - x) > 15) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            } else if (x == 2) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs3 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.t; x > 1; x--) {
                                            if (sandmap.blocks[x - 1][this.units[t].tile.k].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.t - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[x - 1][this.units[t].tile.k].markdraw != 1 || Math.abs(this.units[t].tile.t - x) > 15) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            } else if (x == 2) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs1 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.t; x < (worldscale - 1); x++) {
                                            if (sandmap.blocks[x + 1][this.units[t].tile.k].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.t - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[x + 1][this.units[t].tile.k].markdraw != 1 || Math.abs(this.units[t].tile.t - x) > 15) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            } else if (x == (worldscale - 2)) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                            } else if ((this.units[t].decayingInTheWind >= .01 && this.units[t].decayingInTheWind < .3 && this.units[t].drone != 1) || (this.units[t].decayingInTheWind > .01 && this.units[t].decayingInTheWind < .3 && this.units[t].drone == 1 && (Math.random() < (this.hotrock * .008)))) {
                                if (this.units[t].dirs2 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.k; x < (worldscale - 1); x++) {
                                            if (sandmap.blocks[this.units[t].tile.t][x + 1].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.k - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[this.units[t].tile.t][x + 1].markdraw != 1 || Math.abs(this.units[t].tile.k - x) > 15) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            } else if (x == (worldscale - 2)) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs4 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.k; x > 1; x--) {
                                            if (sandmap.blocks[this.units[t].tile.t][x - 1].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.k - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[this.units[t].tile.t][x - 1].markdraw != 1 || Math.abs(this.units[t].tile.k - x) > 15) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            } else if (x == 2) {
                                                this.buildWall(sandmap.blocks[this.units[t].tile.t][x])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs3 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.t; x > 1; x--) {
                                            if (sandmap.blocks[x - 1][this.units[t].tile.k].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.t - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[x - 1][this.units[t].tile.k].markdraw != 1 || Math.abs(this.units[t].tile.t - x) > 15) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            } else if (x == 2) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                                if (this.units[t].dirs1 == 1) {
                                } else {
                                    if (this.units[t].health < (this.units[t].maxhealth * .99)) {
                                        for (let x = this.units[t].tile.t; x < (worldscale - 1); x++) {
                                            if (sandmap.blocks[x + 1][this.units[t].tile.k].faction == sandmap.players.indexOf(this)) {
                                                break
                                            }
                                            if (x < 0 || x > (worldscale - 1)) {
                                                continue
                                            }
                                            if (Math.abs(this.units[t].tile.t - x) > 16) {
                                                continue
                                            }
                                            if (this.blocks[x + 1][this.units[t].tile.k].markdraw != 1 || Math.abs(this.units[t].tile.t - x) > 15) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            } else if (x == (worldscale - 2)) {
                                                this.buildWall(sandmap.blocks[x][this.units[t].tile.k])
                                            }
                                            if (debreak == 0) {
                                                break
                                            }
                                        }
                                    }
                                }
                            } else {


                            }
                        }

                    }




                    //sliced in

                }

                if (this.units.length > 25) {
                    if (this.attacktimeout <= 0) {
                        this.aimode = 1
                        this.attacktimeout = 3000
                    }
                    this.attacktimeout--
                }
            }



        }
        buildWallOld(tile, options = 0) {
            if (this.type == 1) {
                return
            } else if (this.type == 4) {
                // if (this.racks == 0 && this.isAI == 1) {
                //     this.buildBarracks(tile)
                // } else if (this.lab == 0 && this.isAI == 1 && this.hotrock > 150) {
                //     this.buildMachineLab(tile)
                // } else {
                let wet = 0
                for (let t = 0; t < this.buildings.length; t++) {
                    if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                        wet = 1
                        debreak = 1
                        // //////////console.log(tile)
                    }
                }
                if (tile.walkable == false) {
                    let us = 0
                    for (let u = 0; u < this.units.length; u++) {
                        if (this.units[u].tile == tile) {
                            us = 1
                        }
                    }
                    if (us == 0) {
                        wet = 1
                    }
                }
                if (tile.builtOn == 1) {
                    wet = 1
                }
                if (wet == 0) {
                    if (this.hotrock >= 5) {
                        this.hotrock -= 5
                        const building = new Building(tile, this, 0, 1, 5)
                        building.name = "Slime"
                        building.defense = 0
                        building.damage = 0
                        building.tile.spiretile = 1
                        building.tile.walkable = true
                        building.tile.slime = true
                        this.slimeflag = 1
                        building.slime = 1
                        building.health = 5
                        building.maxhealth = building.health
                        building.pather = slimyastar
                        building.active = 0
                        building.tile.primed = 0
                        building.pather.agent = building
                        for (let t = 0; t < this.buildings.length; t++) {
                            if (this.buildings[t].sporeball == 1) {
                                sandmap.diagonal = false
                                const path = [...building.pather.search(sandmap, building.tile, this.buildings[t].tile, {})]
                                sandmap.diagonal = true
                                //////////console.log(path)
                                if (path.length > 0) {
                                    building.active = 1
                                    building.tile.primed = 1
                                    break
                                }
                            }
                        }
                    }
                }
                // }
            } else if (this.type == 0) {
                if (this.racks == 0 && this.isAI == 1) {
                    this.buildBarracks(tile)
                } else if (this.lab == 0 && this.isAI == 1 && this.hotrock > 150) {
                    this.buildMachineLab(tile)
                } else {
                    let wet = 0
                    for (let t = 0; t < this.buildings.length; t++) {
                        if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                            wet = 1
                            debreak = 1
                            // //////////console.log(tile)
                        }
                    }
                    if (tile.walkable == false) {
                        wet = 1
                    }
                    if (wet == 0) {
                        if (this.hotrock >= 10) {
                            this.hotrock -= 10
                            const building = new Building(tile, this, 0, 1, 10)
                            building.defense = 3
                            building.wall = 1
                            building.damage = 0
                        }
                    }
                }
            } else if (this.type == 2) {

                this.Bflag = 0

                //////////console.log("d")
                if (this.hotrock > (this.racksflag * 75)) {
                    // //////////console.log("hamartan effect")
                    this.racks = 0
                    this.lab = 0
                    this.racksflag += 4
                }

                if (this.racks == 0 && this.isAI == 1 && this.hotrock > 340 && options == 0) {
                    if (Math.random() < .95) {
                        this.buildGate(tile)
                    } else if (this.lab == 0 && this.isAI == 1 && this.hotrock > 150 && options == 0) {
                        this.buildBarracks(tile)
                    }
                } else if (this.lab == 0 && this.isAI == 1 && this.hotrock > 150 && this.racks == 1 && options == 0) {
                    this.buildBarracks(tile)
                } else if (this.lab == 1 && this.isAI == 1 && this.hotrock > 150 && this.racks == 1 && options == 0) {
                    this.buildMachineLab(tile)
                } else {
                    let wet = 0
                    for (let t = 0; t < this.buildings.length; t++) {
                        if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                            wet = 1
                            debreak = 1
                            // //////////console.log(tile)
                        }
                    }
                    if (tile.walkable == false) {
                        wet = 1
                    }
                    //////////console.log("a")
                    if (wet == 0) {
                        //////////console.log("b")
                        if (this.hotrock >= 40) {
                            //////////console.log("c")
                            // this.racks = 1
                            this.hotrock -= 40
                            const building = new Building(tile, this, 0, 1, 40)
                            building.defense = 10
                            building.damage = 0
                            building.name = "Spire"
                            building.animated = 1
                            building.body2 = new UnitCircle(building.tile.x + 5, building.tile.y + 5, 110, this.color + "10")
                            building.bodybig = new UnitCircle(building.tile.x + 5, building.tile.y + 5, 170, this.color + "10")
                            building.health = 420
                            building.maxhealth = building.health
                            building.spire = 1
                            building.tile.spiretile = 1
                            for (let t = 0; t < this.units.length; t++) {
                                this.units[t].spirecheck()
                            }
                        }
                    }
                }
            }

        }
        buildPond(tile, options = 0) {

            this.Bflag = 0
            this.Nflag = 0
            this.Gflag = 0
            this.Mflag = 0
            if (this.type == 7) {
                let wet = 0
                for (let t = 0; t < this.buildings.length; t++) {
                    if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                        wet = 1
                        debreak = 1
                    }
                }
                if (tile.walkable == false) {
                    let us = 0
                    for (let u = 0; u < this.units.length; u++) {
                        if (this.units[u].tile == tile) {
                            us = 1
                        }
                    }
                    if (us == 0) {
                        wet = 1
                    }
                }
                if (tile.builtOn == 1) {
                    wet = 1
                }
                if (wet == 0) {
                    if (this.hotrock >= 250) {
                        this.Bflag = 0
                        this.hotrock -= 250
                        const building = new Building(tile, this, 0, 0, 250)
                        building.pond = 1
                        building.alagadile = 1
                        // building.eggtimer = 300
                        building.name = "Alagadile Pond"
                        building.animated = 1
                        building.defense = 12
                        building.damage = 0
                        // building.body = new UnitCircle(building.tile.x + 5, building.tile.y + 5, 110, this.color + "10")
                        // building.bodybig = new UnitCircle(building.tile.x + 5, building.tile.y + 5, 170, this.color + "10")
                        building.health = 1260
                        building.maxhealth = building.health
                        building.tile.spiretile = 1
                    }
                }
            }
        }
        buildTeleporter(tile, options = 0) {
            this.Bflag = 0
            this.Nflag = 0
            this.Gflag = 0
            this.Mflag = 0
            if (this.type == 7) {
                let wet = 0
                for (let t = 0; t < this.buildings.length; t++) {
                    if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                        wet = 1
                        debreak = 1
                    }
                }
                if (tile.walkable == false) {
                    let us = 0
                    for (let u = 0; u < this.units.length; u++) {
                        if (this.units[u].tile == tile) {
                            us = 1
                        }
                    }
                    if (us == 0) {
                        wet = 1
                    }
                }
                if (tile.builtOn == 1) {
                    wet = 1
                }
                if (wet == 0) {
                    if (this.hotrock >= 300) {
                        this.Bflag = 0
                        this.hotrock -= 300
                        const building = new Building(tile, this, 0, 1, 250)
                        building.teleporter = 1
                        building.alagadile = 1
                        // building.eggtimer = 300
                        building.name = "Alagadile Teleporter Pad"
                        building.tile.spiretile = 1
                        building.tile.walkable = true
                        building.open = -1
                        building.animated = 1
                        building.defense = 3
                        building.damage = 0
                        // building.body = new UnitCircle(building.tile.x + 5, building.tile.y + 5, 110, this.color + "10")
                        // building.bodybig = new UnitCircle(building.tile.x + 5, building.tile.y + 5, 170, this.color + "10")
                        building.health = 500
                        building.maxhealth = building.health
                        building.tile.spiretile = 1
                    }
                }
            }
        }

        buildHive(tile, options = 0) {
            this.Bflag = 0
            this.Nflag = 0
            this.Gflag = 0
            this.Mflag = 0
            if (this.type == 10) {
                let wet = 0
                for (let t = 0; t < this.buildings.length; t++) {
                    if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                        wet = 1
                        debreak = 1
                    }
                }
                if (tile.walkable == false) {
                    let us = 0
                    for (let u = 0; u < this.units.length; u++) {
                        if (this.units[u].tile == tile) {
                            us = 1
                        }
                    }
                    if (us == 0) {
                        wet = 1
                    }
                }
                if (tile.builtOn == 1) {
                    wet = 1
                }
                if (wet == 0) {
                    if (this.hotrock >= 400) {
                        this.Bflag = 0
                        this.hotrock -= 400
                        const building = new Building(tile, this, 0, 0, 250)
                        building.bee = 1
                        building.beehive = 1
                        // building.eggtimer = 300
                        building.name = "Beeple Hive"
                        building.animated = 1
                        building.defense = 30
                        building.damage = 0
                        // building.body = new UnitCircle(building.tile.x + 5, building.tile.y + 5, 110, this.color + "10")
                        // building.bodybig = new UnitCircle(building.tile.x + 5, building.tile.y + 5, 170, this.color + "10")
                        building.health = 5000
                        building.maxhealth = building.health
                        building.tile.spiretile = 1
                    }
                }
            }
        }
        buildTree(tile, options = 0) {

            this.Bflag = 0
            this.Nflag = 0
            this.Gflag = 0
            this.Mflag = 0
            if (this.type == 9) {
                let wet = 0
                for (let t = 0; t < this.buildings.length; t++) {
                    if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                        wet = 1
                        debreak = 1
                    }
                }
                if (tile.walkable == false) {
                    let us = 0
                    for (let u = 0; u < this.units.length; u++) {
                        if (this.units[u].tile == tile) {
                            us = 1
                        }
                    }
                    if (us == 0) {
                        wet = 1
                    }
                }
                if (tile.builtOn == 1) {
                    wet = 1
                }
                if (wet == 0) {
                    if (this.hotrock >= 200) {
                        this.hotrock -= 200
                        this.Bflag = 0
                        const building = new Building(tile, this, 0, 0, 200)
                        building.tree = 1
                        building.gogo = 1
                        // building.eggtimer = 300
                        building.name = "Gogonaut Tree"
                        building.defense = 30
                        building.damage = 0
                        // building.body = new UnitCircle(building.tile.x + 5, building.tile.y + 5, 110, this.color + "10")
                        // building.bodybig = new UnitCircle(building.tile.x + 5, building.tile.y + 5, 170, this.color + "10")
                        building.health = 4000
                        building.maxhealth = building.health
                        building.tile.spiretile = 1
                    }
                }
            }
        }

        buildMound(tile, options = 0) {
            this.Bflag = 0
            this.Nflag = 0
            this.Gflag = 0
            this.Mflag = 0
            if (this.type == 5) {
                let wet = 0
                for (let t = 0; t < this.buildings.length; t++) {
                    if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                        wet = 1
                        debreak = 1
                    }
                }
                if (tile.walkable == false) {
                    let us = 0
                    for (let u = 0; u < this.units.length; u++) {
                        if (this.units[u].tile == tile) {
                            us = 1
                        }
                    }
                    if (us == 0) {
                        wet = 1
                    }
                }
                if (tile.builtOn == 1) {
                    wet = 1
                }
                if (wet == 0) {
                    if (this.hotrock >= 105) {
                        this.hotrock -= 105
                        this.Bflag = 0
                        const building = new Building(tile, this, 0, 1, 105)
                        building.mound = 1
                        building.ave = 1
                        building.eggtimer = 300
                        building.name = "Avesectian Eggmound"
                        building.defense = 12
                        building.damage = 0
                        // building.body = new UnitCircle(building.tile.x + 5, building.tile.y + 5, 110, this.color + "10")
                        // building.bodybig = new UnitCircle(building.tile.x + 5, building.tile.y + 5, 170, this.color + "10")
                        building.health = 1260
                        building.maxhealth = building.health
                        building.tile.spiretile = 1
                    }
                }
            }
        }
        buildEgg(tile) {
            if (this.type == 5) {
                let wet = 0
                for (let t = 0; t < this.buildings.length; t++) {
                    if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                        wet = 1
                        debreak = 1
                    }
                }
                // if (tile.walkable == false) {
                //     let us = 0
                //     for (let u = 0; u < this.units.length; u++) {
                //         if (this.units[u].tile == tile) {
                //             us = 1
                //         }
                //     }
                //     if (us == 0) {
                //         wet = 1
                //     }
                // }
                if (tile.builtOn == 1) {
                    wet = 1
                }
                if (tile.ice == 1) {
                    wet = 1
                }
                if (wet == 0) {
                    const building = new Building(tile, this, 0, 1, 0)
                    building.ave = 1
                    building.egg = 1
                    building.name = "Avesectian Egg"
                    building.defense = 24
                    building.damage = 0
                    // building.body = new UnitCircle(building.tile.x + 5, building.tile.y + 5, 110, this.color + "10")
                    // building.bodybig = new UnitCircle(building.tile.x + 5, building.tile.y + 5, 170, this.color + "10")
                    building.health = 100
                    building.maxhealth = building.health
                    building.tile.spiretile = 1
                    building.tile.walkable = true
                    return true
                }
            }
            return false
        }
        buildWall(tile, options = 0) {

            //////////console.log("F")
            if (this.type == 1) {
                return
            } else if (this.type == 4 || this.type == -1) {
                // if (this.racks == 0 && this.isAI == 1) {
                //     this.buildBarracks(tile)
                // } else if (this.lab == 0 && this.isAI == 1 && this.hotrock > 150) {
                //     this.buildMachineLab(tile)
                // } else {
                let wet = 0
                for (let t = 0; t < this.buildings.length; t++) {
                    if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                        wet = 1
                        debreak = 1
                        // //////////console.log(tile)
                    }
                }
                if (tile.walkable == false) {
                    let us = 0
                    for (let u = 0; u < this.units.length; u++) {
                        if (this.units[u].tile == tile) {
                            us = 1
                        }
                    }
                    if (us == 0) {
                        wet = 1
                    }
                }
                if (tile.builtOn == 1) {
                    wet = 1
                }
                // //////////console.log("0")

                if (wet == 0) {
                    // //////////console.log("a")
                    if (this.hotrock >= 2) {
                        // //////////console.log("b")

                        this.hotrock -= 2
                        const building = new Building(tile, this, 0, 1, 2)
                        building.name = "Slime"
                        building.defense = 0
                        building.damage = 0
                        building.tile.spiretile = 1
                        building.tile.walkable = true
                        building.tile.slime = true
                        this.slimeflag = 1
                        building.slime = 1
                        building.health = 5
                        building.maxhealth = building.health
                        building.pather = slimyastar
                        building.active = 0
                        building.tile.primed = 0
                        building.pather.agent = building
                        for (let t = 0; t < this.buildings.length; t++) {
                            this.buildings[t].slimeossify = 50
                        }


                        let sporeballblock = {}
                        let max = 9999999999
                        let wet = 0
                        for (let t = 0; t < this.buildings.length; t++) {
                            if (this.buildings[t].sporeball == 1) {
                                let dis = (Math.abs(building.tile.k - this.buildings[t].tile.k)) + (Math.abs(building.tile.t - this.buildings[t].tile.t))
                                if (dis < max) {
                                    max = dis
                                    sporeballblock = this.buildings[t].tile
                                    wet = 1
                                }

                            }
                        }
                        // if(wet == 1){
                        //     sandmap.diagonal = false
                        //     sandmap.slimeflag = 1
                        //     const path = [...this.pather.search(sandmap, this.tile, sporeballblock, {})]
                        //     sandmap.slimeflag = 0
                        //     sandmap.diagonal = true
                        //         sum += path.length
                        // }


                        // for (let t = 0; t < this.buildings.length; t++) {
                        //     if (this.buildings[t].sporeball == 1) {
                        if (wet == 1) {
                            // sandmap.diagonal = false
                            // // const path = [...building.pather.search(sandmap, building.tile, sporeballblock, {})]
                            // sandmap.diagonal = true
                            //////////console.log(path)
                            // if (path.length > 0) {
                            building.active = 1
                            building.tile.primed = 1
                            // break
                            // }
                        }
                        //     }
                        // }
                    }
                }
                // }
            } else if (this.type == 0) {
                if (this.racks == 0 && this.isAI == 1) {
                    this.buildBarracks(tile)
                } else if (this.lab == 0 && this.isAI == 1 && this.hotrock >= 110) { //150
                    this.buildMachineLab(tile)
                } else {
                    let wet = 0
                    for (let t = 0; t < this.buildings.length; t++) {
                        if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                            wet = 1
                            debreak = 1
                            // //////////console.log()
                            // //////////console.log(tile)
                        }
                    }
                    if (tile.walkable == false) {
                        wet = 1
                    }
                    if (wet == 0) {
                        if (this.hotrock >= 10) {
                            this.hotrock -= 10
                            // hotsum+=10
                            // //////////console.log(hotsum, this.buildings.length)
                            const building = new Building(tile, this, 0, 1, 10)
                            building.defense = 3
                            building.wall = 1
                            building.tile.wallflag = 1
                            building.wallflag = 1
                            building.earth = 1
                            building.damage = 0
                        }
                    }
                }
            } else if (this.type == 2) {

                //////////console.log("F")
                this.Bflag = 0
                if (this.hotrock > (this.racksflag * 75)) {
                    //////////console.log("hamartan effect")
                    this.racks = 0
                    this.lab = 0
                    this.racksflag += 4
                }
                let workfactory = 0
                let spiredistancemin = 999999999
                const link = new LineOP(tile, {})
                let moistened = 0
                if (this.isAI == 1) {
                    for (let t = 0; t < this.buildings.length; t++) {
                        if (this.buildings[t].assembler == 3) {
                            workfactory = 1
                        }
                        if (this.buildings[t].spire == 1) {
                            link.target = this.buildings[t].tile
                            const dis = link.hypotenuse()
                            if (dis < spiredistancemin) {
                                spiredistancemin = dis
                                if (spiredistancemin <= this.buildings[t].body2.radius) {
                                    moistened = 1
                                    break
                                }
                            }
                        }
                    }
                }

                if (workfactory == 0 && options == 0) {
                    if (this.isAI == 1) {
                        this.buildGate(tile)
                    } else {

                        //////////console.log("A")
                        let wet = 0
                        for (let t = 0; t < this.buildings.length; t++) {
                            if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                                wet = 1
                                debreak = 1
                                // //////////console.log(tile)
                            }
                        }
                        if (tile.walkable == false) {
                            wet = 1
                        }
                        if (wet == 0) {
                            if (moistened == 0) {
                                //////////console.log("B")
                                if (this.hotrock >= 40) {
                                    //////////console.log("C")
                                    // this.racks = 1
                                    this.hotrock -= 40
                                    const building = new Building(tile, this, 0, 1, 40)
                                    building.defense = 10
                                    building.damage = 0
                                    building.name = "Spire"
                                    building.animated = 1
                                    building.body2 = new UnitCircle(building.tile.x + 5, building.tile.y + 5, 110, this.color + "10")
                                    building.bodybig = new UnitCircle(building.tile.x + 5, building.tile.y + 5, 170, this.color + "10")
                                    building.health = 420
                                    building.maxhealth = building.health
                                    building.spire = 1
                                    building.tile.spiretile = 1
                                    for (let t = 0; t < this.units.length; t++) {
                                        this.units[t].spirecheck()
                                    }
                                }
                            }
                        }
                    }
                } else if (this.racks == 0 && this.isAI == 1 && this.hotrock > 340 && options == 0) {
                    this.buildGate(tile)
                } else if (this.lab == 0 && this.isAI == 1 && this.hotrock > 150 && this.racks == 1 && options == 0) {
                    this.buildBarracks(tile)
                } else if (this.lab == 1 && this.isAI == 1 && this.hotrock >= 210 && this.racks == 1 && options == 0) {
                    this.buildMachineLab(tile)
                    //////////console.log("scout assembler")
                } else {
                    //////////console.log("A")
                    let wet = 0
                    for (let t = 0; t < this.buildings.length; t++) {
                        if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                            wet = 1
                            debreak = 1
                            // //////////console.log(tile)
                        }
                    }

                    let spiredistancemin = 999999999
                    const link = new LineOP(tile, {})
                    let moistened = 0
                    if (this.isAI == 1) {
                        for (let t = 0; t < this.buildings.length; t++) {
                            if (this.buildings[t].spire == 1) {
                                link.target = this.buildings[t].tile
                                const dis = link.hypotenuse()
                                if (dis < spiredistancemin) {
                                    spiredistancemin = dis
                                    if (spiredistancemin <= this.buildings[t].body2.radius) {
                                        moistened = 1
                                        break
                                    }
                                }
                            }
                        }
                    }
                    if (tile.walkable == false) {
                        wet = 1
                    }
                    if (wet == 0) {
                        //////////console.log("B")
                        if (moistened == 0) {
                            if (this.hotrock >= 40) {
                                //////////console.log("C")
                                // this.racks = 1
                                this.hotrock -= 40
                                const building = new Building(tile, this, 0, 1, 40)
                                building.defense = 10
                                building.damage = 0
                                building.name = "Spire"
                                building.animated = 1
                                building.body2 = new UnitCircle(building.tile.x + 5, building.tile.y + 5, 110, this.color + "10")
                                building.bodybig = new UnitCircle(building.tile.x + 5, building.tile.y + 5, 170, this.color + "10")
                                building.health = 420
                                building.maxhealth = building.health
                                building.spire = 1
                                building.tile.spiretile = 1
                                for (let t = 0; t < this.units.length; t++) {
                                    this.units[t].spirecheck()
                                }
                            }
                        }
                    }
                }
            }

        }
        buildWallHamartans(tile, options = 0) {
            if (this.type == 2) {

                //////////console.log("F")
                this.Bflag = 0
                if (this.hotrock > (this.racksflag * 75)) {
                    //////////console.log("hamartan effect")
                    this.racks = 0
                    this.lab = 0
                    this.racksflag += 10
                }
                let workfactory = 0
                let spiredistancemin = 999999999
                const link = new LineOP(tile, {})
                let moistened = 0
                if (this.isAI == 1) {
                    for (let t = 0; t < this.buildings.length; t++) {
                        if (this.buildings[t].assembler == 3) {
                            if (this.buildings[t].que != 1) {
                                workfactory = 1
                            }
                        }
                        if (this.buildings[t].spire == 1) {
                            link.target = this.buildings[t].tile
                            const dis = link.hypotenuse()
                            if (dis < spiredistancemin) {
                                spiredistancemin = dis
                                if (spiredistancemin <= this.buildings[t].body2.radius) {
                                    moistened = 1
                                    break
                                }
                            }
                        }
                    }
                }

                if (workfactory == 0 && options == 0) {
                    if (this.isAI == 1) {
                        this.buildGate(tile)
                    } else {

                        //////////console.log("A")
                        let wet = 0
                        for (let t = 0; t < this.buildings.length; t++) {
                            if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                                wet = 1
                                debreak = 1
                                // //////////console.log(tile)
                            }
                        }
                        if (tile.walkable == false) {
                            wet = 1
                        }
                        if (wet == 0) {
                            if (moistened == 0) {
                                //////////console.log("B")
                                if (this.hotrock >= 40) {
                                    //////////console.log("C")
                                    // this.racks = 1
                                    this.hotrock -= 40
                                    const building = new Building(tile, this, 0, 1, 40)
                                    building.defense = 10
                                    building.damage = 0
                                    building.name = "Spire"
                                    building.animated = 1
                                    building.body2 = new UnitCircle(building.tile.x + 5, building.tile.y + 5, 110, this.color + "10")
                                    building.bodybig = new UnitCircle(building.tile.x + 5, building.tile.y + 5, 170, this.color + "10")
                                    building.health = 420
                                    building.maxhealth = building.health
                                    building.spire = 1
                                    building.tile.spiretile = 1
                                    for (let t = 0; t < this.units.length; t++) {
                                        this.units[t].spirecheck()
                                    }
                                }
                            }
                        }
                    }
                } else if (this.racks == 0 && this.isAI == 1 && (this.hotrock > 340 && workfactory == 0) && options == 0) {
                    // this.buildGate(tile)
                } else if (this.lab == 0 && this.isAI == 1 && this.hotrock > 150 && this.racks == 1 && options == 0) {
                    this.buildBarracks(tile)
                } else if (this.lab == 1 && this.isAI == 1 && this.hotrock >= 210 && this.racks == 1 && options == 0) {
                    this.buildMachineLab(tile)
                    //////////console.log("scout assembler")
                } else {
                    //////////console.log("A")
                    let wet = 0
                    for (let t = 0; t < this.buildings.length; t++) {
                        if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                            wet = 1
                            debreak = 1
                            // //////////console.log(tile)
                        }
                    }

                    let spiredistancemin = 999999999
                    const link = new LineOP(tile, {})
                    let moistened = 0
                    if (this.isAI == 1) {
                        for (let t = 0; t < this.buildings.length; t++) {
                            if (this.buildings[t].spire == 1) {
                                link.target = this.buildings[t].tile
                                const dis = link.hypotenuse()
                                if (dis < spiredistancemin) {
                                    spiredistancemin = dis
                                    if (spiredistancemin <= this.buildings[t].body2.radius) {
                                        moistened = 1
                                        break
                                    }
                                }
                            }
                        }
                    }
                    if (tile.walkable == false) {
                        wet = 1
                    }
                    if (wet == 0) {
                        //////////console.log("B")
                        if (moistened == 0) {
                            if (this.hotrock >= 40) {
                                //////////console.log("C")
                                // this.racks = 1
                                this.hotrock -= 40
                                const building = new Building(tile, this, 0, 1, 40)
                                building.defense = 10
                                building.damage = 0
                                building.name = "Spire"
                                building.animated = 1
                                building.body2 = new UnitCircle(building.tile.x + 5, building.tile.y + 5, 110, this.color + "10")
                                building.bodybig = new UnitCircle(building.tile.x + 5, building.tile.y + 5, 170, this.color + "10")
                                building.health = 420
                                building.maxhealth = building.health
                                building.spire = 1
                                building.tile.spiretile = 1
                                for (let t = 0; t < this.units.length; t++) {
                                    this.units[t].spirecheck()
                                }
                            }
                        }
                    }
                }
            }

        }
        buildGate(tile) {
            if (this.type == 1) {
                return
            } else if (this.type == 0) {
                if (this.racks == 0 && this.isAI == 1) {
                    this.buildBarracks(tile)
                } else if (this.lab == 0 && this.isAI == 1 && this.hotrock > 150) {
                    this.buildMachineLab(tile)
                } else {
                    let wet = 0
                    for (let t = 0; t < this.buildings.length; t++) {
                        if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                            wet = 1
                            debreak = 1
                            // //////////console.log(tile)
                        }
                    }
                    if (tile.walkable == false) {
                        wet = 1
                    }
                    if (wet == 0) {
                        if (this.hotrock >= 25) {
                            this.hotrock -= 25
                            const building = new Building(tile, this, 0, 0, 25)
                            building.health = 1000
                            building.maxhealth = building.health
                            building.defense = 35
                            building.damage = 0
                            building.gate = 1
                            building.name = "Blast Door"
                            building.earth = 1
                            building.animated = 1
                            building.open = -1
                            building.tile.wallflag = 1
                            // building.tile.spiretile = 1
                            building.wallflag = 1
                        }
                    }
                }
            } else if (this.type == 2) {

                this.Gflag = 0
                let wet = 0
                for (let t = 0; t < this.buildings.length; t++) {
                    if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                        wet = 1
                        debreak = 1
                        // //////////console.log(tile)
                    }
                }
                if (tile.walkable == false) {
                    wet = 1
                }
                if (wet == 0) {
                    if (this.hotrock >= 340) {
                        this.hotrock -= 340
                        const building = new Building(tile, this, 0, 0, 340)
                        building.health = 1300
                        building.maxhealth = building.health
                        building.defense = 15
                        building.damage = 0
                        building.assembler = 3
                        building.tile.spiretile = 1
                        building.name = "High-Caste Assembler"
                        building.animated = 1
                        this.racks = 1
                    }
                }

            }

        }
        buildBarracks(tile) {

            if (this.type == 1) {
                return
            } else if (this.type == 4) {

                this.Nflag = 0
                let wet = 0
                if (tile.walkable == false) {
                    wet = 1
                }
                for (let t = 0; t < this.buildings.length; t++) {
                    if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                        wet = 1
                    }
                }
                if (wet == 0) {

                    if (this.hotrock >= 140) {
                        this.racks = 1
                        this.hotrock -= 140
                        const building = new Building(tile, this, 0, 1, 140)
                        building.sporeball = 1
                        building.tile.spiretile = 1
                        building.tile.slime = true
                        building.pather = slimemakingastar
                        building.name = "Sporeball"
                        this.slimeflag = 1
                        building.health = 1500
                        building.maxhealth = building.health
                        building.defense = 7
                        building.damage = 0
                    }
                }


            } else if (this.type == 0) {
                this.Nflag = 0


                let wet = 0
                if (tile.walkable == false) {
                    wet = 1
                }
                for (let t = 0; t < this.buildings.length; t++) {
                    if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                        wet = 1
                    }
                }
                if (wet == 0) {

                    if (this.hotrock >= 50) {
                        this.racks = 1
                        this.hotrock -= 50
                        const building = new Building(tile, this, 0, 0, 50)
                        building.barracks = 1
                        building.name = "Barracks"
                        building.animated = 1
                        building.earth = 1
                        building.health = 500
                        building.maxhealth = building.health
                        building.defense = 6
                        building.damage = 0
                        building.tile.wallflag = 1
                        building.wallflag = 1
                    }
                }

            } else if (this.type == 2) {

                this.Nflag = 0
                let wet = 0
                if (tile.walkable == false) {
                    wet = 1
                }
                for (let t = 0; t < this.buildings.length; t++) {
                    if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                        wet = 1
                    }
                }
                if (wet == 0) {

                    if (this.hotrock >= 130) {
                        this.lab = 1
                        this.hotrock -= 130
                        const building = new Building(tile, this, 0, 0, 130)
                        building.assembler = 1
                        building.name = "Soldier Assembler"
                        building.animated = 1
                        building.health = 500
                        building.maxhealth = building.health
                        building.defense = 6
                        building.damage = 0
                        building.tile.spiretile = 1
                    }
                }
            } else if (this.type == 3) {

                this.Nflag = 0
                let wet = 0
                let dirty = 0
                for (let t = 0; t < this.buildings.length; t++) {
                    if (this.buildings[t].bulbplant == 1) {
                        const link = new LineOP(tile, this.buildings[t].tile)
                        if (link.hypotenuse() < 160) {
                            dirty = 1
                        }
                    }
                }
                if (tile.walkable == false) {
                    wet = 1
                }
                for (let t = 0; t < this.buildings.length; t++) {
                    if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                        wet = 1
                    }
                }
                if (wet == 0 && ((dirty == 0 && this.isAI == 1) || this.isAI == 0)) {

                    if (this.hotrock >= 80) {
                        this.racks = 1
                        this.hotrock -= 80
                        const building = new Building(tile, this, 0, 1, 80)
                        building.bulbplant = 1
                        building.name = "Librilbian Bulbplant"
                        building.animated = 1
                        building.health = 500
                        building.maxhealth = building.health
                        building.defense = 6
                        building.damage = 0
                        building.tile.spiretile = 1
                        building.tile.dirt = 1
                    }
                }
            }
        }
        buildMachineLab(tile) {
            if (this.type == 1) {
                return
            } else if (this.type == 0) {

                this.Mflag = 0
                let wet = 0
                if (tile.walkable == false) {
                    wet = 1
                }
                for (let t = 0; t < this.buildings.length; t++) {
                    if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                        wet = 1
                    }
                }
                if (wet == 0) {

                    if (this.hotrock >= 110) {
                        this.lab = 1
                        this.hotrock -= 110
                        const building = new Building(tile, this, 0, 0, 110)
                        building.barracks = 2
                        building.name = "Machine Lab"
                        building.earth = 1
                        building.animated = 1
                        building.health = 1000
                        building.maxhealth = building.health
                        building.defense = 20
                        building.damage = 0
                        building.wallflag = 1
                        building.tile.wallflag = 1
                    }
                }
            } else if (this.type == 2) {

                this.Mflag = 0
                let wet = 0
                if (tile.walkable == false) {
                    wet = 1
                }
                for (let t = 0; t < this.buildings.length; t++) {
                    if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                        wet = 1
                    }
                }
                if (wet == 0) {

                    if (this.hotrock >= 210) {
                        this.lab = 2
                        this.hotrock -= 210
                        const building = new Building(tile, this, 0, 0, 210)
                        building.assembler = 2
                        building.name = "Scout Assembler"
                        building.animated = 1
                        building.health = 750
                        building.maxhealth = building.health
                        building.defense = 20
                        building.damage = 0
                        building.tile.spiretile = 1
                    }
                }
            } else if (this.type == 3) {

                this.Mflag = 0
                let wet = 0

                let dirty = 0
                for (let t = 0; t < this.buildings.length; t++) {
                    if (this.buildings[t].bulbplant == 1) {
                        const link = new LineOP(tile, this.buildings[t].tile)
                        if (link.hypotenuse() < 100) {
                            dirty = 1
                        }
                    }
                }
                if (tile.walkable == false) {
                    wet = 1
                }
                for (let t = 0; t < this.buildings.length; t++) {
                    if (tile == this.buildings[t].tile || this.blocks[tile.t][tile.k].markdraw != 1) {
                        wet = 1
                    }
                }
                if (wet == 0 && dirty == 1) {

                    if (this.hotrock >= 210) {
                        this.lab = 1
                        this.hotrock -= 210
                        const building = new Building(tile, this, 0, 0, 210)
                        building.bulbplant = 2
                        building.name = "Librilbian Podmother"
                        building.animated = 1
                        building.health = 1750
                        building.maxhealth = building.health
                        building.defense = 22
                        building.damage = 0
                        building.tile.spiretile = 1
                    }
                }
            }
        }
        groupControl() {
            if (keysPressed['Control']) {
                for (let t = 0; t < this.buildings.length; t++) {
                    if (keysPressed['0']) {
                        if (this.controlGroups[0].includes(this.buildings[t]) || this.buildings[t].selected == 0) {
                        } else {
                            this.controlGroups[0].push(this.buildings[t])
                        }
                    } else if (keysPressed['1']) {
                        if (this.controlGroups[1].includes(this.buildings[t]) || this.buildings[t].selected == 0) {
                        } else {
                            this.controlGroups[1].push(this.buildings[t])
                        }
                    } else if (keysPressed['2']) {
                        if (this.controlGroups[2].includes(this.buildings[t]) || this.buildings[t].selected == 0) {
                        } else {
                            this.controlGroups[2].push(this.buildings[t])
                        }
                    } else if (keysPressed['3']) {
                        if (this.controlGroups[3].includes(this.buildings[t]) || this.buildings[t].selected == 0) {
                        } else {
                            this.controlGroups[3].push(this.buildings[t])
                        }
                    } else if (keysPressed['4']) {
                        if (this.controlGroups[4].includes(this.buildings[t]) || this.buildings[t].selected == 0) {
                        } else {
                            this.controlGroups[4].push(this.buildings[t])
                        }
                    } else if (keysPressed['5']) {
                        if (this.controlGroups[5].includes(this.buildings[t]) || this.buildings[t].selected == 0) {
                        } else {
                            this.controlGroups[5].push(this.buildings[t])
                        }
                    } else if (keysPressed['6']) {
                        if (this.controlGroups[6].includes(this.buildings[t]) || this.buildings[t].selected == 0) {
                        } else {
                            this.controlGroups[6].push(this.buildings[t])
                        }
                    } else if (keysPressed['7']) {
                        if (this.controlGroups[7].includes(this.buildings[t]) || this.buildings[t].selected == 0) {
                        } else {
                            this.controlGroups[7].push(this.buildings[t])
                        }
                    } else if (keysPressed['8']) {
                        if (this.controlGroups[8].includes(this.buildings[t]) || this.buildings[t].selected == 0) {
                        } else {
                            this.controlGroups[8].push(this.buildings[t])
                        }
                    } else if (keysPressed['9']) {
                        if (this.controlGroups[9].includes(this.buildings[t]) || this.buildings[t].selected == 0) {
                        } else {
                            this.controlGroups[9].push(this.buildings[t])
                        }
                    }
                }
                for (let t = 0; t < this.units.length; t++) {
                    if (keysPressed['0']) {
                        if (this.controlGroups[0].includes(this.units[t]) || this.units[t].selected == 0) {
                        } else {
                            this.controlGroups[0].push(this.units[t])
                        }
                    } else if (keysPressed['1']) {
                        if (this.controlGroups[1].includes(this.units[t]) || this.units[t].selected == 0) {
                        } else {
                            this.controlGroups[1].push(this.units[t])
                        }
                    } else if (keysPressed['2']) {
                        if (this.controlGroups[2].includes(this.units[t]) || this.units[t].selected == 0) {
                        } else {
                            this.controlGroups[2].push(this.units[t])
                        }
                    } else if (keysPressed['3']) {
                        if (this.controlGroups[3].includes(this.units[t]) || this.units[t].selected == 0) {
                        } else {
                            this.controlGroups[3].push(this.units[t])
                        }
                    } else if (keysPressed['4']) {
                        if (this.controlGroups[4].includes(this.units[t]) || this.units[t].selected == 0) {
                        } else {
                            this.controlGroups[4].push(this.units[t])
                        }
                    } else if (keysPressed['5']) {
                        if (this.controlGroups[5].includes(this.units[t]) || this.units[t].selected == 0) {
                        } else {
                            this.controlGroups[5].push(this.units[t])
                        }
                    } else if (keysPressed['6']) {
                        if (this.controlGroups[6].includes(this.units[t]) || this.units[t].selected == 0) {
                        } else {
                            this.controlGroups[6].push(this.units[t])
                        }
                    } else if (keysPressed['7']) {
                        if (this.controlGroups[7].includes(this.units[t]) || this.units[t].selected == 0) {
                        } else {
                            this.controlGroups[7].push(this.units[t])
                        }
                    } else if (keysPressed['8']) {
                        if (this.controlGroups[8].includes(this.units[t]) || this.units[t].selected == 0) {
                        } else {
                            this.controlGroups[8].push(this.units[t])
                        }
                    } else if (keysPressed['9']) {
                        if (this.controlGroups[9].includes(this.units[t]) || this.units[t].selected == 0) {
                        } else {
                            this.controlGroups[9].push(this.units[t])
                        }
                    }
                }
            } else {

                for (let t = 0; t < this.buildings.length; t++) {
                    if (keysPressed['0'] || keysPressed[')']) {
                        for (let k = 0; k < this.buildings.length; k++) {
                            if (!keysPressed['Shift']) {
                                this.buildings[k].selected = 0
                            }
                        }
                        for (let k = 0; k < this.controlGroups[0].length; k++) {
                            this.controlGroups[0][k].selected = 1
                        }
                    } else if (keysPressed['1'] || keysPressed['!']) {
                        for (let k = 0; k < this.buildings.length; k++) {
                            if (!keysPressed['Shift']) {
                                this.buildings[k].selected = 0
                            }
                        }
                        for (let k = 0; k < this.controlGroups[1].length; k++) {
                            this.controlGroups[1][k].selected = 1
                        }
                    } else if (keysPressed['2'] || keysPressed['@']) {
                        for (let k = 0; k < this.buildings.length; k++) {
                            if (!keysPressed['Shift']) {
                                this.buildings[k].selected = 0
                            }
                        }
                        for (let k = 0; k < this.controlGroups[2].length; k++) {
                            this.controlGroups[2][k].selected = 1
                        }
                    } else if (keysPressed['3'] || keysPressed['#']) {
                        for (let k = 0; k < this.buildings.length; k++) {
                            if (!keysPressed['Shift']) {
                                this.buildings[k].selected = 0
                            }
                        }
                        for (let k = 0; k < this.controlGroups[3].length; k++) {
                            this.controlGroups[3][k].selected = 1
                        }
                    } else if (keysPressed['4'] || keysPressed['$']) {
                        for (let k = 0; k < this.buildings.length; k++) {
                            if (!keysPressed['Shift']) {
                                this.buildings[k].selected = 0
                            }
                        }
                        for (let k = 0; k < this.controlGroups[4].length; k++) {
                            this.controlGroups[4][k].selected = 1
                        }
                    } else if (keysPressed['5'] || keysPressed['%']) {
                        for (let k = 0; k < this.buildings.length; k++) {
                            if (!keysPressed['Shift']) {
                                this.buildings[k].selected = 0
                            }
                        }
                        for (let k = 0; k < this.controlGroups[5].length; k++) {
                            this.controlGroups[5][k].selected = 1
                        }
                    } else if (keysPressed['6'] || keysPressed['^']) {
                        for (let k = 0; k < this.buildings.length; k++) {
                            if (!keysPressed['Shift']) {
                                this.buildings[k].selected = 0
                            }
                        }
                        for (let k = 0; k < this.controlGroups[6].length; k++) {
                            this.controlGroups[6][k].selected = 1
                        }
                    } else if (keysPressed['7'] || keysPressed['&']) {
                        for (let k = 0; k < this.buildings.length; k++) {
                            if (!keysPressed['Shift']) {
                                this.buildings[k].selected = 0
                            }
                        }
                        for (let k = 0; k < this.controlGroups[7].length; k++) {
                            this.controlGroups[7][k].selected = 1
                        }
                    } else if (keysPressed['8'] || keysPressed['*']) {
                        for (let k = 0; k < this.buildings.length; k++) {
                            if (!keysPressed['Shift']) {
                                this.buildings[k].selected = 0
                            }
                        }
                        for (let k = 0; k < this.controlGroups[8].length; k++) {
                            this.controlGroups[8][k].selected = 1
                        }
                    } else if (keysPressed['9'] || keysPressed['(']) {
                        for (let k = 0; k < this.buildings.length; k++) {
                            if (!keysPressed['Shift']) {
                                this.buildings[k].selected = 0
                            }
                        }
                        for (let k = 0; k < this.controlGroups[9].length; k++) {
                            this.controlGroups[9][k].selected = 1
                        }
                    }
                }
                for (let t = 0; t < this.units.length; t++) {
                    if (keysPressed['0'] || keysPressed[')']) {
                        for (let k = 0; k < this.units.length; k++) {
                            if (!keysPressed['Shift']) {
                                this.units[k].selected = 0
                            }
                        }
                        for (let k = 0; k < this.controlGroups[0].length; k++) {
                            this.controlGroups[0][k].selected = 1
                        }
                    } else if (keysPressed['1'] || keysPressed['!']) {
                        for (let k = 0; k < this.units.length; k++) {
                            if (!keysPressed['Shift']) {
                                this.units[k].selected = 0
                            }
                        }
                        for (let k = 0; k < this.controlGroups[1].length; k++) {
                            this.controlGroups[1][k].selected = 1
                        }
                    } else if (keysPressed['2'] || keysPressed['@']) {
                        for (let k = 0; k < this.units.length; k++) {
                            if (!keysPressed['Shift']) {
                                this.units[k].selected = 0
                            }
                        }
                        for (let k = 0; k < this.controlGroups[2].length; k++) {
                            this.controlGroups[2][k].selected = 1
                        }
                    } else if (keysPressed['3'] || keysPressed['#']) {
                        for (let k = 0; k < this.units.length; k++) {
                            if (!keysPressed['Shift']) {
                                this.units[k].selected = 0
                            }
                        }
                        for (let k = 0; k < this.controlGroups[3].length; k++) {
                            this.controlGroups[3][k].selected = 1
                        }
                    } else if (keysPressed['4'] || keysPressed['$']) {
                        for (let k = 0; k < this.units.length; k++) {
                            if (!keysPressed['Shift']) {
                                this.units[k].selected = 0
                            }
                        }
                        for (let k = 0; k < this.controlGroups[4].length; k++) {
                            this.controlGroups[4][k].selected = 1
                        }
                    } else if (keysPressed['5'] || keysPressed['%']) {
                        for (let k = 0; k < this.units.length; k++) {
                            if (!keysPressed['Shift']) {
                                this.units[k].selected = 0
                            }
                        }
                        for (let k = 0; k < this.controlGroups[5].length; k++) {
                            this.controlGroups[5][k].selected = 1
                        }
                    } else if (keysPressed['6'] || keysPressed['^']) {
                        for (let k = 0; k < this.units.length; k++) {
                            if (!keysPressed['Shift']) {
                                this.units[k].selected = 0
                            }
                        }
                        for (let k = 0; k < this.controlGroups[6].length; k++) {
                            this.controlGroups[6][k].selected = 1
                        }
                    } else if (keysPressed['7'] || keysPressed['&']) {
                        for (let k = 0; k < this.units.length; k++) {
                            if (!keysPressed['Shift']) {
                                this.units[k].selected = 0
                            }
                        }
                        for (let k = 0; k < this.controlGroups[7].length; k++) {
                            this.controlGroups[7][k].selected = 1
                        }
                    } else if (keysPressed['8'] || keysPressed['*']) {
                        for (let k = 0; k < this.units.length; k++) {
                            if (!keysPressed['Shift']) {
                                this.units[k].selected = 0
                            }
                        }
                        for (let k = 0; k < this.controlGroups[8].length; k++) {
                            this.controlGroups[8][k].selected = 1
                        }
                    } else if (keysPressed['9'] || keysPressed['(']) {
                        for (let k = 0; k < this.units.length; k++) {
                            if (!keysPressed['Shift']) {
                                this.units[k].selected = 0
                            }
                        }
                        for (let k = 0; k < this.controlGroups[9].length; k++) {
                            this.controlGroups[9][k].selected = 1
                        }
                    }
                }
            }
        }
        draw() {
            // this.playerUI.display()


                for(let t = 0;t<this.enemyBullets.length;t++){
                // ////////console.log(this.enemyBullets[t])
                    this.enemyBullets[t].x = ((this.enemyBullets[t].startx*(this.enemyBullets[t].life/8)) + (this.enemyBullets[t].chase.body.x*((8-this.enemyBullets[t].life)/8)))
                    this.enemyBullets[t].y = ((this.enemyBullets[t].starty*(this.enemyBullets[t].life/8)) + (this.enemyBullets[t].chase.body.y*((8-this.enemyBullets[t].life)/8)))
                    this.enemyBullets[t].draw()
                    this.enemyBullets[t].life--
                    if(this.enemyBullets[t].life <= 0){
                        this.enemyBullets[t].marked = 1
                    }
                }
                for(let t = 0;t<this.enemyBullets.length;t++){
                    if(this.enemyBullets[t].marked == 1){
                        this.enemyBullets.splice(t,1)
                    }
                }

            this.collectiveStrain -= 1
            //////////console.log(this.collectiveStrain)
            let countsle = 0
            for (let t = 0; t < this.buildings.length; t++) {
                if (this.buildings[t].selected == 1 || this.buildings[t].selected == 2) {
                    countsle++
                }
            }
            for (let t = 0; t < this.units.length; t++) {
                if (this.units[t].selected == 1 || this.units[t].selected == 2) {
                    countsle++
                }
            }


            for (let t = 0; t < this.buildings.length; t++) {
                this.buildings[t].clean()
            }
            for (let t = 0; t < this.buildings.length; t++) {
                this.buildings[t].runSelf()
            }


            this.groupControl()


            for (let t = 0; t < this.controlGroups.length; t++) {
                for (let k = 0; k < this.controlGroups[t].length; k++) {
                    if (this.controlGroups[t][k].marked == 1) {
                        this.controlGroups[t].splice(k, 1)
                    }
                }
            }
        }


        unitdraw() {
            for (let t = 0; t < this.units.length; t++) {
                this.units[t].checkRangeConsistent()
            }
            let now = Date.now()
            globalAItimeFlag = now
            for (let t = 0; t < this.units.length; t++) {
                if (Date.now() - now > 12 && this.isAI == 1) {//timelimit
                    //////////console.log("time")
                    break
                } else {
                    this.units[t].coordinatemove(Date.now() - now)
                }
            }
            for (let t = 0; t < this.units.length; t++) {
                this.units[t].incrementMove()
            }



            for (let t = 0; t < this.units.length; t++) {
                this.units[t].move()
            }
            for (let t = 0; t < this.units.length; t++) {
                if(this.units[t].bee == 1){
                    this.units[t].body.draw()
                }
            }
            for (let t = 0; t < this.units.length; t++) {
                this.units[t].draw()
            }
        }

        fogdraw() {
            // this.context.clearRect(0,0,worldscale,worldscale)
            if (this.inned == 0) {
                this.init()
            }

            this.context.imageSmoothingEnabled = false;
            this.context2.imageSmoothingEnabled = false;
            this.contextx.imageSmoothingEnabled = false;

            if (this.tick % 5 == 0) {
                this.context.drawImage(this.canvas2, 0, 0);
                // if(this.tick%10== 0){
                this.context.globalAlpha = .0625;
                this.context.drawImage(fogblock, 0, 0, 128, 128, 0, 0, worldscale, worldscale)
                this.context.globalAlpha = 1;
                // }
                this.context2.globalAlpha = .02;
                this.context2.drawImage(this.canvas, 0, 0, worldscale, worldscale, 0, 0, worldscale, worldscale);
            }
            this.context.imageSmoothingEnabled = false;
            this.context2.imageSmoothingEnabled = false;
            this.contextx.imageSmoothingEnabled = false;
            // this.context2.clearRect(0,0,worldscale,worldscale);
            for (let t = 0; t < this.units.length; t++) {
                // //////////console.log((this.units[t].tile.x*.1)-(this.units[t].sight*1),(this.units[t].tile.y*.1)-(this.units[t].sight*1), (this.units[t].tile.x*.1)+(this.units[t].sight*1),(this.units[t].tile.y*.1)+(this.units[t].sight*1) )
                this.context.clearRect((this.units[t].tile.x * .1) - (this.units[t].sight * 1), (this.units[t].tile.y * .1) - (this.units[t].sight * 1), ((this.units[t].sight * 2) + 1), ((this.units[t].sight * 2) + 1))
                this.contextx.clearRect((this.units[t].tile.x * .1) - (this.units[t].sight * 1), (this.units[t].tile.y * .1) - (this.units[t].sight * 1), ((this.units[t].sight * 2) + 1), ((this.units[t].sight * 2) + 1))
            }
            for (let t = 0; t < this.buildings.length; t++) {
                if (this.buildings[t].sight > 0) {
                    this.context.clearRect((this.buildings[t].tile.x * .1) - (this.buildings[t].sight * 1), (this.buildings[t].tile.y * .1) - (this.buildings[t].sight * 1), ((this.buildings[t].sight * 2) + 1), ((this.buildings[t].sight * 2) + 1))
                    this.contextx.clearRect((this.buildings[t].tile.x * .1) - (this.buildings[t].sight * 1), (this.buildings[t].tile.y * .1) - (this.buildings[t].sight * 1), ((this.buildings[t].sight * 2) + 1), ((this.buildings[t].sight * 2) + 1))

                }
                for (let k = 0; k < this.buildings[t].tiles.length; k++) {
                    this.context.clearRect((this.buildings[t].tiles[k].x * .1) - (1 * 0), (this.buildings[t].tiles[k].y * .1) - (1 * 0), ((1 * 1) + 0), ((1 * 1) + 0))
                    this.contextx.clearRect((this.buildings[t].tiles[k].x * .1) - (1 * 0), (this.buildings[t].tiles[k].y * .1) - (1 * 0), ((1 * 1) + 0), ((1 * 1) + 0))

                }



                // //////////console.log((this.units[t].tile.x*.1)-(this.units[t].sight*1),(this.units[t].tile.y*.1)-(this.units[t].sight*1), (this.units[t].tile.x*.1)+(this.units[t].sight*1),(this.units[t].tile.y*.1)+(this.units[t].sight*1) )
            }

            this.tick++
        }
        uiDraw() {

            for (let t = 0; t < this.units.length; t++) {

                //         if(this.units[t].boombuddy == 1 && this.units[t].selected == 1){
                //     if(keysPressed["p"]){
                //         this.units[t].marked = 1
                //     }
                // }


                if (this.units[t].marked == 1) {

                    this.units[t].dying++
                    // if(this.units[t].boombuddy == 1){

                    //     // if (this.hotrock >= 5) {
                    //         // this.hotrock -= 5
                    //         for(let r = Math.floor(this.units[t].tile.x/10)-4;r<Math.floor(this.units[t].tile.x/10)+5 && r>0 && r<worldscale;r++){
                    //             for(let k = Math.floor(this.units[t].tile.y/10)-4;k<Math.floor(this.units[t].tile.y/10)+5&& k>0 && k<worldscale;k++){

                    //                 const building = new Building(sandmap.blocks[r][k], this.units[t].faction, 0)
                    //                 building.name = "Slime"
                    //                 building.defense = 0
                    //                 building.damage = 0
                    //                 building.tile.spiretile = 1
                    //                 building.tile.walkable = true
                    //                 building.tile.slime = true
                    //                 this.units[t].faction.slimeflag = 1
                    //                 building.slime = 1
                    //                 building.health = 5
                    //                 building.maxhealth = building.health
                    //                 building.pather = slimyastar
                    //                 building.active = 0
                    //                 building.tile.primed = 0
                    //                 building.pather.agent = building
                    //                 for (let  g = 0; g < this.units[t].faction.buildings.length; g++) {
                    //                     if (this.units[t].faction.buildings[g].sporeball == 1) {
                    //                         sandmap.diagonal = false
                    //                         const path = [...building.pather.search(sandmap, building.tile, this.units[t].faction.buildings[g].tile, {})]
                    //                         sandmap.diagonal = true
                    //                         //////////console.log(path)
                    //                         if (path.length > 0) {
                    //                             building.active = 1
                    //                             building.tile.primed = 1
                    //                             break
                    //                         }
                    //                     }
                    //                 }
                    //             }
                    //         }
                    //     // }
                    //     }
                    if (this.units[t].dying == 1) {
                        if (sandmap.players[sandmap.turn] == this) {
                            playDeathSound(this.units[t])
                        }
                    }

                    if (this.units[t].dying >= 14) {
                        this.units[t].tile.walkable = true
                        this.units[t].tile.occupied = false
                        this.units[t].tile.occupant = {}
                        this.units[t].tile.occupant.moving = false
                        this.units[t].tile.occupant.faction = {}
                        this.units[t].tile.occupant.faction.id = -1
                        this.units.splice(t, 1)
                    }
                }
            }
            // for (let t = 0; t < this.units.length; t++) {
            //     if (this.units[t].moved == 1) { //this.units[t].seetime % 40 ||
            //         this.units[t].moved = 0
            //         this.units[t].see()
            //     }
            //     this.units[t].seetime++
            // }
            if (sandmap.players[sandmap.turn] == this) {
                canvas_context.fillStyle = "black"
                canvas_context.strokeStyle = sandmap.players[sandmap.turn].color
                canvas_context.lineWidth = 1.5
                canvas_context.font = "17px arial"
                // canvas_context.strokeText("Hotrock: " + Math.round(this.hotrock), sandmap.window.body.x + sandmap.window.body.width + 10, 315)
                canvas_context.fillText("Units: " + Math.round(this.units.length) + ", " + "Hotrock: " + Math.round(this.hotrock), sandmap.window.body.x + sandmap.window.body.width + 10, 328)
                // canvas_context.strokeText("Units: " + Math.round(this.units.length), sandmap.window.body.x + sandmap.window.body.width + 10, 290)
                // canvas_context.fillText("Units: " + Math.round(this.units.length), sandmap.window.body.x + sandmap.window.body.width + 10, 290)
            }


        }
    }


    var gCanvas = document.getElementById("gCanvas");
    var gCanvasOffset;
    var gctx = gCanvas.getContext("2d");
    var CANVAS_WIDTH = worldscale * 10;
    var CANVAS_HEIGHT = worldscale * 10;
    var NODESIZE = 10;


    var path;

    var openSet = new Set();
    var closedSet = new Set();
    var gridPointsByPos = [];
    var gridPoints = [];

    var wallSet = new Set;

    //used to store the start and endPoint during resets, etc. 
    var startPoint;
    var endPoint;
    const mode = "endPoint"

    //any point in 2D space
    class Vec2 {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
    }

    class RedX {
        constructor(x, y) {
            const angle = Math.PI / 4
            this.point1 = new Point(x + (Math.cos(angle) * 10), y + (Math.sin(angle) * 10))
            this.point2 = new Point(x + (Math.cos(angle) * -10), y + (Math.sin(angle) * -10))
            this.point3 = new Point(x + (Math.cos(angle + Math.PI * .5) * 10), y + (Math.sin(angle + Math.PI * .5) * 10))
            this.point4 = new Point(x + (Math.cos(angle + Math.PI * .5) * -10), y + (Math.sin(angle + Math.PI * .5) * -10))

            this.link1 = new LineOP(this.point1, this.point2, "red", 3)
            this.link2 = new LineOP(this.point3, this.point4, "red", 3)
        }
        draw() {
            this.link1.draw()
            this.link2.draw()
            //////////console.log(this)
        }
    }


    gCanvasOffset = new Vec2(gCanvas.offsetLeft, gCanvas.offsetTop);


    // startPoint = new Vec2(bottle.crew[bottle.selectedcrew].body.x, bottle.crew[bottle.selectedcrew].body.y);
    endPoint = new Vec2(640, 640);

    class PathFindingAlg {
        constructor(grid, startNode, endNode, agent = {}) {
            this.agent = agent
            this.grid = grid;
            const gridarray = Array.from(grid)
            // for(let t = 0; t<gridarray.length; t++){
            //     for(let k = 0; k<gridarray[t].length; k++){

            //     }
            // }
            gridPointsByPos = [...this.grid]
            // this.startNode = gridPointsByPos[startNode.x][startNode.y];
            const roundedx = (Math.round((startNode.x))) * .1
            const roundedy = (Math.round((startNode.y))) * .1
            //////////console.log(gridPointsByPos, roundedx, roundedy)
            //////////console.log(gridPointsByPos[roundedx] [roundedy])
            this.startNode = startNode // gridPointsByPos[roundedx] [roundedy]
            this.endNode = endNode //gridPointsByPos[endNode.x][endNode.y];
            this.currentNode = null;

            this.openSet = [];
            this.closedset = [];
            this.breaker = 0
        }
        findPath() {
            // this.breaker++
            // if(this.breaker > 1){
            //     return
            // }
            openSet.clear();
            closedSet.clear();

            var grid = this.grid; //the grid we're working with

            var currentNode = this.startNode; // the currentNode, defaults to start node for now
            //////////console.log(this.endNode)
            var endNode = this.endNode //sandmap.gridPoints[this.endNode.id]; //the target node
            var startNode = this.startNode

            var tempArray;

            var newMovementCost; //the new movement cost to neighbor

            openSet.add(currentNode);
            //   //////////console.log(currentNode)
            // currentNode.color = "black"
            // //////////console.log('begin');

            let j = 0
            const timeout = 0
            while (openSet.size > 0) {
                j++
                if (j > 50000) {
                    timeout = 1
                }
                tempArray = Array.from(openSet);
                //////////console.log(tempArray)
                currentNode = tempArray[0];

                for (var i = 1; i < tempArray.length; i++) {
                    //this if statement is solely to build the starting walls.
                    if (tempArray[i].getValueF() < currentNode.getValueF() || tempArray[i].getValueF() == currentNode.getValueF() && tempArray[i].getValueH() < currentNode.getValueH()) {
                        currentNode = tempArray[i]; //sets the currentNode to openSetI if it has a lower F value, or an = F value with a lower HCost.
                        if (currentNode.walkable == false) {
                            j += 100
                        }
                    }
                }

                //exits for loop with either lowest F value or combined H value and F value

                openSet.delete(currentNode);

                // currentNode.drawClosedNode();

                closedSet.add(currentNode);

                //might need to put this after getNighbors.... then replace closedSet.hasIn(neighborNode with currentNode
                // if (currentNode.id == startNode.id) {
                //   currentNode.drawNode();
                // }
                // if (currentNode.id == endNode.id) {
                //   currentNode.drawNode();
                // }
                // if (currentNode.walkable == false) {
                //   currentNode.drawNode();
                // }

                //////////console.log(currentNode, endNode)
                // currentNode.color = "black"
                //////////console.log(currentNode, endNode)
                if (currentNode.id == endNode.id) {
                    //////////console.log(startNode, endNode)
                    retracePath(startNode, endNode, this.agent);
                    //hit the last point, exit's the loop.

                    return; //exits loop
                } else if (timeout == 1) {

                    //////////console.log(startNode, endNode)
                    retracePath(startNode, currentNode, this.agent);
                    //hit the last point, exit's the loop.

                    return; //exits loop
                }
                getNeighbors(currentNode, this.agent).forEach(function (neighbor) {

                    var neighborNode = neighbor;
                    var neighborH = neighborNode.getHCost();
                    var neighborG = neighborNode.getGCost();

                    var currentG = currentNode.getGCost();
                    var currentH = currentNode.getHCost();
                    if (neighborNode.occupied == true || ((!neighborNode.walkable && neighbor.agent.submerged !== 1) && (!neighborNode.walkable && (neighbor.agent.mounted !== 0))) || closedSet.has(neighborNode)) {

                        return; //acts as a continue, no need to continue if the wall was already checked.

                    }

                    newMovementCost = currentG + (getDistance(currentNode, neighborNode));

                    if (newMovementCost < neighborG || !openSet.has(neighborNode)) {

                        neighborNode.gCost = newMovementCost;
                        neighborNode.hCost = neighborH;
                        neighborNode.parent = currentNode;

                        if (!openSet.has(neighborNode)) {
                            //push the neighborNode to the openSet, to check against other open values
                            openSet.add(neighborNode);

                            // neighborNode.drawOpenNode();

                        }
                    }

                })
            }

        }

    }
    //distance from a node to  another node
    function getDistance(nodeA, nodeB) {
        // return distancetable[`${nodeA.x},${nodeB.y},${nodeA.x},${nodeB.y}`]
        var distX = Math.abs(nodeA.x - nodeB.x);
        var distY = Math.abs(nodeA.y - nodeB.y);

        if (distX > distY) {
            return ((1.4 * distY) + ((distX - distY)))

        }
        return (1.4 * distX + ((distY - distX)));
    }

    function retracePath(startNode, endNode, agent = {}) {
        path = new Set();
        var currentNode = endNode;
        var reverseArray;
        let j = 0
        while (currentNode != startNode) {
            j++
            if (j > 129 * 129) {
                break
            }
            path.add(currentNode);
            //////////console.log(currentNode)
            currentNode = currentNode.parent;
            //////////console.log(currentNode)
            // currentNode.inPath = true;
            // if (currentNode != startNode)
            //     currentNode.drawPath();
        }

        reverseArray = Array.from(path);

        reverseArray.reverse();
        path = new Set(reverseArray);

        //   //////////console.log(path)

        realPath = Array.from(path)
        //   //////////console.log(realPath)

        if (realPath.length == 1) {
            // realPath[0].walkable = false
            //////////console.log("hit")
            // wallSet.add(realPath[0])
            //////////console.log(wallSet)
        }

        //////////console.log(realPath)
        if (realPath.length > 0) {
            realPath.unshift(agent.tile)
            agent.realPath = [...realPath]
            //   for(let t = 0;t<realPath.length;t++){
            //       realPath[t].color = "black"
            //   }
            // bottle.crew[bottle.selectedcrew].body.x =realPath[0].posx+105
            // bottle.crew[bottle.selectedcrew].body.y  = realPath[0].posy+285

            // startPoint = new Vec2(bottle.crew[bottle.selectedcrew].body.x, bottle.crew[bottle.selectedcrew].body.y);
            // startPoint = new Vec2(realPath[0].posx+100, realPath[0].posy+280);
            // bottle.crew[bottle.selectedcrew].body.x =startPoint.x+4
            // bottle.crew[bottle.selectedcrew].body.y  = startPoint.y+4
            // startPoint = new Vec2(realPath[0].posx, realPath[0].posy);
            //////////console.log(startPoint)
            // bottle.crew[bottle.selectedcrew].moving = 1
        } else {
            //   //////////console.log(endPoint)

            //     if(bottle.crew[bottle.selectedcrew].moving == 1){
            //         // //////////console.log(endPoint)
            //     // bottle.crew[bottle.selectedcrew].body.x =endPoint.x+96
            //     // bottle.crew[bottle.selectedcrew].body.y  = endPoint.y+284
            //     // bottle.crew[bottle.selectedcrew].moving = 0
            //     // //////////console.log(endPoint)
            //         reset()
            //   }
        }
    }
    //list of neighbors
    function getNeighbors(node, agent, parent) {
        // //////////console.log(agent)
        var checkX;
        var checkY;
        var neighborList = [];
        var tempList = [];
        //   for (var x = -NODESIZE; x <= NODESIZE; x += NODESIZE) {
        //     for (var y = -NODESIZE; y <= NODESIZE; y += NODESIZE) {
        //       if (x == 0 && y == 0) {
        //         continue;
        //       }
        //       checkX = node.posx + x;
        //       checkY = node.posy + y;

        //       if (checkX >= 0 && checkX <= CANVAS_WIDTH - NODESIZE && checkY >= 0 && checkY <= CANVAS_HEIGHT - NODESIZE) {

        //         if(x == 0 || y == 0){

        //             if(checkX<=gridPointsByPos.length ){
        //                 if(checkY<=gridPointsByPos[checkX].length ){
        //                     if(sandmap.gridPoints[gridPointsByPos[checkX][checkY].id].walkable !== false){
        //                         tempList.push(gridPointsByPos[checkX][checkY]);
        //                     }

        //             }
        //         }
        //         }
        //       }
        //     }
        //   }


        for (var x = -1; x <= 1; x += 1) {
            for (var y = -1; y <= 1; y += 1) {
                if (x == 0 && y == 0) {
                    continue;
                }
                checkX = node.t + x;
                checkY = node.k + y;

                if (checkX >= 0 && checkX <= sandmap.blocks.length && checkY >= 0 && checkY <= sandmap.blocks.length) { //(worldscale-1) mapsize

                    if (x == 0 || y == 0 || Math.random() < .525) {  // randomness leads to organic //.25
                        //////////console.log(sandmap)
                        if (checkX < sandmap.blocks.length) {
                            if (checkY < sandmap.blocks[0].length) {
                                if ((sandmap.blocks[checkX][checkY].walkable !== false || agent.submerged == 1 || agent.mounted == 0) || sandmap.blocks[checkX][checkY].occupied == false) { //occupied? false?
                                    sandmap.blocks[checkX][checkY].agent = agent
                                    tempList.push(sandmap.blocks[checkX][checkY]);
                                }

                            }
                        }
                    }
                }
            }
        }


        neighborList = tempList;
        neighborList.agent = agent
        //////////console.log(neighborList)
        return (neighborList);

    }



    //UI, buttons, and click events/functions

    //tells canvas to how to draw the node
    function nodeDrawer(context, target, lineW, strokeS, fillS) {
        //   context.beginPath();
        //   context.lineWidth = lineW;
        //   context.strokeStyle = strokeS;
        //   context.fillStyle = fillS;
        //   context.fillRect(target.posx, target.posy, target.size, target.size);
        //   context.rect(target.posx, target.posy, target.size, target.size);
        //   context.closePath();
        //   context.stroke();
    }
    //clears the path WITHOUT clearing the walls
    function reset() {
        gridPoints = []; // resets the gridPoints so that it clears the walls etc. on reset.
        gridPointsByPos = [];
        openSet.clear();
        closedSet.clear();
        //gctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
        grid.createGrid();

    }
    //resets everything INCLUDING walls
    function resetWalls() {

        wallSet.clear();
        reset();
    }

    class Textpaint {
        constructor() {
            this.speakers = []
            this.colors = []
            this.text = []
            this.opacity = 1
        }
        push(speaker, color, text) {
            this.speakers.push(speaker)
            this.colors.push(color)
            this.text.push(text)
            this.opacity = 1
        }
        clear() {
            this.colors = []
            this.text = []
            this.speakers = []
            this.opacity = 1
        }

        measure(k) {
            const invscale = 1
            this.ypointer = 600 - ((this.text.length - k) * 40)
            this.xpointer = 200
            const lock = {}
            lock.x = this.xpointer - 10
            lock.y = this.ypointer
            canvas_context.font = "22px arial"
            // canvas_context.font = "50px Arial";
            // canvas_context.fillStyle = "#FFFFFF"
            const stoarr = this.text[k].split(' ')
            let stostring = ''
            for (let t = 0; t < stoarr.length; t++) {
                const width = canvas_context.measureText(stostring + ' ' + stoarr[t]).width
                if (width > canvas.width * invscale * .5) {
                    // canvas_context.fillText(stostring + ' ' + stoarr[t], this.xpointer, this.ypointer)

                    // canvas_context.fillStyle = "#090909"
                    // canvas_context.fillRect(70, 590, 750, 40)
                    canvas_context.strokeStyle = "#090909"
                    canvas_context.lineWidth = 3
                    canvas_context.font = "22px arial"
                    // if(t == 0){
                    canvas_context.strokeText(this.speakers[k], this.xpointer - 195, this.ypointer)
                    // }
                    canvas_context.fillStyle = this.colors[k]
                    canvas_context.font = "22px arial"
                    canvas_context.strokeStyle = "#090909"
                    canvas_context.lineWidth = 3
                    canvas_context.font = "22px arial"
                    // if(t == 0){
                    canvas_context.fillText(this.speakers[k], this.xpointer - 195, this.ypointer)
                    // }
                    canvas_context.strokeText(stostring + ' ' + stoarr[t], this.xpointer, this.ypointer)
                    canvas_context.fillStyle = "#FFFFAA"
                    canvas_context.font = "22px arial"
                    canvas_context.fillText(stostring + ' ' + stoarr[t], this.xpointer, this.ypointer)


                    this.ypointer += 40
                    stostring = ''
                } else {
                    stostring = stostring + " " + stoarr[t]
                    if (t == stoarr.length - 1) {


                        canvas_context.strokeStyle = "#090909"
                        canvas_context.lineWidth = 3
                        canvas_context.font = "22px arial"
                        canvas_context.strokeText(this.speakers[k], this.xpointer - 195, this.ypointer)
                        canvas_context.fillStyle = this.colors[k]
                        canvas_context.font = "22px arial"
                        canvas_context.strokeStyle = "#090909"
                        canvas_context.lineWidth = 3
                        canvas_context.font = "22px arial"
                        canvas_context.fillText(this.speakers[k], this.xpointer - 195, this.ypointer)
                        canvas_context.strokeStyle = "#090909"
                        canvas_context.lineWidth = 3
                        canvas_context.font = "22px arial"
                        canvas_context.strokeText(stostring, this.xpointer, this.ypointer)
                        canvas_context.fillStyle = "#FFFFAA"
                        canvas_context.font = "22px arial"
                        canvas_context.fillText(stostring, this.xpointer, this.ypointer)
                        // canvas_context.fillText(stostring, this.xpointer, this.ypointer)

                        // canvas_context.fillStyle = "#090909"
                        // canvas_context.fillRect(lock.x, lock.y, 650, this.ypointer-lock.y)

                    }
                }
            }
            // //////////console.log(this)
        }

        draw() {
            this.opacity *= .9973
            if (this.opacity < .3) {

            } else {
                canvas_context.globalAlpha = this.opacity
                for (let t = 0; t < this.text.length; t++) {
                    this.measure(t)

                    // canvas_context.fillStyle = "#090909"
                    // canvas_context.fillRect(70, 590, 750, 40)
                    // canvas_context.fillStyle = this.colors[t]
                    // canvas_context.font = "22px arial"
                    // canvas_context.fillText(this.speakers[t], 80, (600-(this.text.length*40))+(t*42), 100)
                    // canvas_context.strokeStyle = "#090909"
                    // canvas_context.lineWidth = 3
                    // canvas_context.font = "22px arial"
                    // canvas_context.strokeText(this.text[t], 200, (600-(this.text.length*40))+(t*42), 600)
                    // canvas_context.fillStyle = "#FFFFAA"
                    // canvas_context.font = "22px arial"
                    // canvas_context.fillText(this.text[t], 200, (600-(this.text.length*40))+(t*42), 600)
                }
            }
            canvas_context.globalAlpha = 1
        }
    }

    const textpainter = new Textpaint()

    class Campaign {
        constructor() {
            this.on = 0
            this.levelset = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
            this.metanames = ["The March Of Su'ser'sana", "Commander Park's Longest Hour", "Fragmentation And Accretion", "Blossoms Amongst The Frost", "Spread"]
            this.names = [["Coalescent Chaos", "Bolster And Burgeon", "Pilfer And Protect", "Whiteout", "Real Retaliation"], ["I've Got An Hour", "I Don't Understand", "The Middle 2/3rds", "Wealth, Status, Power", "Timber"], ["Ostwald Ripening", "Amorphous Allotropy", "Long-Range Order", "Diffraction", "Polymorphism"], ["Seeds Of Destruction", "Shake It All Sprout", "Secondary Growth", "Sap On The Snow", "Cower: Flower Power"], ["What's The Splatter", "Slime Highway", "Pay For This Slime", "Gooing Too Far", "Sporangium"]]
            this.buttons = []

            this.colorsx = [["#888888", "#FFAA00"], ["#AA8888", "#ec2c08"], ["#444477", "#AA0000"], ["#225522", "#FF00AA"], ["#661177", "#AAFF00"]]


            this.mission = -1

            this.colors = [["#555555", "#FFAA00"], ["#393939", "#bc2c08"], ["#000066", "#aa5555"], ["#006600", "#dd5555"], ["#8800BB", "#aaff00"]]
            for (let t = 0; t < 5; t++) {
                for (let k = 0; k < 5; k++) {
                    const button = new UiRectangle(40 + (t * 250), 60 + (k * 120), 210, 50, this.colors[t][0])
                    button.tcol = this.colors[t][1]
                    this.buttons.push(button)
                }
            }
            this.starter = new UiRectangle(870, 620, 200, 75, "#333333")
        }
        puppet() {
            if (this.mission == 7 && sandmap.players[0].units.length > 0) {
                if (sandmap.players[1].units.length < 20) {
                    let block = sandmap.blocks[Math.floor(Math.random() * worldscale)][Math.floor(Math.random() * worldscale)]
                    let fj = 0
                    while (sandmap.players[0].blocks[block.t][block.k].markdraw == 1 || sandmap.players[0].blocks[block.t][block.k].ice == 1 || sandmap.players[0].blocks[block.t][block.k].occupied == true) {
                        fj++
                        if (fj > 1000) {
                            break
                        }
                        block = sandmap.blocks[Math.floor(Math.random() * worldscale)][Math.floor(Math.random() * worldscale)]
                    }
                    if (block.ice != 1 && block.pit != 1) {
                        let agentBuddy = new Agent(block, sandmap.players[1])
                        if (Math.random() < .1) {
                            agentBuddy.isFruitingBuddy()
                        } else {
                            if (Math.random() < .1) {
                                agentBuddy.isSporeseer()
                            } else {
                                if (Math.random() < .1) {
                                    agentBuddy.isSporevizir()
                                } else {
                                    agentBuddy.isMycoknight()
                                }
                            }
                        }
                        agentBuddy.health *= .1
                        agentBuddy.damage *= 1.5
                        agentBuddy.firerate *= 2
                        agentBuddy.attackrange *= 2
                        agentBuddy.movespeed = Math.ceil(agentBuddy.movespeed * .5)
                        agentBuddy.ultrabreak = (sandmap.players[0].units[0].tile)

                        let gj = 0
                        while (agentBuddy.ultrabreak.walkable == false && (agentBuddy.submerged != 1 && agentBuddy.mounted != 0)) {
                            if (gj > 100) {
                                break
                            }
                            agentBuddy.ultrabreak = sandmap.blocks[Math.min(Math.max(agentBuddy.ultrabreak.t - (Math.sign(Math.random() - .5)), 0), worldscale - 1)][Math.min(Math.max(agentBuddy.ultrabreak.k - (Math.sign(Math.random() - .5)), 0), worldscale - 1)]
                        }
                        agentBuddy.ultrawalk = 0
                        agentBuddy.start = block
                    }
                }
                if (!(this.missionClock > 0)) {
                    this.missionClock = 0
                }
                this.missionClock++
                if (this.missionClock % 100 == 0) {
                    for (let t = 0; t < sandmap.players[1].units.length; t++) {

                        sandmap.players[1].units[t].ultrabreak = (sandmap.players[0].units[0].tile)

                        let gj = 0
                        while (sandmap.players[1].units[t].ultrabreak.walkable == false && (sandmap.players[1].units[t].submerged != 1 && sandmap.players[1].units[t].mounted != 0)) {
                            if (gj > 100) {
                                break
                            }
                            sandmap.players[1].units[t].ultrabreak = sandmap.blocks[Math.min(Math.max(sandmap.players[1].units[t].ultrabreak.t - (Math.sign(Math.random() - .5)), 0), worldscale - 1)][Math.min(Math.max(sandmap.players[1].units[t].ultrabreak.k - (Math.sign(Math.random() - .5)), 0), worldscale - 1)]
                        }
                        sandmap.players[1].units[t].ultrawalk = 0
                        sandmap.players[1].units[t].start = sandmap.players[1].units[t].tile
                    }
                }
            }
        }
        initialize() {
            this.on = 0
            this.levelset = [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
            this.metanames = ["The March Of Su'ser'sana", "Commander Park's Longest Hour", "Fragmentation And Accretion", "Blossoms Amongst The Frost", "Spread"]
            this.names = [["Coalescent Chaos", "Bolster And Burgeon", "Pilfer And Protect", "Whiteout", "Real Retaliation"], ["I've Got An Hour", "I Don't Understand", "The Middle 2/3rds", "Wealth, Status, Power", "Timber"], ["Ostwald Ripening", "Amorphous Allotropy", "Long-Range Order", "Diffraction", "Polymorphism"], ["Seeds Of Destruction", "Shake It All Sprout", "Secondary Growth", "Sap On The Snow", "Cower: Flower Power"], ["What's The Splatter", "Slime Highway", "Pay For This Slime", "Gooing Too Far", "Sporangium"]]
            this.buttons = []

            this.colorsx = [["#888888", "#FFAA00"], ["#AA8888", "#ec2c08"], ["#444477", "#AA0000"], ["#225522", "#FF00AA"], ["#661177", "#AAFF00"]]


            this.mission = -1

            this.colors = [["#555555", "#FFAA00"], ["#393939", "#bc2c08"], ["#000066", "#aa5555"], ["#006600", "#dd5555"], ["#8800BB", "#aaff00"]]
            for (let t = 0; t < 5; t++) {
                for (let k = 0; k < 5; k++) {
                    const button = new UiRectangle(40 + (t * 250), 60 + (k * 120), 210, 50, this.colors[t][0])
                    button.tcol = this.colors[t][1]
                    this.buttons.push(button)
                }
            }
            this.starter = new UiRectangle(870, 620, 200, 75, "#333333")
        }
        buildmapallfactions(map) {

            for (let t = 0; t < sandmap.blocks.length; t++) {
                for (let k = 0; k < sandmap.blocks[t].length; k++) {
                    if (map[`${t},${k}`] == 1) {
                        sandmap.blocks[t][k].ice = 1
                        sandmap.blocks[t][k].walkable = false
                        sandmap.blocks[t][k].color = "#AAFFFF"
                    } else if (map[`${t},${k}`] == 2) {
                        sandmap.blocks[t][k].sourcerock = 500
                        sandmap.blocks[t][k].hotrock = 2
                        sandmap.blocks[t][k].walkable = true
                        sandmap.blocks[t][k].color = "#AA8822"
                        sandmap.hotrocks.push(sandmap.blocks[t][k])
                        if (k > 65 && t > 65) {
                            const building = new Building(sandmap.blocks[t][k], sandmap.players[1], 0, 1)
                            building.name = "Slime"
                            building.defense = 0
                            building.damage = 0
                            building.tile.spiretile = 1
                            building.tile.walkable = true
                            building.tile.slime = true
                            // this.slimeflag = 1
                            building.slime = 1
                            building.health = 5
                            building.maxhealth = building.health
                            building.pather = slimyastar
                            building.active = 0
                            building.tile.primed = 0
                            building.pather.agent = building
                        }
                    } else if (map[`${t},${k}`] == 3) {

                        const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                        if (t < 65) {
                            if (k > 65) {
                                agent2.isPodman()
                                agent2.decayRate = 0
                            } else {
                                agent2.finishMorphgamergate()
                                agent2.decayRate = 0
                            }
                        } else {
                            if (k > 65) {
                                agent2.isSporevizir()
                                const building = new Building(sandmap.blocks[t][k], sandmap.players[1], 0, 1)
                                building.name = "Slime"
                                building.defense = 0
                                building.damage = 0
                                building.tile.spiretile = 1
                                building.tile.walkable = true
                                building.tile.slime = true
                                // this.slimeflag = 1
                                building.slime = 1
                                building.health = 5
                                building.maxhealth = building.health
                                building.pather = slimyastar
                                building.active = 0
                                building.tile.primed = 0
                                building.pather.agent = building
                            } else {
                                agent2.isHamartaninvader()
                            }
                        }
                    } else if (map[`${t},${k}`] == 4) {
                        const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                        if (t < 65) {
                            if (k > 65) {
                                agent2.isPufffellow()
                                agent2.decayRate = 0
                            } else {
                                agent2.finishMorph1()
                                agent2.decayRate = 0
                            }
                        } else {
                            if (k > 65) {
                                agent2.isSporeseer()
                                const building = new Building(sandmap.blocks[t][k], sandmap.players[1], 0, 1)
                                building.name = "Slime"
                                building.defense = 0
                                building.damage = 0
                                building.tile.spiretile = 1
                                building.tile.walkable = true
                                building.tile.slime = true
                                // this.slimeflag = 1
                                building.slime = 1
                                building.health = 5
                                building.maxhealth = building.health
                                building.pather = slimyastar
                                building.active = 0
                                building.tile.primed = 0
                                building.pather.agent = building
                            } else {
                                agent2.isHamartansoldier()
                            }
                        }

                    } else if (map[`${t},${k}`] == 5) {
                        const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                        if (t < 65) {
                            if (k > 65) {
                                agent2.isPollinator()
                                agent2.decayRate = 0
                            } else {
                                agent2.isNymph()
                                agent2.decayRate = 0
                            }
                        } else {
                            if (k > 65) {
                                agent2.isFruitingBuddy()
                                const building = new Building(sandmap.blocks[t][k], sandmap.players[1], 0, 1)
                                building.name = "Slime"
                                building.defense = 0
                                building.damage = 0
                                building.tile.spiretile = 1
                                building.tile.walkable = true
                                building.tile.slime = true
                                // this.slimeflag = 1
                                building.slime = 1
                                building.health = 5
                                building.maxhealth = building.health
                                building.pather = slimyastar
                                building.active = 0
                                building.tile.primed = 0
                                building.pather.agent = building
                            } else {
                                agent2.isHamartanscout()
                            }
                        }

                    } else if (map[`${t},${k}`] == 6) {
                        const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                        if (t < 65) {
                            if (k > 65) {
                                agent2.isGoliophyte()
                                agent2.decayRate = 0
                            } else {
                                agent2.finishMorph2()
                                agent2.decayRate = 0
                            }
                        } else {
                            if (k > 65) {
                                agent2.isMycoknight()
                                const building = new Building(sandmap.blocks[t][k], sandmap.players[1], 0, 1)
                                building.name = "Slime"
                                building.defense = 0
                                building.damage = 0
                                building.tile.spiretile = 1
                                building.tile.walkable = true
                                building.tile.slime = true
                                // this.slimeflag = 1
                                building.slime = 1
                                building.health = 5
                                building.maxhealth = building.health
                                building.pather = slimyastar
                                building.active = 0
                                building.tile.primed = 0
                                building.pather.agent = building
                            } else {
                                agent2.isHamartaninvader()
                            }
                        }

                    } else if (map[`${t},${k}`] == 7) {
                        // const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                        // agent2.isSniper()
                        // agent2.decayRate = 0

                        // const building = new Building(sandmap.blocks[t][k], sandmap.players[1], 0)
                        // building.defense = 3
                        // building.damage = 0
                    } else if (map[`${t},${k}`] == 8) {
                        // const building = new Building(sandmap.blocks[t][k], sandmap.players[1], 0)
                        // building.defense = 3
                        // building.damage = 0

                        // sandmap.blocks[t][k].walkable = false
                        // sandmap.blocks[t][k].occupied = true
                        // sandmap.blocks[t][k].pit = 1
                        // sandmap.blocks[t][k].color = "#000000"
                    } else if (map[`${t},${k}`] == 9) {
                        const building = new Building(sandmap.blocks[t][k], sandmap.players[1], 0, 1)
                        building.name = "Slime"
                        building.defense = 0
                        building.damage = 0
                        building.tile.spiretile = 1
                        building.tile.walkable = true
                        building.tile.slime = true
                        // this.slimeflag = 1
                        building.slime = 1
                        building.health = 5
                        building.maxhealth = building.health
                        building.pather = slimyastar
                        building.active = 0
                        building.tile.primed = 0
                        building.pather.agent = building

                    } else if (map[`${t},${k}`] == 10) {
                        // const building = new Building(sandmap.blocks[t][k], sandmap.players[1], 0)
                        // building.defense = 3
                        // building.damage = 0

                        sandmap.blocks[t][k].walkable = false
                        sandmap.blocks[t][k].occupied = true
                        sandmap.blocks[t][k].occupant = {}
                        sandmap.blocks[t][k].occupant.moving = false
                        sandmap.blocks[t][k].occupant.faction = {}
                        sandmap.blocks[t][k].occupant.faction.id = -1
                        sandmap.blocks[t][k].pit = 1
                        sandmap.blocks[t][k].color = "#000000"
                    } else {

                        // sandmap.blocks[t][k].walkable = false
                        // sandmap.blocks[t][k].occupied = true
                        // sandmap.blocks[t][k].pit = 1
                        // sandmap.blocks[t][k].color = "#000000"
                    }
                }
            }
        }
        buildmaplibrilbians(map) {

            for (let t = 0; t < sandmap.blocks.length; t++) {
                for (let k = 0; k < sandmap.blocks[t].length; k++) {
                    if (map[`${t},${k}`] == 1) {
                        sandmap.blocks[t][k].ice = 1
                        sandmap.blocks[t][k].walkable = false
                        sandmap.blocks[t][k].color = "#AAFFFF"
                    } else if (map[`${t},${k}`] == 2) {
                        sandmap.blocks[t][k].sourcerock = 500
                        sandmap.blocks[t][k].hotrock = 2
                        sandmap.blocks[t][k].walkable = true
                        sandmap.blocks[t][k].color = "#AA8822"
                        sandmap.hotrocks.push(sandmap.blocks[t][k])
                    } else if (map[`${t},${k}`] == 3) {
                        const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                        agent2.isPodman()
                        agent2.decayRate = 0
                    } else if (map[`${t},${k}`] == 4) {
                        const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                        agent2.isPufffellow()
                        agent2.decayRate = 0

                    } else if (map[`${t},${k}`] == 5) {
                        const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                        agent2.isPollinator()
                        agent2.decayRate = 0

                    } else if (map[`${t},${k}`] == 6) {
                        const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                        agent2.isGoliophyte()
                        agent2.decayRate = 0

                    } else if (map[`${t},${k}`] == 7) {
                        // const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                        // agent2.isSniper()
                        // agent2.decayRate = 0

                        // const building = new Building(sandmap.blocks[t][k], sandmap.players[1], 0)
                        // building.defense = 3
                        // building.damage = 0
                    } else if (map[`${t},${k}`] == 8) {
                        // const building = new Building(sandmap.blocks[t][k], sandmap.players[1], 0)
                        // building.defense = 3
                        // building.damage = 0

                        // sandmap.blocks[t][k].walkable = false
                        // sandmap.blocks[t][k].occupied = true
                        // sandmap.blocks[t][k].pit = 1
                        // sandmap.blocks[t][k].color = "#000000"
                    } else {

                        // sandmap.blocks[t][k].walkable = false
                        // sandmap.blocks[t][k].occupied = true
                        // sandmap.blocks[t][k].pit = 1
                        // sandmap.blocks[t][k].color = "#000000"
                    }
                }
            }
        }
        buildOutMap(map) {
            let step = 256 / worldscale

            for (let t = 0; t < sandmap.blocks.length; t++) {
                for (let k = 0; k < sandmap.blocks[t].length; k++) {
                    if (map[`${(Math.floor(t * step))},${Math.floor(k * step)}`] == 1) {
                        sandmap.blocks[t][k].ice = 1
                        sandmap.blocks[t][k].walkable = false
                        sandmap.blocks[t][k].color = "#AAFFFF"
                    } else {
                        sandmap.blocks[t][k].ice = 0
                        sandmap.blocks[t][k].walkable = true
                        sandmap.blocks[t][k].color = "#AAFFFF"
                    }

                    if (true) {
                    } else if (map[`${t},${k}`] == 2) {
                        // sandmap.blocks[t][k].sourcerock = 500
                        // sandmap.blocks[t][k].hotrock = 2
                        // sandmap.blocks[t][k].walkable = true
                        // sandmap.blocks[t][k].color = "#AA8822"
                        // sandmap.hotrocks.push(sandmap.blocks[t][k])
                    } else if (map[`${t},${k}`] == 3) {
                        // const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                        // agent2.isPodman()
                        // agent2.decayRate = 0
                    } else if (map[`${t},${k}`] == 4) {
                        // const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                        // agent2.isPufffellow()
                        // agent2.decayRate = 0

                    } else if (map[`${t},${k}`] == 5) {
                        // const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                        // agent2.isPollinator()
                        // agent2.decayRate = 0

                    } else if (map[`${t},${k}`] == 6) {
                        // const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                        // agent2.isGoliophyte()
                        // agent2.decayRate = 0

                    } else if (map[`${t},${k}`] == 7) {
                        // const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                        // agent2.isSniper()
                        // agent2.decayRate = 0

                        // const building = new Building(sandmap.blocks[t][k], sandmap.players[1], 0)
                        // building.defense = 3
                        // building.damage = 0
                    } else if (map[`${t},${k}`] == 8) {
                        // const building = new Building(sandmap.blocks[t][k], sandmap.players[1], 0)
                        // building.defense = 3
                        // building.damage = 0

                        // sandmap.blocks[t][k].walkable = false
                        // sandmap.blocks[t][k].occupied = true
                        // sandmap.blocks[t][k].pit = 1
                        // sandmap.blocks[t][k].color = "#000000"
                    } else {

                        // sandmap.blocks[t][k].walkable = false
                        // sandmap.blocks[t][k].occupied = true
                        // sandmap.blocks[t][k].pit = 1
                        // sandmap.blocks[t][k].color = "#000000"
                    }
                }
            }
        }
        check(point) {
            for (let t = 0; t < 8; t++) { //this.buttons.length
                if (this.buttons[t].isPointInside(point)) {
                    this.mission = t
                    sandmap.turn = 0
                    if (t == 0) {

                        sana1.play()
                        textpainter.clear()
                        textpainter.push("Mother's memory", "#DD8800", "Su'ser'sana, you must make your way through this causeway. Clear out any humans you find, and try to collect some hotrock to build an army.")
                        // textpainter.push("Mother's memory", "#DD8800", "")
                        sandmap.players[0].type = 1
                        sandmap.players[0].name = "Cold Itzlerians"
                        sandmap.players[0].color = "#dd8800"
                        sandmap.players[0].hotrock = 0
                        sandmap.players[0].units = []
                        sandmap.players[1].units = []
                        sandmap.players[1].type = 0
                        sandmap.players[1].clickrate = 1000
                        sandmap.players[1].attacktimeout = 10000000000
                        sandmap.players[1].color = "#440088"
                        sandmap.players[1].aimode = 2
                        sandmap.players[1].name = "Earthoids"
                        sandmap.players[0].units = []
                        sandmap.players[1].units = []
                        start = 0
                        for (let t = 0; t < 1; t++) {
                            const agent1 = new Agent(sandmap.blocks[5][t + 5], sandmap.players[0])
                            agent1.sana = 1
                            agent1.name = "Su'ser'sana"
                            agent1.seen1 = 0
                            agent1.body.color = "teal"
                            agent1.body.radius = 4
                            agent1.movespeed = 1
                            agent1.firerate = gargantuanNumber / 1 //3 make more viable in combat
                            agent1.decayRate = 0
                            agent1.damage = 19
                            // agent1.name = "Nymph"
                            agent1.nymph = 1
                            agent1.defense = 5
                            agent1.sight = 4 + agent1.movespeed
                            // this.firerate = gargantuanNumber/(this.movespeed * 5)
                            agent1.attackrange = agent1.sight
                            // this.health = this.sight * 100
                            agent1.maxhealth = agent1.health
                            agent1.shots = []
                            agent1.attacktarget = {}
                            agent1.attacktarget.tile = {}
                            agent1.attacktarget.health = 0
                            agent1.attackcounter = 0
                            agent1.health = 206
                            agent1.maxhealth = agent1.health
                        }
                        // for (let  t = 0; t < 3; t++) {
                        // }
                        playstart = 1
                        for (let t = 0; t < sandmap.blocks.length; t++) {
                            for (let k = 0; k < sandmap.blocks[t].length; k++) {

                                sandmap.blocks[t][k].sourcerock = 0
                                sandmap.blocks[t][k].hotrock = 0
                                sandmap.blocks[t][k].ice = 0
                                sandmap.blocks[t][k].walkable = true

                                if (colditzleriancampaign1[`${t},${k}`] == 1) {
                                    sandmap.blocks[t][k].ice = 1
                                    sandmap.blocks[t][k].walkable = false
                                    sandmap.blocks[t][k].color = "#AAFFFF"
                                } else if (colditzleriancampaign1[`${t},${k}`] == 2) {
                                    sandmap.blocks[t][k].sourcerock = 300
                                    sandmap.blocks[t][k].hotrock = 2
                                    sandmap.blocks[t][k].walkable = true
                                    sandmap.blocks[t][k].color = "#AA8822"

                                    sandmap.hotrocks.push(sandmap.blocks[t][k])
                                    if (sandmap.players[1].units.length < 5) {
                                        const agent2 = new Agent(sandmap.blocks[t - 2][k - 2], sandmap.players[1])
                                        agent2.isScout()
                                        agent2.decayRate = 0
                                        agent2.super = 1
                                        agent2.health *= 1.5
                                        agent2.maxhealth *= 1.5
                                        agent2.defense *= 1.5
                                        agent2.damage *= 1.5
                                        const agent3 = new Agent(sandmap.blocks[t - 3][k], sandmap.players[1])
                                        agent3.isInfantry()
                                        agent3.decayRate = 0

                                    } else if (sandmap.players[1].units.length < 11) {
                                        const agent2 = new Agent(sandmap.blocks[t - 2][k], sandmap.players[1])
                                        agent2.isInfantry()
                                        agent2.decayRate = 0
                                        agent2.super = 1
                                        agent2.health *= 1.2
                                        agent2.maxhealth *= 1.2
                                        agent2.defense *= 1.2
                                        agent2.damage *= 1.2

                                        const agent3 = new Agent(sandmap.blocks[t - 3][k], sandmap.players[1])
                                        agent3.isInfantry()
                                        agent3.decayRate = 0

                                    } else {

                                        const agent2 = new Agent(sandmap.blocks[t - 2][k], sandmap.players[1])
                                        agent2.isInfantry()
                                        agent2.decayRate = 0

                                        const agent3 = new Agent(sandmap.blocks[t - 3][k], sandmap.players[1])
                                        agent3.isInfantry()
                                        agent3.decayRate = 0
                                        const agent4 = new Agent(sandmap.blocks[t - 4][k], sandmap.players[1])
                                        agent4.isHarvester()
                                        agent4.decayRate = 0
                                        if (sandmap.players[1].units.length % 2 == 0) {
                                            agent4.super = 1
                                            agent4.health *= 1.2
                                            agent4.maxhealth *= 1.2
                                            agent4.defense *= 1.2
                                            agent4.damage *= 1.2
                                        }

                                    }
                                } else {
                                    // sandmap.blocks[t][k].walkable = false
                                    // sandmap.blocks[t][k].occupied = true
                                    // sandmap.blocks[t][k].pit = 1
                                    // sandmap.blocks[t][k].color = "#000000"
                                }
                            }
                        }
                        //////////console.log(sandmap)
                    } else if (t == 1) {

                        sana2.play()
                        textpainter.clear()
                        textpainter.push("Inner Voice", "#BB6600", "Produce a squadron of scuttlers and imago.")

                        sandmap.players[0].type = 1
                        sandmap.players[0].name = "Cold Itzlerians"
                        sandmap.players[0].color = "#dd8800"
                        sandmap.players[0].units = []
                        sandmap.players[1].units = []
                        sandmap.players[1].type = 0
                        sandmap.players[1].clickrate = 1000
                        sandmap.players[1].attacktimeout = 10000000000
                        sandmap.players[1].color = "#440088"
                        sandmap.players[1].aimode = 2
                        sandmap.players[1].name = "Earthoids"
                        sandmap.players[0].units = []
                        sandmap.players[1].units = []
                        start = 0
                        for (let t = 0; t < 1; t++) {
                            const agent1 = new Agent(sandmap.blocks[7][t + 7], sandmap.players[0])
                            agent1.sana = 1
                            agent1.name = "Su'ser'sana"
                            agent1.finishMorph2()
                        }
                        // for (let  t = 0; t < 3; t++) {
                        // }
                        playstart = 1
                        for (let t = 0; t < sandmap.blocks.length; t++) {
                            for (let k = 0; k < sandmap.blocks[t].length; k++) {

                                sandmap.blocks[t][k].sourcerock = 0
                                sandmap.blocks[t][k].hotrock = 0
                                sandmap.blocks[t][k].ice = 0
                                sandmap.blocks[t][k].walkable = true

                                if (colditzleriancampaign2[`${t},${k}`] == 1) {
                                    sandmap.blocks[t][k].ice = 1
                                    sandmap.blocks[t][k].walkable = false
                                    sandmap.blocks[t][k].color = "#AAFFFF"
                                    sandmap.hotrocks.push(sandmap.blocks[t][k])
                                } else if (colditzleriancampaign2[`${t},${k}`] == 2) {
                                    sandmap.blocks[t][k].sourcerock = 300
                                    sandmap.blocks[t][k].hotrock = 2
                                    sandmap.blocks[t][k].walkable = true
                                    sandmap.blocks[t][k].color = "#AA8822"
                                    sandmap.hotrocks.push(sandmap.blocks[t][k])
                                } else if (colditzleriancampaign2[`${t},${k}`] == 3) {
                                    const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                                    agent2.isHarvester()
                                    // if (sandmap.players[1].units.length%2 == 0) {
                                    agent2.super = 1
                                    agent2.health *= 1.5
                                    agent2.maxhealth *= 1.5
                                    agent2.defense *= 1.5
                                    agent2.damage *= 1.5
                                    // }
                                    agent2.decayRate = 0
                                } else if (colditzleriancampaign2[`${t},${k}`] == 4) {
                                    const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                                    agent2.isInfantry()
                                    if (sandmap.players[1].units.length % 2 == 0) {
                                        agent2.super = 1
                                        agent2.health *= 1.5
                                        agent2.maxhealth *= 1.5
                                        agent2.defense *= 1.5
                                        agent2.damage *= 1.5
                                    }
                                    agent2.decayRate = 0

                                } else if (colditzleriancampaign2[`${t},${k}`] == 5) {
                                    const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                                    agent2.isScout()
                                    agent2.decayRate = 0

                                }
                            }
                        }
                    } else if (t == 2) {


                        sana3.play()
                        textpainter.clear()
                        textpainter.push("Inner Voice", "#BB6600", "Destroy the human incursion! Hotrock belongs to the Itzlerians!")

                        sandmap.players[0].type = 1
                        sandmap.players[0].name = "Cold Itzlerians"
                        sandmap.players[0].color = "#dd8800"
                        sandmap.players[0].units = []
                        sandmap.players[0].hotrock = 400
                        sandmap.players[1].units = []
                        sandmap.players[1].type = 0
                        sandmap.players[1].clickrate = 1000
                        sandmap.players[1].attacktimeout = 10000000000
                        sandmap.players[1].color = "#440088"
                        sandmap.players[1].name = "Earthoids"
                        sandmap.players[1].hotrock = 400
                        sandmap.players[1].aimode = 2
                        sandmap.players[0].units = []
                        sandmap.players[1].units = []
                        start = 0
                        for (let t = 0; t < 1; t++) {
                            const agent1 = new Agent(sandmap.blocks[7][t + 7], sandmap.players[0])
                            agent1.sana = 1
                            agent1.name = "Su'ser'sana"
                            agent1.finishMorph2()
                        }
                        for (let t = 0; t < 2; t++) {
                            const agent1 = new Agent(sandmap.blocks[9][t + 9], sandmap.players[0])
                            agent1.isNymph()
                        }
                        // for (let  t = 0; t < 3; t++) {
                        // }
                        playstart = 1
                        for (let t = 0; t < sandmap.blocks.length; t++) {
                            for (let k = 0; k < sandmap.blocks[t].length; k++) {

                                sandmap.blocks[t][k].sourcerock = 0
                                sandmap.blocks[t][k].hotrock = 0
                                sandmap.blocks[t][k].ice = 0
                                sandmap.blocks[t][k].walkable = true

                                if (colditzleriancampaign3[`${t},${k}`] == 1) {
                                    sandmap.blocks[t][k].ice = 1
                                    sandmap.blocks[t][k].walkable = false
                                    sandmap.blocks[t][k].color = "#AAFFFF"
                                } else if (colditzleriancampaign3[`${t},${k}`] == 2) {
                                    sandmap.blocks[t][k].sourcerock = 300
                                    sandmap.blocks[t][k].hotrock = 2
                                    sandmap.blocks[t][k].walkable = true
                                    sandmap.blocks[t][k].color = "#AA8822"
                                    sandmap.hotrocks.push(sandmap.blocks[t][k])
                                } else if (colditzleriancampaign3[`${t},${k}`] == 3) {
                                    const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                                    agent2.isHarvester()
                                    agent2.super = 1
                                    agent2.health *= 1.8
                                    agent2.maxhealth *= 1.8
                                    agent2.defense *= 1.8
                                    agent2.damage *= 1.8
                                    agent2.decayRate = 0
                                } else if (colditzleriancampaign3[`${t},${k}`] == 4) {
                                    const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                                    agent2.isInfantry()
                                    if (sandmap.players[1].units.length % 2 == 0) {
                                        agent2.super = 1
                                        agent2.health *= 1.8
                                        agent2.maxhealth *= 1.8
                                        agent2.defense *= 1.8
                                        agent2.damage *= 1.8
                                        agent2.decayRate = 0
                                    }

                                } else if (colditzleriancampaign3[`${t},${k}`] == 5) {
                                    const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                                    agent2.isScout()
                                    if (sandmap.players[1].units.length % 2 == 0) {
                                        agent2.super = 1
                                        agent2.health *= 5
                                        agent2.maxhealth *= 5
                                        agent2.defense *= 5
                                        agent2.damage *= 3
                                        agent2.decayRate = 0
                                    }
                                    agent2.decayRate = 0

                                }
                            }
                        }
                    } else if (t == 3) {


                        sandmap.players[0].type = 1
                        sandmap.players[0].name = "Cold Itzlerians"
                        sandmap.players[0].color = "#dd8800"
                        sandmap.players[0].units = []
                        sandmap.players[0].hotrock = 400
                        sandmap.players[1].units = []
                        sandmap.players[1].type = 0
                        sandmap.players[1].clickrate = 1000
                        sandmap.players[1].attacktimeout = 10000000000
                        sandmap.players[1].color = "#440088"
                        sandmap.players[1].name = "Earthoids"
                        sandmap.players[1].hotrock = 400
                        sandmap.players[1].aimode = 2
                        sandmap.players[0].units = []
                        sandmap.players[1].units = []
                        start = 0
                        for (let t = 0; t < 1; t++) {
                            const agent1 = new Agent(sandmap.blocks[7][t + 7], sandmap.players[0])
                            agent1.sana = 1
                            agent1.name = "Su'ser'sana"
                            agent1.finishMorph2()
                        }
                        for (let t = 0; t < 2; t++) {
                            const agent1 = new Agent(sandmap.blocks[10][t + 9], sandmap.players[0])
                            agent1.finishMorph2()
                        }
                        for (let t = 0; t < 2; t++) {
                            const agent1 = new Agent(sandmap.blocks[12][t + 9], sandmap.players[0])
                            agent1.finishMorph1()
                        }
                        for (let t = 0; t < 3; t++) {
                            const agent1 = new Agent(sandmap.blocks[14][t + 6], sandmap.players[0])
                            agent1.isNymph()
                        }
                        // for (let  t = 0; t < 3; t++) {
                        // }
                        playstart = 1
                        for (let t = 0; t < sandmap.blocks.length; t++) {
                            for (let k = 0; k < sandmap.blocks[t].length; k++) {

                                sandmap.blocks[t][k].sourcerock = 0
                                sandmap.blocks[t][k].hotrock = 0
                                sandmap.blocks[t][k].ice = 0
                                sandmap.blocks[t][k].walkable = true

                                if (colditzleriancampaign4[`${t},${k}`] == 1) {
                                    sandmap.blocks[t][k].ice = 1
                                    sandmap.blocks[t][k].walkable = false
                                    sandmap.blocks[t][k].color = "#AAFFFF"
                                } else if (colditzleriancampaign4[`${t},${k}`] == 2) {
                                    sandmap.blocks[t][k].sourcerock = 300
                                    sandmap.blocks[t][k].hotrock = 2
                                    sandmap.blocks[t][k].walkable = true
                                    sandmap.blocks[t][k].color = "#AA8822"
                                    sandmap.hotrocks.push(sandmap.blocks[t][k])
                                } else if (colditzleriancampaign4[`${t},${k}`] == 3) {
                                    const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                                    agent2.isHarvester()
                                    agent2.decayRate = 0
                                } else if (colditzleriancampaign4[`${t},${k}`] == 4) {
                                    const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                                    agent2.isInfantry()
                                    agent2.decayRate = 0

                                } else if (colditzleriancampaign4[`${t},${k}`] == 5) {
                                    const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                                    agent2.isScout()
                                    agent2.decayRate = 0

                                } else if (colditzleriancampaign4[`${t},${k}`] == 6) {
                                    const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                                    agent2.isSniper()
                                    agent2.decayRate = 0

                                }
                            }
                        }
                    } else if (t == 4) {


                        sandmap.players[0].type = 1
                        sandmap.players[0].name = "Cold Itzlerians"
                        sandmap.players[0].color = "#dd8800"
                        sandmap.players[0].units = []
                        sandmap.players[0].hotrock = 5000
                        sandmap.players[1].units = []
                        sandmap.players[1].type = 0
                        sandmap.players[1].clickrate = 1000
                        sandmap.players[1].attacktimeout = 10000000000
                        sandmap.players[1].name = "Earthoids"
                        sandmap.players[1].color = "#440088"
                        sandmap.players[1].hotrock = 400
                        sandmap.players[1].aimode = 2
                        sandmap.players[0].units = []
                        sandmap.players[1].units = []
                        start = 0
                        for (let t = 0; t < 1; t++) {
                            const agent1 = new Agent(sandmap.blocks[7][t + 7], sandmap.players[0])
                            agent1.sana = 1
                            agent1.name = "Su'ser'sana"
                            agent1.finishMorph2()
                        }

                        for (let t = 0; t < 36; t++) {
                            const agent1 = new Agent(sandmap.blocks[14 + Math.floor(t / 12)][(t % 12) + 6], sandmap.players[0])
                            // agent1.isNymph()
                            // agent1.damage = 1
                            // agent1.health = 1000
                            // agent1.maxhealth = 1000
                            agent1.finishMorph1()
                        }
                        for (let t = 0; t < 12; t++) {
                            const agent1 = new Agent(sandmap.blocks[10][t + 9], sandmap.players[0])
                            agent1.finishMorph2()
                            // agent1.isNymph()

                            // agent1.damage = 1
                            // agent1.health = 1000
                            // agent1.maxhealth = 1000
                            // agent1.health = 9999999999
                            // agent1.maxhealth = 9999999999
                            // agent1.movespeed = 1
                        }
                        for (let t = 0; t < 12; t++) {
                            const agent1 = new Agent(sandmap.blocks[12][t + 9], sandmap.players[0])
                            // agent1.isNymph()
                            // agent1.damage = 1
                            // agent1.health = 1000
                            // agent1.maxhealth = 1000
                            agent1.finishMorphgamergate()
                        }
                        // for (let  t = 0; t < 3; t++) {
                        // }
                        playstart = 1
                        for (let t = 0; t < sandmap.blocks.length; t++) {
                            for (let k = 0; k < sandmap.blocks[t].length; k++) {

                                sandmap.blocks[t][k].sourcerock = 0
                                sandmap.blocks[t][k].hotrock = 0
                                sandmap.blocks[t][k].ice = 0
                                sandmap.blocks[t][k].walkable = true

                                if (colditzleriancampaign5[`${t},${k}`] == 1) {
                                    sandmap.blocks[t][k].ice = 1
                                    sandmap.blocks[t][k].walkable = false
                                    sandmap.blocks[t][k].color = "#AAFFFF"
                                } else if (colditzleriancampaign5[`${t},${k}`] == 2) {
                                    sandmap.blocks[t][k].sourcerock = 300
                                    sandmap.blocks[t][k].hotrock = 2
                                    sandmap.blocks[t][k].walkable = true
                                    sandmap.blocks[t][k].color = "#AA8822"
                                    sandmap.hotrocks.push(sandmap.blocks[t][k])
                                } else if (colditzleriancampaign5[`${t},${k}`] == 3) {
                                    const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                                    agent2.isHarvester()
                                    agent2.decayRate = 0
                                } else if (colditzleriancampaign5[`${t},${k}`] == 4) {
                                    const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                                    agent2.isInfantry()
                                    agent2.decayRate = 0

                                } else if (colditzleriancampaign5[`${t},${k}`] == 5) {
                                    const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                                    agent2.isScout()
                                    agent2.decayRate = 0

                                } else if (colditzleriancampaign5[`${t},${k}`] == 6) {
                                    const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                                    agent2.isSniper()
                                    agent2.decayRate = 0

                                } else if (colditzleriancampaign5[`${t},${k}`] == 7) {
                                    const agent2 = new Agent(sandmap.blocks[t][k], sandmap.players[1])
                                    agent2.isSniper()
                                    agent2.decayRate = 0

                                    const building = new Building(sandmap.blocks[t][k], sandmap.players[1], 0, 1, 0)
                                    building.defense = 3
                                    building.damage = 0
                                } else if (colditzleriancampaign5[`${t},${k}`] == 8) {
                                    const building = new Building(sandmap.blocks[t][k], sandmap.players[1], 0, 1, 0)
                                    building.defense = 3
                                    building.damage = 0

                                }
                            }
                        }
                    } else if (t == 5) {
                        park1.play()

                        sandmap.players[0].type = 0
                        sandmap.players[0].name = "Earthoids"
                        sandmap.players[0].units = []
                        sandmap.players[0].hotrock = 500
                        sandmap.players[1].units = []
                        sandmap.players[1].type = 3
                        sandmap.players[1].clickrate = 10000000000.1
                        sandmap.players[1].attacktimeout = 10000000000
                        sandmap.players[1].name = "Librilbians"
                        sandmap.players[1].hotrock = 400
                        sandmap.players[1].aimode = 2
                        sandmap.players[0].units = []
                        sandmap.players[1].units = []
                        start = 0
                        for (let t = 0; t < 1; t++) {
                            const agent1 = new Agent(sandmap.blocks[7][t + 7], sandmap.players[0])
                            agent1.isSniper()
                            agent1.super = 1
                            agent1.park = 1
                            agent1.name = "Commander Park"
                            agent1.health = 3690
                            agent1.maxhealth = 3690
                            agent1.damage *= 3
                            agent1.defense *= 2
                            agent1.range = 11
                            agent1.sight = 12
                            agent1.sana = 1
                            agent1.decayRate = 0
                            agent1.movespeed = 2
                            agent1.range = 11
                            agent1.sight = 12
                        }
                        for (let t = 0; t < 4; t++) {
                            const agent1 = new Agent(sandmap.blocks[10][t + 9], sandmap.players[0])
                            agent1.isScout()
                            agent1.name = "Experimental Drone "
                            agent1.range = 7
                            agent1.sight = 8
                            agent1.movespeed = 1
                            agent1.super = 1
                            agent1.health *= 5
                            agent1.defense *= 5
                            agent1.maxhealth *= 5
                            agent1.damage *= 4
                            agent1.decayRate *= .01
                        }
                        // for (let  t = 0; t < 3; t++) {
                        // }
                        playstart = 1
                        this.buildmaplibrilbians(humancampaign1)
                    } else if (t == 6) {

                        sandmap.players[0].type = 0
                        sandmap.players[0].name = "Earthoids"
                        sandmap.players[0].units = []
                        sandmap.players[0].hotrock = 500
                        sandmap.players[1].units = []
                        sandmap.players[1].type = -1
                        sandmap.players[1].clickrate = 10000000000.1
                        sandmap.players[1].attacktimeout = 10000000000
                        sandmap.players[1].name = "All"
                        sandmap.players[1].hotrock = 0
                        sandmap.players[1].aimode = 2
                        sandmap.players[0].units = []
                        sandmap.players[1].units = []
                        start = 0
                        for (let t = 0; t < 1; t++) {
                            const agent1 = new Agent(sandmap.blocks[65][65], sandmap.players[0])
                            agent1.isSniper()
                            agent1.super = 1
                            agent1.park = 1
                            agent1.name = "Commander Park"
                            agent1.health = 3690
                            agent1.maxhealth = 3690
                            agent1.damage *= 3
                            agent1.defense *= 2
                            agent1.range = 11
                            agent1.sight = 12
                            agent1.sana = 1
                            agent1.decayRate = 0
                            agent1.movespeed = 2
                            agent1.range = 11
                            agent1.sight = 12
                        }
                        playstart = 1
                        this.buildmapallfactions(humancampaign2)
                    } else if (t == 7) {
                        let resize = new MapResizer(256, 0)
                        this.mission = t
                        sandmap.players[0].type = 0
                        sandmap.players[0].name = "Earthoids"
                        sandmap.players[0].units = []
                        sandmap.players[0].hotrock = 0
                        sandmap.players[1].units = []
                        sandmap.players[1].type = -1
                        sandmap.players[1].clickrate = 1
                        sandmap.players[1].attacktimeout = 0
                        sandmap.players[1].name = "All"
                        sandmap.players[1].hotrock = 100000
                        sandmap.players[1].surf = 1
                        sandmap.players[1].isAI = 1
                        sandmap.players[0].units = []
                        sandmap.players[1].units = []
                        start = 0
                        for (let t = 0; t < 1; t++) {
                            const agent1 = new Agent(sandmap.blocks[2][2], sandmap.players[0])
                            agent1.isSniper()
                            agent1.super = 1
                            agent1.park = 1
                            agent1.name = "Commander Park"
                            agent1.health = 3690
                            agent1.maxhealth = 3690
                            agent1.damage *= 3
                            agent1.defense *= 2
                            agent1.range = 11
                            agent1.firerate *= 2
                            agent1.sight = 12
                            agent1.sana = 1
                            agent1.decayRate = 0
                            agent1.movespeed = 2
                            agent1.range = 11
                            agent1.sight = 12
                        }
                        playstart = 1
                        this.buildmapallfactions(humancampaign3)
                    }

                    start = 1

                    for (let t = 0; t < sandmap.players[0].units.length; t++) {
                        sandmap.players[0].units[t].moved = 1
                        sandmap.players[0].units[t].see()
                        // sandmap.players[0].units[t].attack()
                        // sandmap.players[0].units[t].move()
                    }
                    // for (let t = 0; t < sandmap.players[1].units.length; t++) {
                    //     sandmap.players[1].units[t].moved = 1
                    //     sandmap.players[1].units[t].see()
                    //     sandmap.players[1].units[t].attack()
                    //     sandmap.players[1].units[t].move()
                    // }
                    return true
                }
            }



            // if(pix.data[t] <= 0 && pix.data[t+1] <= 0 && pix.data[t+2] <= 0){
            //     obj[`${x},${y}`] = 1
            // }else if(pix.data[t] == 255 && pix.data[t+1] <= 0 && pix.data[t+2] <= 0){
            //     obj[`${x},${y}`] = 2
            // }else if(pix.data[t] == 255 && pix.data[t+1] <= 0 && pix.data[t+2] == 255){
            //     obj[`${x},${y}`] = 3
            // }else if(pix.data[t] == 0 && pix.data[t+1] <= 0 && pix.data[t+2] == 255){
            //     obj[`${x},${y}`] = 4
            // }else if(pix.data[t] == 0 && pix.data[t+1] == 255 && pix.data[t+2] == 0){
            //     obj[`${x},${y}`] = 5
            // }
        }
        draw() {
            this.starter.draw()
            canvas_context.fillStyle = "white"
            canvas_context.font = "25px arial"
            canvas_context.fillText("Campaign", this.starter.x + 35, this.starter.y + 43)


            if (this.on == 1) {

                canvas_context.fillStyle = "white"
                canvas_context.font = "25px arial"
                canvas_context.fillText("Work in progress, load time may vary by level", this.starter.x - 635, this.starter.y + 43)
                canvas_context.fillText("type '?' to escape a level to menu at any time", this.starter.x - 635, this.starter.y + 83)
                for (let t = 0; t < this.metanames.length; t++) {
                    canvas_context.fillStyle = this.colorsx[t][1]
                    canvas_context.font = "14px arial"
                    canvas_context.fillText(this.metanames[t], 40 + (t * 250), 30)
                }

                for (let t = 0; t < 8; t++) { //this.buttons.length
                    this.buttons[t].draw()
                    canvas_context.fillStyle = this.buttons[t].tcol
                    canvas_context.font = "18px arial"
                    canvas_context.strokeStyle = "black"
                    canvas_context.lineWidth = 2
                    canvas_context.strokeText(this.names[Math.floor(t / 5)][t % 5], this.buttons[t].x + 20, this.buttons[t].y + 29)
                    canvas_context.font = "18px arial"
                    canvas_context.fillText(this.names[Math.floor(t / 5)][t % 5], this.buttons[t].x + 20, this.buttons[t].y + 29)
                }
            }
        }


    }



    campaignController = new Campaign()

    const sandmap = new Sandmap(CANVAS_WIDTH, CANVAS_HEIGHT, 0, 0, []);


    let mapSizer = new UiRectangle(200, 455, 300, 75, "#777777")
    let unitCapper = new UiRectangle(680, 455, 300, 75, "#777777")
    let mapChooser = new UiRectangle(460, 535, 400, 75, "#777777")
    let controlToggle = new UiRectangle(40, 535, 400, 75, "#777777")

    let guideplus = new UiRectangle(550, 620, 200, 75, "#333333")
    let playbutton = new UiRectangle(80, 620, 200, 75, "#333333")
    let aitoggle1 = new UiRectangle(200, 200, 300, 75, "#333333")
    // DropDownFaction
    let chartoggle1 = new DropDownFaction(sandmap.players[0])
    // let chartoggle1 = new UiRectangle(200, 300, 300, 75, "#333333")
    // let chartoggle1 = new DropDownDifficulty(sandmap.players[0])
    let aitoggle2 = new UiRectangle(680, 200, 300, 75, "#333333")
    // let chartoggle2 = new UiRectangle(680, 300, 300, 75, "#333333")
    let chartoggle2 = new DropDownFaction(sandmap.players[1])
    let chartoggle3 = new DropDownFaction(sandmap.players[2])
    let chartoggle4 = new DropDownFaction(sandmap.players[3])

    let AImodeButton =  new UiRectangle(550, 220, 100, 75, "#333333")

    // let difftoggle1 = new UiRectangle(200, 100, 450, 75, "#333333")
    let difftoggle1 = new DropDownDifficulty(sandmap.players[0])
    // let difftoggle2 = new UiRectangle(680, 100, 450, 75, "#333333")
    let difftoggle2 = new DropDownDifficulty(sandmap.players[1])
    let difftoggle3 = new DropDownDifficulty(sandmap.players[2])
    // let difftoggle2 = new UiRectangle(680, 100, 450, 75, "#333333")
    let difftoggle4 = new DropDownDifficulty(sandmap.players[3])

    const score = new ScoreGraph()
    let maplist = [{}, outmap, outmap2, outmap3, outmap4, outmap5, outmap6, outmap7, outmap8, outmap9, outmap10, outmap11, outmap12, outmap13, outmap14, outmap15]
    let maplistnames = ["Flat", "Noodle", "Aperture", "Box", "Chambers", "Rubble", "Screwball", "Grips", "Long Way", "Husk", "Lock-In", "Cells", "Jack", "Reservoirs", "Maze", "Vortex"]
    let mapindex = 0

    class Mapskinner {
        constructor(map) {
            campaignController.buildOutMap(map)
        }
    }

    class Building {
        constructor(tile, faction, size, oversmaller = 0, price = 0) {
            this.decay = 30
            this.dying = 0
            this.id = Math.random()
            this.built = 1
            this.factionNum = sandmap.players.indexOf(faction)
            //  (faction.createdCount/500)
            faction.createdCount++
            if(faction.createdCount >= 500){
                faction.createdCount += .51
                let c = 0
                for(let t = 0;t<faction.units.length;t++){
                    faction.units[t].id = c
                    c+=(1/500)
                }
                for(let t = 0;t<faction.buildings.length;t++){
                    faction.buildings[t].id = c
                    c+=(1/500)
                }
            }
            // if(faction.blocks[tile.t][tile.k].markdraw != 1){
            //     if(sandmap.turn == sandmap.indexOf(faction)){
            //         this.refund(price)
            //         return
            //     }
            // }
            faction.createdCount%= 500
            this.wayfinding = -1
            this.debt = 0
            sandmap.backgroundcheck = 1
            this.triedRocks = []
            this.slimeconstant = 0
            this.slimeossify = 50
            this.seetime = 0
            if (tile.id % worldscale < 0) {
                tile = sandmap.gridPoints[tile.id + 1]
            }
            if (tile.id < worldscale) {
                tile = sandmap.gridPoints[tile.id + worldscale]
            }
            this.tile = tile
            this.waypoint = this.tile
            this.tile.wallflag = 0
            // this.tile.builtOn = 1
            this.timer = -1
            this.tile.faction = sandmap.players.indexOf(faction)

            this.faction = faction
            this.waylink = new Line(this.tile.x + 5, this.tile.y + 5, this.waypoint.x + 5, this.waypoint.y + 5, this.faction.color, .5)
            this.tiles = []
            if (oversmaller == 0) {

                size = 1
                this.size = size
            } else {

                size = 0
                this.size = size
            }
            for (let t = 0; t <= size; t++) {
                for (let k = 0; k <= size; k++) {
                    if (tile.t + t < 0) {
                        this.refund(price)
                        return
                    }
                    if (tile.k + k < 0) {
                        this.refund(price)
                        return
                    }
                    if (tile.t + t > worldscale - 1) {
                        this.refund(price)
                        return
                    }
                    if (tile.k + k > worldscale - 1) {
                        this.refund(price)
                        return
                    }
                    this.tiles.push(sandmap.blocks[tile.t + t][tile.k + k])
                }
            }
            for (let t = 0; t < this.tiles.length; t++) {
                if (this.tiles[t].builtOn == 1 || (this.tiles[t].occupied == true && price != 2 && price != 0) || this.tiles[t].ice == 1) { //2 for slime
                    this.refund(price)
                    for (let k = 0; k < t; k++) {
                        this.tiles[k].builtOn = 0
                    }
                    return
                } else {
                    this.tiles[t].builtOn = 1
                    this.tiles[t].walkable = false
                }
            }

            for (let t = 0; t < this.tiles.length; t++) {
                if(onlineNow != 1){
                this.faction.blocks[this.tiles[t].t][this.tiles[t].k].markdraw = 1
                }
            }
            this.selected = 0
            this.health = 100
            this.maxhealth = this.health
            this.name = "Wall"
            // this.cost = 10
            // this.faction.hotrock -= this.cost
            this.body = new UnitCircle(this.tile.x + (this.tile.width * .5), this.tile.y + (this.tile.height * .5), 5, this.faction.color)
            this.faction.buildings.push(this)
            this.first = 1
            for (let t = 0; t < this.faction.units.length; t++) {
                this.faction.units[t].heatmoved = 1
            }
            this.loaded = []
            this.times = []
            this.commandPanel = new AgentCommands(this)
            this.listDraw = new BuildingQue(this)
            this.faction.sendBuildings = 1
        }
        refund(price) {
            //////////console.log(this.faction.hotrock)
            this.faction.hotrock += price
            //////////console.log(this.faction.hotrock)
        }

            totalBlank(tile, size, player) {
                this.size = size
            this.built = 1
                
            this.factionNum = player
            this.tile.drawish = 0
            this.tile.walkable = true
            this.tile.occupied = false
            this.tile.occupant = {}
            this.tile.occupant.moving = false
            this.tile.occupant.faction = {}
            this.tile.occupant.faction.id = -1
            this.tile = tile
            this.waypoint = this.tile
            this.tile.wallflag = 0
            this.first = 1
            this.animated = 1
            // this.tile.builtOn = 1
            this.timer = -1
            this.tile.faction = sandmap.players.indexOf(this.faction)

            this.waylink = new Line(this.tile.x + 5, this.tile.y + 5, this.waypoint.x + 5, this.waypoint.y + 5, this.faction.color, .5)
            for (let t = 0; t < this.tiles.length; t++) {
                    this.tiles[t].builtOn = 0
                    this.tiles[t].walkable = true
            }
            this.tiles = []
            for (let t = 0; t <= this.size; t++) {
                for (let k = 0; k <= this.size; k++) {
                    this.tiles.push(sandmap.blocks[tile.t + t][tile.k + k])
                }
            }
            for (let t = 0; t < this.tiles.length; t++) {
                    this.tiles[t].builtOn = 1
                    this.tiles[t].walkable = false
            }



                this.decay = 30
                this.mound = 0
                this.ave = 0
                this.egg = 0
                this.barracks = 0
                this.bulbplant = 0
                this.beehive = 0
                this.bee = 0
                this.tree = 0
                this.pond = 0
                this.alagadile = 0
                this.assembler = 0
                this.slime = 0
                this.sporeball = 0
                this.gate = 0
                this.wall = 0
                this.spire = 0
            }
            teleport(){
                if(this.waypoint.walkable == true){
                    for(let t = 0;t<this.faction.units.length;t++){
                       if(this.faction.units[t].tile.t == this.tiles[0].t &&this.faction.units[t].tile.k == this.tiles[0].k){
                           this.faction.units[t].tile = this.waypoint
                           this.faction.units[t].realPath = [this.faction.units[t].tile]
                           this.faction.units[t].index = 0
                           this.tiles[0].walkable = true
                           this.tiles[0].occupied = false
                           this.tiles[0].occuapant = {}
                           break
                       }
                    }
                }
            }
                        isWall(tile){

            this.tile = tile
                        this.wall = 1
                        this.name = "Wall"
                        this.defense = 3
                        this.damage = 0
                        //this.health = 100
                        //this.maxhealth = this.health
                        }
                        isEggmound(tile){

                        this.tile = tile
                        this.mound = 1
                        this.ave = 1
                        this.eggtimer = 300
                        this.name = "Avesectian Eggmound"
                        this.defense = 12
                        this.damage = 0
                        //this.health = 1260
                        //this.maxhealth = this.health
                        this.tile.spiretile = 1
                        }
                        isEgg(tile){

            this.tile = tile
                        this.ave = 1
                        this.egg = 1
                        this.name = "Avesectian Egg"
                        this.defense = 24
                        this.damage = 0
                        //this.health = 100
                        //this.maxhealth = this.health
                        this.tile.spiretile = 1
                        this.tile.walkable = true
                        }
                        isPond(tile){

            this.tile = tile
                        this.pond = 1
                        this.alagadile = 1
                        this.name = "Alagadile Pond"
                        this.animated = 1
                        this.defense = 12
                        this.damage = 0
                        //this.health = 1260
                        }
                        isTeleporter(tile){

            this.tile = tile
                        this.teleporter = 1
                        this.alagadile = 1
                        this.name = "Alagadile Pond"
                        this.animated = 1
                        this.defense = 3
                        this.damage = 0
                        //this.health = 1260
                        }
                        isTree(tile){

            this.tile = tile
                        this.tree = 1
                        this.gogo = 1
                        this.name = "Gogonaut Tree"
                        this.defense = 30
                        this.damage = 0
                        //this.health = 4000
                        //this.maxhealth = this.health
                        this.tile.spiretile = 1
                        }
                        isBeehive(tile){

            this.tile = tile
                        this.bee = 1
                        this.beehive = 1
                        this.name = "Beeple Hive"
                        this.animated = 1
                        this.defense = 30
                        this.damage = 0
                        //this.health = 5000
                        this.tile.spiretile = 1
                        }

                    isPodmother(tile){

            this.tile = tile
                                    this.bulbplant = 2
                                    this.name = "Librilbian Podmother"
                                    //this.health = 1750
                                    //this.maxhealth = this.health
                                    this.defense = 22
                                    this.damage = 0
                                    this.tile.spiretile = 1
                    }
                    isBulbplant(tile){

            this.tile = tile
                                    this.bulbplant = 1
                                    this.name = "Librilbian Bulbplant"
                                    //this.health = 500
                                    //this.maxhealth = this.health
                                    this.defense = 6
                                    this.damage = 0
                                    this.tile.spiretile = 1
                                    this.tile.dirt = 1
                    }
                    isScoutAssembler(tile){

            this.tile = tile
                                    this.assembler = 2
                                    this.name = "Scout Assembler"
                                    //this.health = 750
                                    //this.maxhealth = this.health
                                    this.defense = 20
                                    this.damage = 0
                                    this.tile.spiretile = 1
                    }
                    isSoldierAssembler(tile){

            this.tile = tile
                                    this.assembler = 1
                                    this.name = "Soldier Assembler"
                                    //this.health = 500
                                    //this.maxhealth = this.health
                                    this.defense = 6
                                    this.damage = 0
                                    this.tile.spiretile = 1
                    }
                    isMachineLab(tile){

            this.tile = tile
                                    this.barracks = 2
                                    this.name = "Machine Lab"
                                    //this.health = 1000
                                    //this.maxhealth = this.health
                                    this.defense = 20
                                    this.damage = 0
                    }
                    isBarracks(tile){

            this.tile = tile
                                    this.barracks = 1
                                    this.name = "Barracks"
                                    //this.health = 500
                                    //this.maxhealth = this.health
                                    this.defense = 6
                                    this.damage = 0
                    }

                    isSpire(tile){

            this.tile = tile
                                        this.defense = 10
                                        this.damage = 0
                                        this.name = "Spire"
                                        // this.body2 = new UnitCircle(this.tile.x + 5, this.tile.y + 5, 110, "#FFFF0010")
                                        // this.bodybig = new UnitCircle(this.tile.x + 5, this.tile.y + 5, 170, "#FFFF0010")
                                        //this.health = 420
                                        //this.maxhealth = this.health
                                        this.spire = 1
                                        this.tile.spiretile = 1
                                        this.body2 = new UnitCircle(this.tile.x + 5, this.tile.y + 5, 110,"#FF000010")
                                        this.bodybig = new UnitCircle(this.tile.x + 5, this.tile.y + 5, 170, "#FF000010")
                    }
                    isGate(tile){

            this.tile = tile
                                        //this.health = 300
                                        //this.maxhealth = this.health
                                        this.defense = 35
                                        this.damage = 0
                                        this.gate = 1
                                        this.name = "Blast Door"
                                        this.open = -1
                    }

                    isHighCasteAssembler(tile){

            this.tile = tile
                                    //this.health = 1300
                                    //this.maxhealth = this.health
                                    this.defense = 15
                                    this.damage = 0
                                    this.assembler = 3
                                    this.tile.spiretile = 1
                                    this.name = "High-Caste Assembler"
                    }
                    isSporeball(tile){

            this.tile = tile
                                    this.sporeball = 1
                                    this.tile.spiretile = 1
                                    this.tile.slime = true
                                    this.pather = slimemakingastar
                                    this.name = "Sporeball"
                                    //this.health = 1500
                                    //this.maxhealth = this.health
                                    this.defense = 7
                                    this.damage = 0
                    }
                    isSlime(tile){

            this.tile = tile
                                    this.name = "Slime"
                                    this.defense = 0
                                    this.damage = 0
                                    this.tile.spiretile = 1
                                    this.tile.walkable = true
                                    this.tile.slime = true
                                    this.slime = 1
                                    //this.health = 5
                                    //this.maxhealth = this.health
                                    this.pather = slimyastar
                                    this.active = 0
                                    this.tile.primed = 0
                                    this.pather.agent = this
                    }
        see() {
            if(onlineNow == 1 && sandmap.players.indexOf(this.faction) != sandmap.turn){
                return
            }
            for (let t = -this.sight; t <= this.sight; t++) {
                for (let k = -this.sight; k <= this.sight; k++) {
                    if (this.tile.t + t >= 0) {
                        if (this.tile.k + k >= 0) {
                            if (this.tile.t + t < worldscale) {
                                if (this.tile.k + k < worldscale) {
                                    // if (typeof (sandmap.blocks[this.tile.t + t] != undefined)) { //noquotes on all these??? fixes?
                                    //     if (typeof (sandmap.blocks[this.tile.t + t][this.tile.k + k] != undefined)) {
                                    // this.faction.fog[this.tile.t + t][this.tile.k + k].color = "transparent"
                                    // this.faction.fog[this.tile.t + t][this.tile.k + k].timer = 100
                                    this.faction.blocks[this.tile.t + t][this.tile.k + k].markdraw = 1
                                    if (!sandmap.blocks[this.tile.t + t][this.tile.k + k].factions.includes(sandmap.players.indexOf(this.faction))) {
                                        sandmap.blocks[this.tile.t + t][this.tile.k + k].factions.push(sandmap.players.indexOf(this.faction))
                                        this.faction.seen.push(sandmap.blocks[this.tile.t + t][this.tile.k + k])
                                        if (!sandmap.blocks[this.tile.t + t][this.tile.k + k].factionsrock.includes(sandmap.players.indexOf(this.faction)) && sandmap.blocks[this.tile.t + t][this.tile.k + k].sourcerock > 0) {
                                            // this.faction.clickrate++
                                            sandmap.blocks[this.tile.t + t][this.tile.k + k].factionsrock.push(sandmap.players.indexOf(this.faction))
                                            this.faction.seenrocks.push(sandmap.blocks[this.tile.t + t][this.tile.k + k])
                                            //////////console.log(sandmap.blocks[this.tile.t + t][this.tile.k + k].factionsrock)
                                        } else {
                                            sandmap.blocks[this.tile.t + t][this.tile.k + k].factionsrock.push(sandmap.players.indexOf(this.faction))
                                        }
                                        //     }
                                        // }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        makeHamartansoldier() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 175 && this.faction.units.length < (unitcap)) {
                    if (this.assembler == 1) {
                        this.faction.hotrock -= 175
                        this.que = 1
                        this.soldier = 1
                        this.timer = 95 //115
                        this.maxtimer = this.timer
                    }
                }
            } else {
                if (this.faction.hotrock >= 175 && this.faction.units.length < (unitcap)) {
                    if (this.assembler == 1) {
                        this.faction.hotrock -= 175
                        this.loaded.push('soldier')
                        this.times.push(95)
                    }
                }
            }
        }
        makeHamartanscout() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 75 && this.faction.units.length < (unitcap)) {
                    if (this.assembler == 2) {
                        this.faction.hotrock -= 75
                        this.que = 1
                        this.scout = 1
                        this.timer = 85
                        this.maxtimer = this.timer
                    }
                }
            } else {

                if (this.faction.hotrock >= 75 && this.faction.units.length < (unitcap)) {
                    if (this.assembler == 2) {
                        this.faction.hotrock -= 75
                        this.que = 1
                        // this.scout = 1
                        // this.timer = 85
                        this.loaded.push('scout')
                        this.times.push(85)
                    }
                }
            }
        }
        makeHamartanworker() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 145 && this.faction.units.length < (unitcap)) {
                    if (this.assembler == 3) {
                        this.faction.hotrock -= 145
                        this.que = 1
                        this.worker = 1
                        this.timer = 20
                        this.maxtimer = this.timer
                    }
                }
            } else {
                if (this.faction.hotrock >= 145 && this.faction.units.length < (unitcap)) {
                    if (this.assembler == 3) {
                        this.faction.hotrock -= 145
                        this.que = 1
                        this.loaded.push('worker')
                        this.times.push(20)
                    }
                }

            }
        }
        makeLibrilbianpollinator() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 85 && this.faction.units.length < (unitcap)) {
                    if (this.bulbplant == 1) {
                        this.faction.hotrock -= 85
                        this.que = 1
                        this.pollinator = 1
                        this.timer = 100
                        this.maxtimer = this.timer
                    }
                }
            } else {
                if (this.faction.hotrock >= 85 && this.faction.units.length < (unitcap)) {
                    if (this.bulbplant == 1) {
                        this.faction.hotrock -= 85
                        this.que = 1
                        this.loaded.push('pollinator')
                        this.times.push(100)
                    }
                }
            }
        }
        makeLibrilbianpodman() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 140 && this.faction.units.length < (unitcap)) {
                    if (this.bulbplant == 2) {
                        this.faction.hotrock -= 140 //170
                        this.que = 1
                        this.podman = 1
                        this.timer = 180
                        this.maxtimer = this.timer
                    }
                }
            } else {
                if (this.faction.hotrock >= 140 && this.faction.units.length < (unitcap)) {
                    if (this.bulbplant == 2) {
                        this.faction.hotrock -= 140 //170
                        this.que = 1
                        this.loaded.push('podman')
                        this.times.push(180)
                    }
                }

            }
        }
        makeLibrilbiangoliophyte() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 355 && this.faction.units.length < (unitcap)) {
                    if (this.bulbplant == 2) {
                        this.faction.hotrock -= 355
                        this.que = 1
                        this.goliophyte = 1
                        this.timer = 290
                        this.maxtimer = this.timer
                    }
                }
            } else {

                if (this.faction.hotrock >= 355 && this.faction.units.length < (unitcap)) {
                    if (this.bulbplant == 2) {
                        this.faction.hotrock -= 355
                        this.que = 1
                        this.loaded.push('goliophyte')
                        this.times.push(290)
                    }
                }
            }
        }
        makeLibrilbianpufffellow() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 90 && this.faction.units.length < (unitcap)) {
                    if (this.bulbplant == 2) {
                        this.faction.hotrock -= 90
                        this.que = 1
                        this.pufffellow = 1
                        this.timer = 50
                        this.maxtimer = this.timer
                    }
                }
            } else {
                if (this.faction.hotrock >= 90 && this.faction.units.length < (unitcap)) {
                    if (this.bulbplant == 2) {
                        this.faction.hotrock -= 90
                        this.que = 1
                        this.loaded.push('pufffellow')
                        this.times.push(290)
                    }
                }
            }
        }
        makeHamartaninvader() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 340 && this.faction.units.length < (unitcap)) {
                    if (this.assembler == 3) {
                        this.faction.hotrock -= 340
                        this.que = 1
                        this.invader = 1
                        this.timer = 190 //270
                        this.maxtimer = this.timer
                    }
                }
            } else {
                if (this.faction.hotrock >= 340 && this.faction.units.length < (unitcap)) {
                    if (this.assembler == 3) {
                        this.faction.hotrock -= 340
                        this.que = 1
                        this.loaded.push('invader')
                        this.times.push(190)
                    }
                }
            }
        }
        makeSporeseer() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 80 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 80
                    this.que = 1
                    this.seer = 1
                    this.timer = 35
                    this.maxtimer = this.timer
                }
            } else {
                if (this.faction.hotrock >= 80 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 80
                    this.que = 1
                    this.loaded.push('seer')
                    this.times.push(35)
                }
            }

        }
        makeVizier() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 90 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 90
                    this.que = 1
                    this.vizier = 1
                    this.timer = 30
                    this.maxtimer = this.timer
                }
            } else {

                if (this.faction.hotrock >= 90 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 90
                    this.que = 1
                    this.loaded.push('vizier')
                    this.times.push(30)
                }
            }
        }
        makeMycoknight() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 200 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 200
                    this.que = 1
                    this.knight = 1
                    this.timer = 45
                    this.maxtimer = this.timer
                }
            } else {
                if (this.faction.hotrock >= 200 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 200
                    this.que = 1
                    this.loaded.push('knight')
                    this.times.push(45)
                }
            }
        }
        makeFruitingbuddy() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 45 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 45
                    this.que = 1
                    this.buddy = 1
                    this.timer = 25
                    this.maxtimer = this.timer
                }
            } else {

                if (this.faction.hotrock >= 45 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 45
                    this.que = 1
                    this.loaded.push('buddy')
                    this.times.push(25)
                }
            }
        }
        makeScout() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 30 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 30
                    //////////console.log("?sdr")
                    this.que = 1
                    this.drone = 1
                    this.timer = 25
                    this.maxtimer = this.timer
                }
            } else {
                if (this.faction.hotrock >= 30 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 30
                    //////////console.log("?sdr")
                    this.que = 1
                    this.loaded.push('drone')
                    this.times.push(25)
                }

            }
        }
        finishVizier() {
            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    soundCancel()
                    vizieraudio.play()
                }
            }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isSporevizir()
        }
        finishMycoknight() {
            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    soundCancel()
                    mycoknightaudio.play()
                }
            }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isMycoknight()
        }
        finishSporeseer() {
            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    soundCancel()
                    seeraudio.play()
                }
            }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isSporeseer()
        }
        finishFruitingbuddy() {
            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    soundCancel()
                    buddyaudio.play()
                }
            }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isFruitingBuddy()
        }
        finishScout() {
            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    soundCancel()
                    online.play()
                }
            }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isScout()
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
        }
        finishHamartansoldier() {
            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    soundCancel()
                    testroom.play()
                }
            }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isHamartansoldier()
        }
        finishHamartanscout() {
            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    soundCancel()
                }
            }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isHamartanscout()
        }
        finishLibrilbianpollinator() {
            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    soundCancel()
                    pollinatoraudio.play()
                }
            }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isPollinator()
        }
        finishLibrilbianpodman() {
            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    soundCancel()
                    youworkforme.play()
                }
            }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isPodman()
        }
        finishLibrilbiangoliophyte() {
            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    soundCancel()
                    golophyteaudio.play()
                }
            }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isGoliophyte()
        }
        finishLibrilbianpufffellow() {
            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    soundCancel()
                    pufffellowaudio.play()
                }
            }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isPufffellow()
        }
        finishAvesectianflugoon() {

            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    avesounds[Math.floor(Math.random() * (avesounds.length - 2))].play()
                }
            }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isFlugoon()
            if (this.selected == 1) {
                // agent1.selected  = 1
            }
        }
        finishGogonaut() {

            // if (Math.random() < soundspamdrop) {
            //     if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
            //         avesounds[Math.floor(Math.random() * (avesounds.length - 2))].play()
            //     }
            // }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isGogonaut()
            if (this.selected == 1) {
                // agent1.selected  = 1
            }
        }
        finishGogonautChampion() {

            // if (Math.random() < soundspamdrop) {
            //     if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
            //         avesounds[Math.floor(Math.random() * (avesounds.length - 2))].play()
            //     }
            // }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isGogonautChampion()
            if (this.selected == 1) {
                // agent1.selected  = 1
            }
        }
        finishBeeWorker(){
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isBeeWorker()

            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    soundCancel()
                    beeaudio8.play()
                }
            }
        }
        finishBeeMega(){
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isBeeMega()
            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    soundCancel()
                    beeaudio9.play()
                }
            }
        }
        finishBeeScout(){
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isBeeScout()
            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    soundCancel()
                    beeaudio5.play()
                }
            }
        }
        finishBeeSoldier(){
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isBeeSoldier()
            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    soundCancel()
                    beeaudio4.play()
                }
            }
        }

        finishGogonautDefender() {

            // if (Math.random() < soundspamdrop) {
            //     if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
            //         avesounds[Math.floor(Math.random() * (avesounds.length - 2))].play()
            //     }
            // }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isGogonautDefender()
            if (this.selected == 1) {
                // agent1.selected  = 1
            }
        }
        finishGogonautTeam() {

            // if (Math.random() < soundspamdrop) {
            //     if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
            //         avesounds[Math.floor(Math.random() * (avesounds.length - 2))].play()
            //     }
            // }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isGogonautTeam()
            if (this.selected == 1) {
                // agent1.selected  = 1
            }
        }
        finishAvesectianmegaagnat() {

            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    avesounds[Math.floor(Math.random() * (avesounds.length - 2))].play()
                }
            }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isMegagnat()
            if (this.selected == 1) {
                // agent1.selected  = 1
            }
        }
        finishAvesectianstarbatross() {
            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    avesounds[Math.floor(Math.random() * (avesounds.length - 2))].play()
                }
            }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isStarbatross()
            if (this.selected == 1) {
                // agent1.selected  = 1
            }
        }
        makeGogonaut() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 70 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 70
                    this.que = 1
                    this.gogonautunit = 1
                    this.timer = 75 //70
                    this.maxtimer = this.timer
                }
            } else {
                if (this.faction.hotrock >= 70 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 70
                    this.que = 1
                    this.loaded.push('gogonautunit')
                    this.times.push(75)
                }
            }
        }
        makeBeeWorker() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 100 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 100
                    this.que = 1
                    this.beeworker = 1
                    this.timer = 75 //70
                    this.maxtimer = this.timer
                }
            } else {
                if (this.faction.hotrock >= 100 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 100
                    this.que = 1
                    this.loaded.push('beeworker')
                    this.times.push(75)
                }
            }
        }
        makeBeeScout() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 100 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 100
                    this.que = 1
                    this.beescout = 1
                    this.timer = 40 //70
                    this.maxtimer = this.timer
                }
            } else {
                if (this.faction.hotrock >= 100 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 100
                    this.que = 1
                    this.loaded.push('beescout')
                    this.times.push(40)
                }
            }
        }
        makeBeeMega() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 450 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 450
                    this.que = 1
                    this.beemega = 1
                    this.timer = 300 //70
                    this.maxtimer = this.timer
                }
            } else {
                if (this.faction.hotrock >= 450 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 450
                    this.que = 1
                    this.loaded.push('beemega')
                    this.times.push(300)
                }
            }
        }
        makeBeeSoldier() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 230 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 230
                    this.que = 1
                    this.beesoldier = 1
                    this.timer = 175 //70
                    this.maxtimer = this.timer
                }
            } else {
                if (this.faction.hotrock >= 230 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 230
                    this.que = 1
                    this.loaded.push('beesoldier')
                    this.times.push(175)
                }
            }
        }
        makeGogonautTeam() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 110 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 110
                    this.que = 1
                    this.gogonautteam = 1
                    this.timer = 120 //70
                    this.maxtimer = this.timer
                }
            } else {
                if (this.faction.hotrock >= 110 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 110
                    this.que = 1
                    this.loaded.push('gogonautteam')
                    this.times.push(120)
                }
            }
        }
        makeGogonautChampion() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 360 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 360
                    this.que = 1
                    this.gogonautchampion = 1
                    this.timer = 300 //70
                    this.maxtimer = this.timer
                }
            } else {

                if (this.faction.hotrock >= 360 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 360
                    this.que = 1
                    this.loaded.push('gogonautchampion')
                    this.times.push(300)
                }
            }
        }
        makeGogonautDefender() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 210 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 210
                    this.que = 1
                    this.gogonautdefender = 1
                    this.timer = 210 //70
                    this.maxtimer = this.timer
                }
            } else {

                if (this.faction.hotrock >= 210 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 210
                    this.que = 1
                    this.loaded.push('gogonautdefender')
                    this.times.push(210)
                }
            }
        }
        makeAlagadile() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 50 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 50
                    this.que = 1
                    this.babyalagadile = 1
                    this.timer = 77 //70
                    this.maxtimer = this.timer
                }
            } else {
                if (this.faction.hotrock >= 50 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 50
                    this.que = 1
                    this.loaded.push('babyalagadile')
                    this.times.push(77)
                }
            }
        }
        makeBigAlagadile() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 160 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 160
                    this.que = 1
                    this.bigalagadile = 1
                    this.timer = 155 //70
                    this.maxtimer = this.timer
                }
            } else {

                if (this.faction.hotrock >= 160 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 160
                    this.que = 1
                    this.loaded.push('bigalagadile')
                    this.times.push(155)
                }
            }
        }
        makeBigHunchAlagadile() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 200 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 200
                    this.que = 1
                    this.bighunchalagadile = 1
                    this.timer = 222 //70
                    this.maxtimer = this.timer
                }
            } else {
                if (this.faction.hotrock >= 200 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 200
                    this.que = 1
                    this.loaded.push('bighunchalagadile')
                    this.times.push(222)
                }

            }
        }
        makeHunchAlagadile() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 90 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 90
                    this.que = 1
                    this.hunchalagadile = 1
                    this.timer = 122 //70
                    this.maxtimer = this.timer
                }
            } else {
                if (this.faction.hotrock >= 90 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 90
                    this.que = 1
                    this.loaded.push('hunchalagadile')
                    this.times.push(122)
                }

            }
        }


        hatchBuzzlet() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 90 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 90
                    this.que = 1
                    this.buzzlet = 1
                    this.timer = 22 //70
                    this.maxtimer = this.timer
                }
            }
        }
        hatchMegagnat() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 130 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 130
                    this.que = 1
                    this.megagnat = 1
                    this.timer = 70 //70
                    this.maxtimer = this.timer
                }
            }
        }
        hatchFlugoon() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 180 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 180
                    this.que = 1
                    this.flugoon = 1
                    this.timer = 90 //70
                    this.maxtimer = this.timer
                }
            }
        }
        hatchStarbatross() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 180 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 180
                    this.que = 1
                    this.starbatross = 1
                    this.timer = 90 //70
                    this.maxtimer = this.timer
                }
            }
        }
        finishAvesectianbuzzlet() {
            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    avesounds[Math.floor(Math.random() * (avesounds.length - 2))].play()
                }
            }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isBuzzlet()
            if (this.selected == 1) {
                // agent1.selected  = 1
            }
        }
        finishAlagadile() {
            //     if (Math.random() < soundspamdrop) {
            //         if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
            //             avesounds[Math.floor(Math.random()*(avesounds.length-2))].play()
            //     }
            // }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isAlagadile()
        }
        finishBigAlagadile() {
            //     if (Math.random() < soundspamdrop) {
            //         if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
            //             avesounds[Math.floor(Math.random()*(avesounds.length-2))].play()
            //     }
            // }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isBigAlagadile()
        }
        finishBigHunchAlagadile() {
            //     if (Math.random() < soundspamdrop) {
            //         if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
            //             avesounds[Math.floor(Math.random()*(avesounds.length-2))].play()
            //     }
            // }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isBigHunchAlagadile()
        }
        finishHunchAlagadile() {
            //     if (Math.random() < soundspamdrop) {
            //         if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
            //             avesounds[Math.floor(Math.random()*(avesounds.length-2))].play()
            //     }
            // }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isHunchAlagadile()
        }
        finishHamartaninvader() {
            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    soundCancel()
                    iamerror.play()
                }
            }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isHamartaninvader()
        }
        finishHamartanworker() {
            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    soundCancel()
                }
            }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isHamartanworker()
        }
        makeInfantry() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 85 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 85
                    //////////console.log("?idr")
                    this.que = 1
                    this.infantry = 1
                    this.timer = 45 //70
                    this.maxtimer = this.timer
                }
            } else {
                if (this.faction.hotrock >= 85 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 85
                    //////////console.log("?idr")
                    this.que = 1
                    this.loaded.push("infantry")
                    this.times.push(45)
                }

            }
        }
        makeSniper() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 195 && this.faction.units.length < (unitcap)) {
                    //////////console.log("?dr")
                    this.faction.hotrock -= 195
                    this.que = 1
                    this.sniper = 1
                    this.timer = 200
                    this.maxtimer = this.timer
                }
            } else {

                if (this.faction.hotrock >= 195 && this.faction.units.length < (unitcap)) {
                    //////////console.log("?dr")
                    this.faction.hotrock -= 195
                    this.que = 1
                    this.loaded.push("sniper")
                    this.times.push(200)
                }
            }
        }
        finishInfantry() {
            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    soundCancel()
                    reporting.play()
                }
            }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isInfantry()
        }
        finishSniper() {
            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    soundCancel()
                    if (Math.random() < .5) {
                        youunderstandany.play()
                    } else {
                        idontunderstand.play()
                    }
                }
            }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isSniper()
        }
        makeHarvester() {

            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 190 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 190
                    //////////console.log("?hdr")
                    this.que = 1
                    this.harvester = 1
                    this.timer = 220 //140
                    this.maxtimer = this.timer
                }
            } else {
                if (this.faction.hotrock >= 190 && this.faction.units.length < (unitcap)) {
                    this.faction.hotrock -= 190
                    //////////console.log("?hdr")
                    this.que = 1
                    this.loaded.push("harvester")
                    this.times.push(220)  //140
                }

            }


        }
        finishHarvester() {
            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    soundCancel()
                    systems.play()
                }
            }
            const agent1 = new Agent(this.tile, this.faction)
            agent1.shouldMove = 1
            agent1.ultrabreak = this.waypoint
            agent1.ultrawalk = 0
            agent1.isHarvester()
        }

        dataOutput() {
            //moved
        }
        async slimecheck() {
            this.slimeossify++
            if (this.active == 1) {

                if (this.tile.sourcerock > 0) {
                    // if(this.tile.sourcerock > 0){
                    //     this.tile.sourcerock -= .09
                    //     this.faction.hotrock += .09
                    // }

                    // if(Math.random()<.03){
                    let sum = 0

                    let sporeballblock = {}
                    let max = 9999999999
                    let wet = 0
                    for (let t = 0; t < this.faction.buildings.length; t++) {
                        if (this.faction.buildings[t].sporeball == 1) {
                            let dis = (Math.abs(this.tile.k - this.faction.buildings[t].tile.k)) + (Math.abs(this.tile.t - this.faction.buildings[t].tile.t))
                            if (dis < max) {
                                max = dis
                                sporeballblock = this.faction.buildings[t].tile
                                wet = 1
                            }

                        }
                    }
                    if (wet == 1) {
                        sandmap.diagonal = false
                        sandmap.slimeflag = 1
                        const path = await [...this.pather.search(sandmap, this.tile, sporeballblock, {})]
                        sandmap.slimeflag = 0
                        sandmap.diagonal = true
                        sum += path.length
                    }
                    if (sum == 0) {
                        this.active = 0
                        this.tile.primed = 0
                    } else {

                        this.tile.primed = 1
                    }
                    // }
                }
            } else if (this.active == 0) {

                if (this.tile.sourcerock > 0) {

                    let sporeballblock = {}
                    let max = 9999999999
                    let wet = 0
                    for (let t = 0; t < this.faction.buildings.length; t++) {
                        if (this.faction.buildings[t].sporeball == 1) {
                            let dis = (Math.abs(this.tile.k - this.faction.buildings[t].tile.k)) + (Math.abs(this.tile.t - this.faction.buildings[t].tile.t))
                            if (dis < max) {
                                max = dis
                                sporeballblock = this.faction.buildings[t].tile
                                wet = 1
                            }

                        }
                    }
                    if (wet == 1) {
                        sandmap.diagonal = false
                        sandmap.slimeflag = 1
                        const path = await [...this.pather.search(sandmap, this.tile, sporeballblock, {})]
                        sandmap.slimeflag = 0
                        sandmap.diagonal = true
                        if (path.length > 0) {
                            this.active = 1
                            this.tile.primed = 1
                        } else {

                            this.tile.primed = 0
                        }
                    }
                }
            }
        }
        runSelf() {


            // if (this.selected == 1 || this.selected == 2 || globalHealthDraw == true) {
            //     if (sandmap.turn == sandmap.players.indexOf(this.faction) || globalHealthDraw == true) {
            //         // this.dataOutput()
            //         this.healthbar = new Rectangle(this.body.x - 5.5, this.body.y + 2.5, 11, 3, "black")
            //         this.healthbar.draw()
            //         if (this.health / this.maxhealth > .5) {
            //             this.healthbar = new Rectangle(this.body.x - 5, this.body.y + 3, (this.health / this.maxhealth) * 10 * Math.sqrt(this.tiles.length), 2, `rgb(${(1 - ((this.health / this.maxhealth))) * 512},${255},  0)`)
            //         } else {
            //             this.healthbar = new Rectangle(this.body.x - 5, this.body.y + 3, (this.health / this.maxhealth) * 10* Math.sqrt(this.tiles.length), 2, `rgb(${255},${(((this.health / this.maxhealth) * 1)) * 512},  0)`)
            //         }
            //         this.healthbar.draw()
            //     }
            //     // this.draw()
            // } 
            if (this.teleporter == 1 ) {     
                 for (let t = 0; t < this.tiles.length; t++) {
                this.tiles[t].walkable = true
            }
            }
            if (this.tile.sourcerock > 0) {
                this.rocked = 1
            } else {
                if (this.rocked == 1) {
                    this.first = 1
                    this.rocked = 0
                }
            }

            if (this.first == 1) {
                if (this.animated != 1) {
                    this.first = 0
                }
                this.draw()
            }
            if(onlineNow == 1 && sandmap.players.indexOf(this.faction) != sandmap.turn){
                return
            }

            if(this.dying > 0 || this.health <= 0){
                sandmap.buildingCanvas_context.clearRect(this.tile.x, this.tile.y, this.tile.width + (this.size * 1 * this.tile.width), this.tile.height + (this.size * 1 * this.tile.height))
            for (let t = 0; t < this.tiles.length; t++) {
                this.tiles[t].walkable = true
                this.tiles[t].builtOn = true
            }
            return
            }
            

            if (this.selected == 1 || this.selected == 2) {

                map_context.strokeStyle = this.faction.color
                map_context.lineWidth = .7
                map_context.strokeRect(this.tile.x, this.tile.y, this.tile.width + (this.size * 1 * this.tile.width), this.tile.height + (this.size * 1 * this.tile.height))
            }

            if (this.selected == 1) {
                this.waylink.x2 = this.waypoint.x + 5
                this.waylink.y2 = this.waypoint.y + 5
                this.waylink.draw()
            }

            if (this.faction.slimeflag == 1) {
                this.slimeflag = 1
            }
            if (this.wallflag == 1) {
                this.tile.wallflag = 1
            }
            this.slimeconstant++
            if (this.slimeflag == 1) {
                if (this.slimeconstant % this.slimeossify == 0) {
                    this.slimecheck()
                    this.slimeflag = 0
                }
            }

            if (this.active == 1) {

                if (this.tile.sourcerock > 0) {
                    this.tile.sourcerock -= .09
                    this.faction.hotrock += .09
                    this.faction.income += .09
                }

            }
            //////////console.log(this)
            if (this.bulbplant == 1 || this.slime == 1) {
                this.sight = 10
                if (this.slime == 1) {
                    this.sight = 1
                }
                if (this.slime != 1) {
                    this.seetime++
                    if (this.seetime % 44 == 0) {
                        this.see()
                    }

                } else {
                    this.seetime++
                    if (this.seetime % 99 == 0) {
                        this.see()
                    }
                }
            }
            if (this.que != 0) {
                this.first = 1
                this.animated = 1
            } else {
                if (this.assembler != 1) {
                    this.animated = 0
                }
            }
            if (this.barracks >= 1 || this.assembler >= 1 || this.bulbplant >= 1 || this.slime == 1 || this.egg == 1 || this.pond == 1 || this.tree == 1 || this.beehive == 1) {
                this.timer--
                if (this.timer == 0) {
                    if (this.faction.units.length < unitcap) {
                        if (this.seer == 1) {
                            this.que = 0
                            this.seer = 0
                            this.finishSporeseer()
                        } else if (this.vizier == 1) {
                            this.que = 0
                            this.vizier = 0
                            this.finishVizier()
                        } else if (this.knight == 1) {
                            this.que = 0
                            this.knight = 0
                            this.finishMycoknight()
                        } else if (this.buddy == 1) {
                            this.que = 0
                            this.buddy = 0
                            this.finishFruitingbuddy()
                        } else if (this.drone == 1) {
                            this.que = 0
                            this.drone = 0
                            this.finishScout()
                        } else if (this.infantry == 1) {
                            this.infantry = 0
                            this.que = 0
                            this.finishInfantry()
                        } else if (this.harvester == 1) {
                            this.harvester = 0
                            this.que = 0
                            this.finishHarvester()
                        } else if (this.sniper == 1) {
                            this.sniper = 0
                            this.que = 0
                            this.finishSniper()
                        } else if (this.soldier == 1) {
                            this.soldier = 0
                            this.que = 0
                            this.finishHamartansoldier()
                        } else if (this.scout == 1) {
                            this.scout = 0
                            this.que = 0
                            this.finishHamartanscout()
                        }
                        if (this.worker == 1) {
                            this.worker = 0
                            this.que = 0
                            this.finishHamartanworker()
                        } else if (this.invader == 1) {
                            this.invader = 0
                            this.que = 0
                            this.finishHamartaninvader()
                        } else if (this.pollinator == 1) {
                            this.pollinator = 0
                            this.que = 0
                            this.finishLibrilbianpollinator()
                        } else if (this.podman == 1) {
                            this.podman = 0
                            this.que = 0
                            this.finishLibrilbianpodman()
                        } else if (this.goliophyte == 1) {
                            this.goliophyte = 0
                            this.que = 0
                            this.finishLibrilbiangoliophyte()
                        } else if (this.pufffellow == 1) {
                            this.pufffellow = 0
                            this.que = 0
                            this.finishLibrilbianpufffellow()
                        } else if (this.babyalagadile == 1) {
                            this.babyalagadile = 0
                            this.que = 0
                            this.finishAlagadile()
                        } else if (this.bigalagadile == 1) {
                            this.bigalagadile = 0
                            this.que = 0
                            this.finishBigAlagadile()
                        } else if (this.hunchalagadile == 1) {
                            this.hunchalagadile = 0
                            this.que = 0
                            this.finishHunchAlagadile()
                        } else if (this.bighunchalagadile == 1) {
                            this.bighunchalagadile = 0
                            this.que = 0
                            this.finishBigHunchAlagadile()
                        } else if (this.buzzlet == 1) {
                            this.health = 0
                            this.finishAvesectianbuzzlet()
                        } else if (this.flugoon == 1) {
                            this.health = 0
                            this.finishAvesectianflugoon()
                        } else if (this.megagnat == 1) {
                            this.health = 0
                            this.finishAvesectianmegaagnat()
                        } else if (this.starbatross == 1) {
                            this.health = 0
                            this.finishAvesectianstarbatross()
                        } else if (this.gogonautunit == 1) {
                            this.gogonautunit = 0
                            this.que = 0
                            this.finishGogonaut()
                        } else if (this.gogonautchampion == 1) {
                            this.gogonautchampion = 0
                            this.que = 0
                            this.finishGogonautChampion()
                        } else if (this.gogonautdefender == 1) {
                            this.que = 0
                            this.gogonautdefender = 0
                            this.finishGogonautDefender()
                        } else if (this.gogonautteam == 1) {
                            this.gogonautteam = 0
                            this.que = 0
                            this.finishGogonautTeam()
                        }else if (this.beeworker == 1) {
                            this.beeworker = 0
                            this.que = 0
                            this.finishBeeWorker()
                        }else if (this.beesoldier == 1) {
                            this.beesoldier = 0
                            this.que = 0
                            this.finishBeeSoldier()
                        }else if (this.beemega == 1) {
                            this.beemega = 0
                            this.que = 0
                            this.finishBeeMega()
                        }else if (this.beescout == 1) {
                            this.beescout = 0
                            this.que = 0
                            this.finishBeeScout()
                        }
                    } else {
                        this.timer = 1
                    }
                    if (this.loaded.length > 0 && this.faction.isAI != 1) {
                        this[this.loaded[0]] = 1
                        this.timer = this.times[0]
                        this.maxtimer = this.times[0]
                        this.que = 1
                        this.loaded.splice(0, 1)
                        this.times.splice(0, 1)
                    }
                }
            }


            if (this.mound == 1) {
                this.eggtimer--
                if (this.eggtimer <= 0) {
                    for (let t = -1; t <= 1; t++) {
                        for (let k = -1; k <= 1; k++) {
                            if (this.tile.t + t >= 0) {
                                if (this.tile.k + k >= 0) {
                                    if (this.tile.t + t < worldscale) {
                                        if (this.tile.k + k < worldscale) {
                                            if (this.eggtimer <= 0) {
                                                if (this.faction.buildEgg((sandmap.blocks[this.tile.t + t][this.tile.k + k]))) {
                                                    this.eggtimer = 300
                                                    break
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    // for (let t = -2; t <= 2; t++) {
                    //     for (let k = -2; k <= 2; k++) {
                    //         if (this.tile.t + t >= 0) {
                    //             if (this.tile.k + k >= 0) {
                    //                 if (this.tile.t + t < worldscale) {
                    //                     if (this.tile.k + k < worldscale) {
                    //                         if(this.eggtimer <= 0){
                    //                         if(this.faction.buildEgg((sandmap.blocks[this.tile.t+t][this.tile.k+k]))){
                    //                             this.eggtimer = 300
                    //                             break
                    //                         }
                    //                     }
                    //                     }
                    //                 }
                    //             }
                    //         }
                    //     }
                    // }
                }
            }












            for (let t = 0; t < this.tiles.length; t++) {
                this.tiles[t].walkable = false

                if (this.open == 1) {
                    // this.tiles[t].builtOn = 0
                    this.tiles[t].walkable = true
                }
                if (this.open == -1) {
                    // this.tiles[t].builtOn = 1
                    this.tiles[t].walkable = false
                }

                if (this.slime == 1) {
                    this.tiles[t].builtOn = 1
                    this.tiles[t].walkable = true
                }

            }

            if (this.teleporter == 1 ) {     
                 for (let t = 0; t < this.tiles.length; t++) {
                this.tiles[t].walkable = true
            }
            }
        }
        draw() {

            sandmap.buildingCanvas_context.clearRect(this.tile.x, this.tile.y, this.tile.width + (this.size * 1 * this.tile.width), this.tile.height + (this.size * 1 * this.tile.height))



            // if (this.tile.wallflag == 1 || (((this.tile.walkable == false) || (this.tile.walkable == true && this.tile.spiretile >= 1)) && this.tile.builtOn == 1 && !(this.tile.hotrock >= 1))) {
                if(this.wall == 1 || this.barracks > 0 || this.gate == 1){
                this.tile.color = this.faction.color
                if (this.tile.spiretile >= 1) {
                    this.tile.color = "transparent"
                }
                if (typeof this.tile.wallcolor != "undefined") {
                    sandmap.buildingCanvas_context.fillStyle = this.tile.color
                    sandmap.buildingCanvas_context.fillRect(this.tile.x, this.tile.y, this.tile.width + (this.size * 1 * this.tile.width), this.tile.height + (this.size * 1 * this.tile.height))
                } else {
                    sandmap.buildingCanvas_context.fillStyle = this.tile.color  //may not be else?
                    sandmap.buildingCanvas_context.fillRect(this.tile.x, this.tile.y, this.tile.width + (this.size * 1 * this.tile.width), this.tile.height + (this.size * 1 * this.tile.height))
                }
            }

            for (let t = 0; t < this.tiles.length; t++) {
                this.tiles[t].walkable = false

                if (this.open == 1) {
                    // this.tiles[t].builtOn = 0
                    this.tiles[t].walkable = true
                }
                if (this.open == -1) {
                    // this.tiles[t].builtOn = 1
                    this.tiles[t].walkable = false
                }

                if (this.slime == 1) {
                    this.tiles[t].builtOn = 1
                    this.tiles[t].walkable = true
                }
                this.tiles[t].color = this.faction.color  // this.faction.color

                if (this.selected == 1) {
                    this.tiles[t].wallcolor = "black"
                } else {
                    // this.tiles[t].wallcolor = this.faction.color
                    this.tiles[t].wallcolor = "transparent"
                }
            }
            if (true) {

                if(this.bee == 1){
                    if (this.beehive == 1) {
                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {

                            if (this.que != 1) {
                                sandmap.buildingCanvas_context.drawImage(beehiveimg, 0, 0, 20, 20, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            }else{
                                sandmap.buildingCanvas_context.drawImage(beehiveimg, (20 * ((this.maxtimer - this.timer) % 12)), 0, 20, 20, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            }
                        }else{

                            if (this.que != 1) {
                                sandmap.buildingCanvas_context.drawImage(beehiveimg, 0, 0, 20, 20, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            }else{
                                sandmap.buildingCanvas_context.drawImage(beehiveimg, (20 * ((this.maxtimer - this.timer) % 12)), 0, 20, 20, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            }
                        }
                    }

                }else if (this.gogo == 1) {
                    if (this.tree == 1) {
                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {

                            if (this.que != 1) {
                                sandmap.buildingCanvas_context.drawImage(gogonauttree, 0, 0, 20, 20, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            } else {
                                sandmap.buildingCanvas_context.drawImage(gogonauttree, (20 * ((this.maxtimer - this.timer) % 26)), 0, 20, 20, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            }

                        } else {

                            if (this.que != 1) {
                                sandmap.buildingCanvas_context.drawImage(gogonauttreesheetinv, 0, 0, 20, 20, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            } else {
                                sandmap.buildingCanvas_context.drawImage(gogonauttreesheetinv, (20 * ((this.maxtimer - this.timer) % 26)), 0, 20, 20, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            }

                        }
                    }
                } else if (this.ave == 1) {
                    if (this.mound == 1) {
                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                            sandmap.buildingCanvas_context.drawImage(eggmound, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                        } else {

                            sandmap.buildingCanvas_context.drawImage(eggmoundinv, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                        }
                    } else if (this.egg == 1) {

                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                            if (this.que != 1) {
                                sandmap.buildingCanvas_context.drawImage(aveegg, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            } else {
                                    const segs = this.maxtimer/16
                                    const frame = (15-Math.min(Math.floor(this.timer/segs),15))
                                    sandmap.buildingCanvas_context.drawImage(aveeggsheet, 10*frame, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                                
                            }
                        } else {

                            if (this.que != 1) {
                                sandmap.buildingCanvas_context.drawImage(aveegginv, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            } else {
                                    const segs = this.maxtimer/16
                                    const frame = (15-Math.min(Math.floor(this.timer/segs),15))
                                    sandmap.buildingCanvas_context.drawImage(aveeggsheetinv, 10*frame, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                                
                            }


                        }
                    }
                } else {

                    if(this.teleporter == 1){
                                sandmap.buildingCanvas_context.drawImage(teleporterimg, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))

                    }else if (this.pond == 1) {
                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {

                            if (this.que != 1) {
                                sandmap.buildingCanvas_context.drawImage(pond, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            } else {
                                if (this.timer >= this.maxtimer - 8) {
                                    sandmap.buildingCanvas_context.drawImage(pond, (10 * (this.maxtimer - this.timer)), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                                } else {
                                    sandmap.buildingCanvas_context.drawImage(pond, 70 + (10 * ((this.maxtimer - this.timer) % 4)), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                                }
                            }
                        } else {
                            if (this.que != 1) {
                                sandmap.buildingCanvas_context.drawImage(pondinv, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            } else {
                                if (this.timer >= this.maxtimer - 8) {
                                    sandmap.buildingCanvas_context.drawImage(pondinv, (10 * (this.maxtimer - this.timer)), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                                } else {
                                    sandmap.buildingCanvas_context.drawImage(pondinv, 70 + (10 * ((this.maxtimer - this.timer) % 4)), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                                }
                            }
                        }
                    } else if (this.barracks == 1) {
                        if (this.que != 1) {
                            sandmap.buildingCanvas_context.drawImage(barracks, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                        } else {
                            if (this.timer >= this.maxtimer - 7) {
                                sandmap.buildingCanvas_context.drawImage(barracks, (10 * (this.maxtimer - this.timer)), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            } else {
                                sandmap.buildingCanvas_context.drawImage(barracks, 70 + (10 * ((this.maxtimer - this.timer) % 7)), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            }
                        }
                    } else if (this.barracks == 2) {
                        if (this.que != 1) {
                            sandmap.buildingCanvas_context.drawImage(machinelab, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                        } else {
                            if (this.timer >= this.maxtimer - 6) {
                                sandmap.buildingCanvas_context.drawImage(machinelab, (10 * (this.maxtimer - this.timer)), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            } else {
                                sandmap.buildingCanvas_context.drawImage(machinelab, 60 + (10 * ((this.maxtimer - this.timer) % 6)), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            }

                        }


                    } else if (this.sporeball == 1) {
                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                            sandmap.buildingCanvas_context.drawImage(sporeball, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                        } else {

                            sandmap.buildingCanvas_context.drawImage(sporeballinv, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                        }
                    } else if (this.slime == 1) {
                        if (this.tile.sourcerock > 0) {
                            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                                sandmap.buildingCanvas_context.drawImage(hotslime, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            } else {
                                sandmap.buildingCanvas_context.drawImage(hotslimeinv, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))

                            }
                        } else {

                            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                                if (this.que != 1) {
                                    sandmap.buildingCanvas_context.drawImage(slime, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                                } else {
                                    sandmap.buildingCanvas_context.drawImage(slime, 0 + (10 * ((this.maxtimer - this.timer) % 10)), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                                }
                            } else {
                                if (this.que != 1) {
                                    sandmap.buildingCanvas_context.drawImage(slimeinv, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                                } else {
                                    sandmap.buildingCanvas_context.drawImage(slimeinv, 0 + (10 * ((this.maxtimer - this.timer) % 10)), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                                }
                            }





                            // this.tiles[t].color = this.faction.color  // this.faction.color
                            // this.tiles[t].draw()



                        }
                    } else if (this.spire == 1) {
                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                            sandmap.buildingCanvas_context.drawImage(spire, (this.tiles[0].counter % 5) * 10, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            // this.body.draw()
                            // this.bodybig.draw()
                            this.tile.aura = 1
                            this.tile.bodybig = this.bodybig
                            this.tile.bodyx = this.body2
                        } else {
                            sandmap.buildingCanvas_context.drawImage(spireinv, (this.tiles[0].counter % 5) * 10, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            this.tile.aura = 1
                            this.tile.bodybig = this.bodybig
                            this.tile.bodyx = this.body2
                        }
                    } else if (this.assembler == 1) {

                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                            sandmap.buildingCanvas_context.drawImage(assembler1, (this.tiles[0].counter % 10), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                        } else {
                            sandmap.buildingCanvas_context.drawImage(assembler1inv, (this.tiles[0].counter % 10), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))

                        }
                    } else if (this.assembler == 2) {
                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {

                            if (this.que != 1) {
                                sandmap.buildingCanvas_context.drawImage(assembler2, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            } else {
                                if (this.timer >= this.maxtimer - 12) {
                                    sandmap.buildingCanvas_context.drawImage(assembler2, (10 * (this.maxtimer - this.timer)), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                                } else {
                                    sandmap.buildingCanvas_context.drawImage(assembler2, 120 + (10 * ((this.maxtimer - this.timer) % 6)), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                                }

                            }
                        } else {
                            if (this.que != 1) {
                                sandmap.buildingCanvas_context.drawImage(assembler2inv, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            } else {
                                if (this.timer >= this.maxtimer - 12) {
                                    sandmap.buildingCanvas_context.drawImage(assembler2inv, (10 * (this.maxtimer - this.timer)), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                                } else {
                                    sandmap.buildingCanvas_context.drawImage(assembler2inv, 120 + (10 * ((this.maxtimer - this.timer) % 6)), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                                }

                            }

                        }
                    } else if (this.assembler == 3) {

                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {

                            if (this.que != 1) {
                                sandmap.buildingCanvas_context.drawImage(assembler3, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            } else {
                                if (this.timer >= this.maxtimer - 19) {
                                    sandmap.buildingCanvas_context.drawImage(assembler3, (10 * (this.maxtimer - this.timer)), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                                } else {
                                    sandmap.buildingCanvas_context.drawImage(assembler3, 190 + (10 * ((this.maxtimer - this.timer) % 10)), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                                }

                            }
                        } else {
                            if (this.que != 1) {
                                sandmap.buildingCanvas_context.drawImage(assembler3inv, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            } else {
                                if (this.timer >= this.maxtimer - 19) {
                                    sandmap.buildingCanvas_context.drawImage(assembler3inv, (10 * (this.maxtimer - this.timer)), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                                } else {
                                    sandmap.buildingCanvas_context.drawImage(assembler3inv, 190 + (10 * ((this.maxtimer - this.timer) % 10)), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                                }

                            }
                        }
                    } else if (this.bulbplant == 1) {
                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {

                            if (this.que != 1) {
                                sandmap.buildingCanvas_context.drawImage(librilbianbulbplant, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            } else {
                                sandmap.buildingCanvas_context.drawImage(librilbianbulbplant, 0 + (10 * ((this.maxtimer - this.timer) % 11)), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            }
                        } else {

                            if (this.que != 1) {
                                sandmap.buildingCanvas_context.drawImage(librilbianbulbplantinv, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            } else {
                                sandmap.buildingCanvas_context.drawImage(librilbianbulbplantinv, 0 + (10 * ((this.maxtimer - this.timer) % 11)), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            }
                        }
                    } else if (this.bulbplant == 2) {

                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {

                            if (this.que != 1) {
                                sandmap.buildingCanvas_context.drawImage(librilbianpodmother, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            } else {
                                sandmap.buildingCanvas_context.drawImage(librilbianpodmother, 0 + (10 * ((this.maxtimer - this.timer) % 8)), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            }
                        } else {
                            if (this.que != 1) {
                                sandmap.buildingCanvas_context.drawImage(librilbianpodmotherinv, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            } else {
                                sandmap.buildingCanvas_context.drawImage(librilbianpodmotherinv, 0 + (10 * ((this.maxtimer - this.timer) % 8)), 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                            }
                        }
                    } else if (this.gate == 1) {
                        if (this.open == -1) {
                            sandmap.buildingCanvas_context.drawImage(closedgate, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                        } else {
                            sandmap.buildingCanvas_context.drawImage(opengate, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                        }
                    } else {
                        sandmap.buildingCanvas_context.drawImage(icewall, 0, 0, 10, 10, this.tiles[0].x, this.tiles[0].y, 10 + (this.size * 1 * 10), 10 + (this.size * 1 * 10))
                    }
                }

            }
            if (this.selected == 1) {
                if (sandmap.turn == sandmap.players.indexOf(this.faction)) {
                    // this.dataOutput()
                }
            } else {
                // this.spawnsmall = new UiRectangle(0, 0, 0, 0, "red")
                this.spawnmedium = new UiRectangle(0, 0, 0, 0, "red")
                this.spawnbig = new UiRectangle(0, 0, 0, 0, "red")
                this.spawnlast = new UiRectangle(0, 0, 0, 0, "red")
            }

        }
        clean() {
            if (this.health <= 0) {
                        this.dying++
                        //////////console.log("hit")
                sandmap.buildingCanvas_context.clearRect(this.tile.x, this.tile.y, this.tile.width + (this.size * 1 * this.tile.width), this.tile.height + (this.size * 1 * this.tile.height))
            this.faction.sendBuildings = 1
                if (this.dying >= 20) {
                    
                this.tile.walkable = 1
                this.tile.color = "#AACCFF"
                delete this.tile.wallcolor
                if (this.barracks == 1) {
                    this.faction.racks = 0
                }
                if (this.assembler == 3) {
                    this.faction.racks = 0
                }
                if (this.assembler == 1) {
                    this.faction.lab = 0
                }
                if (this.assembler == 2) {
                    this.faction.lab = 0
                }
                if (this.barracks == 2) {
                    this.faction.lab = 0
                }
                if (this.bulbplant == 1) {
                    this.faction.racks = 0
                }
                if (this.sporeball == 1) {
                    this.faction.racks = 0
                    this.faction.slimeflag = 1
                }
                if (this.bulbplant == 2) {
                    this.faction.lab = 0
                }

                this.tile.spiretile = 0
                this.tile.builtOn = 0

                if (this.tile.slime == true) {
                    this.faction.slimeflag = 1
                }
                for (let t = 0; t < this.tiles.length; t++) {
                    this.tiles[t].builtOn = 0
                    this.tiles[t].walkable = true
                }
                this.tile.slime = false
                this.tile.dirt = 0
                this.tile.faction = -1
                this.tile.wallflag = 0
                this.tile.aura = 0
                sandmap.backgroundcheck = 1
                // sandmap.buildingCanvas_context.clearRect(this.tile.x, this.tile.y, this.tile.width+(this.size*1*this.tile.width), this.tile.height+(this.size*1*this.tile.height))
                sandmap.buildingCanvas_context.clearRect(this.tile.x, this.tile.y, this.tile.width + (this.size * 1 * this.tile.width), this.tile.height + (this.size * 1 * this.tile.height))
                this.faction.buildings.splice(this.faction.buildings.indexOf(this), 1)
            }
        }
        }
    }
    class Agent {
        constructor(tile, player) {
            if(player.type == 11){
                return
            }   
            this.factionNum = sandmap.players.indexOf(player)
            this.agent = 1
            this.decay = 200
            this.walkcounter = 0
            this.awaiting = 0
            this.stepoutBonus = 0
            this.loaded = []
            this.times = []
            this.patrolling = -1
            this.timeoutforAsync = 0
            this.stack = 8000
            this.id = (player.createdCount/500)
            player.createdCount++
            if(player.createdCount >= 500){
                faction.createdCount += .5
                let c = 0
                for(let t = 0;t<player.units.length;t++){
                    player.units[t].id = c
                    c+=(1/500)
                }
                for(let t = 0;t<player.buildings.length;t++){
                    player.buildings[t].id = c
                    c+=(1/500)
                }
            }
            player.createdCount%= 500
            this.attacktargetmover = this
            this.debt = 0
            this.dying = 0
            this.hotrockrepathlimit = 0
            this.defensepathlimit = 0
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.pathQue = []
            this.slimelimit = Math.floor(Math.random() * 35)
            this.absolutePathLimit = 0
            this.start = {}
            this.start.id = -1
            this.heatmoved = 1
            this.omegalimit = 0
            this.lockout = 0
            this.pathcolor = getRandomColor()
            this.ultrawalk = 0
            this.cooloff = 0
            this.seetime = 0
            this.moved = 0
            this.stacksnap = 0
            this.aircheck = Math.floor(Math.random() * 10)
            this.swing = 0
            this.swingout = 1 //5
            this.stepout = 1
            this.selected = 0
            this.faction = player
            this.tile = tile
            this.ultrabreak = tile
            //////////console.log(this.ultrabreak)
            this.movespeedcount = 0
            this.movespeed = Math.floor(Math.random() * 3) + 2
            // this.pather = astar.search(sandmap, this.tile, this.tile)
            this.body = new UnitCircle(this.tile.x + (this.tile.width * .5), this.tile.y + (this.tile.height * .5), 5, this.faction.color)

            this.gameline = new LineOP(this.body, this.body)
            if (this.faction.type == 8 || this.faction.type == 6) {
                if (this.faction.units.length == 0) {
                    this.faction.units.push(this)
                }
            } else {
                this.faction.units.push(this)
            }
            this.index = 0
            this.realPath = [this.tile]
            this.metrics = {}
            this.metrics.length = this.realPath.length
            this.metrics.end = this.realPath[this.realPath.length - 1]
            this.repath = 0
            this.repathsnap = 0
            this.sight = 1 + this.movespeed
            this.damage = this.body.radius
            this.firerate = gargantuanNumber / (this.movespeed * 5)
            this.attackrange = this.sight - 1
            this.decayRate = (this.sight * this.movespeed) * .05
            this.health = this.sight * 100
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attacktargetmove = {}
            this.attacktargetmove.health = 0
            this.attackcounter = 0
            this.projectilespeed = 7 // 9
            this.name = "agent"
            this.agentTile = new AgentTile(this)

            if (campaignController.mission == -1) {

                if (start == 0) {
                    if (this.faction.type == 2) {
                        if (this.faction.units.length == 1) {
                            this.isHamartanscout()
                        }
                        if (this.faction.units.length == 2) {
                            this.isHamartanworker()
                        }
                        if (this.faction.units.length == 3) {
                            // this.isHamartansoldier() // to0 weak?
                            this.isHamartaninvader()
                        }

                    } else if (this.faction.type == 1) {
                        this.isNymph()
                        if (this.faction.units.length == 2) {
                            this.finishMorph2()
                        }
                    } else if (this.faction.type == 3) {

                        if (this.faction.units.length == 1) {
                            this.isPollinator()
                        }
                        if (this.faction.units.length == 2) {
                            this.isPufffellow()
                        }
                        if (this.faction.units.length == 3) {
                            this.isGoliophyte()
                        }
                    } else if (this.faction.type == 4) {
                        if (this.faction.units.length % 4 == 3) {
                            this.isMycoknight()
                        } else {
                            if (this.faction.units.length % 4 == 2) {
                                this.isFruitingBuddy()
                            } else {
                                if (this.faction.units.length % 4 == 1) {
                                    this.isSporevizir()
                                } else {
                                    this.isSporeseer()
                                }
                            }
                        }
                    } else if (this.faction.type == 0) {
                        if (this.faction.units.length == 1) {
                            this.isScout()
                        } else if (this.faction.units.length == 2) {
                            this.isInfantry()
                        } else if (this.faction.units.length == 3) {
                            this.isHarvester()
                        } else {
                            // this.isScout()
                        }

                    } else if (this.faction.type == 5) {
                        if (this.faction.units.length == 1) {
                            this.isBuzzlet()
                        } else if (this.faction.units.length == 2) {
                            this.isFlugoon()
                        } else if (this.faction.units.length == 3) {
                            this.isMegagnat()
                        } else {
                            // this.isScout()
                        }

                    } else if (this.faction.type == 7) {
                        if (this.faction.units.length == 1) {
                            this.isAlagadile()
                        } else if (this.faction.units.length == 2) {
                            this.isBigHunchAlagadile()
                        } else if (this.faction.units.length == 3) {
                            this.isBigAlagadile()
                        } else {
                            // this.isScout()
                        }

                    } else if (this.faction.type == 8) {
                        if (this.faction.units.length == 1) {
                            this.isTargetroid()
                        } else {
                        }
                    } else if (this.faction.type == 6) {
                        if (this.faction.units.length == 1) {
                            this.isSchlorkupine()
                        } else {
                        }
                    } else if (this.faction.type == 9) {
                        if (this.faction.units.length == 1) {
                            this.isGogonaut()
                        } else if (this.faction.units.length == 2) {
                            this.isGogonautTeam()
                        } else if (this.faction.units.length == 3) {
                            this.isGogonautChampion()
                        } else {
                            this.isGogonautDefender()
                        }
                    } else if (this.faction.type == 10) {
                        if (this.faction.units.length == 1) {
                            this.isBeeScout()
                        } else if (this.faction.units.length == 2) {
                            this.isBeeMega()
                        } else if (this.faction.units.length == 3) {
                            this.isBeeSoldier()
                        } else {
                            this.isBeeWorker()
                        }
                    }
                }


            }
            //army size1
            //army size2
            //avgx1
            //avgy1
            //avgx2
            //avgy2
            //locx
            //locy
            //healthofmax
            //nearrocksx
            //nearrocksy
            this.net = new Network([new Data(.5), new Data(.5), new Data(.5), new Data(.5), new Data(.5), new Data(.5), new Data(.5), new Data(.5), new Data(.5), new Data(.5), new Data(.5)], [9, 9, 2])
            //////////console.log(this.net)

            this.attacktarget = {}
            this.attacktarget.tile = {}
            //new
            this.attacktarget.tile.x = -100000
            this.attacktarget.tile.y = -100000
            this.attacktarget.tile.t = 0
            this.attacktarget.tile.k = 0

            this.commandPanel = new AgentCommands(this)
            this.listDraw = new BuildingQue(this)
        }
        totalBlank(tile, t){
                            let keys = Object.keys(this)
                            //////////console.log(keys)
                            for(let t = 0;t<keys.length;t++){
                               this[keys[t]] = {}
                            }

            this.agent = 1
            this.factionNum = t
                                this.decay = 31 //
                                this.dmark = 0 //
                                this.nymph = 0 //
                                this.bee = 0 //
                                this.alagadile = 0 //
                                this.gogo = 0 //
                                this.ave = 0 //
                                this.scurrier = 0 // 
                                this.imago = 0 //
                                this.gamergate = 0 //

                                this.fruiting = 0 //
                                this.mycoknight = 0 //
                                this.seer = 0 //
                                this.sporevizir = 0

                                this.infantry = 0 //
                                this.sniper = 0 //
                                this.harvester = 0 //
                                this.drone = 0 //

                                this.hamartanscout = 0 //
                                this.hamartanworker = 0 //
                                this.hamartaninvader = 0 //
                                this.hamartansoldier = 0  //


                                this.pollinator = 0 //
                                this.goliophyte = 0 //
                                this.pufffellow = 0 //
                                this.podman = 0

                                this.buzzlet = 0 //
                                this.flugoon = 0 //
                                this.starbatross = 0 //
                                this.megagnat = 0

                                this.alagadile = 0 //
                                this.bigalagadile = 0 //
                                this.bighunchalagadile = 0 //
                                this.hunchalagadile = 0

                                this.gogonaut = 0 //
                                this.gogonautdefender = 0 //
                                this.gogonautchampion = 0 //
                                this.gogonautteam = 0

                                this.beeworker = 0 //
                                this.beescout = 0 //
                                this.beesoldier = 0 //
                                this.beemega = 0
                                
                                this.targetroid = 0 //
                                this.schlorkupine = 0

            // this.walkcounter = 0
            this.awaiting = 0
            this.stepoutBonus = 0
            this.loaded = []
            this.times = []
            this.patrolling = -1
            this.timeoutforAsync = 0
            this.stack = 8000
            // this.id = Math.random()
            this.attacktargetmover = this
            this.debt = 0
            this.dying = 0
            this.hotrockrepathlimit = 0
            this.defensepathlimit = 0
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.pathQue = []
            this.slimelimit = Math.floor(Math.random() * 35)
            this.absolutePathLimit = 0
            this.start = {}
            this.start.id = -1
            this.heatmoved = 1
            this.omegalimit = 0
            this.lockout = 0
            this.pathcolor = getRandomColor()
            this.ultrawalk = 0
            this.cooloff = 0
            this.seetime = 0
            this.moved = 0
            this.stacksnap = 0
            this.aircheck = Math.floor(Math.random() * 10)
            this.swing = 0
            this.swingout = 1 //5
            this.stepout = 1
            this.selected = 0
            this.tile = tile
            this.ultrabreak = tile
            //////////console.log(this.ultrabreak)
            // this.movespeedcount = 0
            this.movespeed = Math.floor(Math.random() * 3) + 2
            // this.pather = astar.search(sandmap, this.tile, this.tile)
            this.body = new UnitCircle(this.tile.x + (this.tile.width * .5), this.tile.y + (this.tile.height * .5), 5, this.faction.color)

            this.gameline = new LineOP(this.body, this.body)
            this.index = 0
            this.realPath = [this.tile]
            this.metrics = {}
            this.metrics.length = this.realPath.length
            this.metrics.end = this.realPath[this.realPath.length - 1]
            this.repath = 0
            this.repathsnap = 0
            this.sight = 1 + this.movespeed
            this.damage = this.body.radius
            this.firerate = gargantuanNumber / (this.movespeed * 5)
            this.attackrange = this.sight - 1
            this.decayRate = (this.sight * this.movespeed) * .05
            this.health = this.sight * 100
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attacktargetmove = {}
            this.attacktargetmove.health = 0
            this.attackcounter = 0
            this.projectilespeed = 7 // 9
            this.name = "agent"
            this.agentTile = new AgentTile(this)

            this.net = new Network([new Data(.5), new Data(.5), new Data(.5), new Data(.5), new Data(.5), new Data(.5), new Data(.5), new Data(.5), new Data(.5), new Data(.5), new Data(.5)], [9, 9, 2])

            this.attacktarget = {}
            this.attacktarget.tile = {}
            //new
            this.attacktarget.tile.x = -100000
            this.attacktarget.tile.y = -100000
            this.attacktarget.tile.t = 0
            this.attacktarget.tile.k = 0

            this.commandPanel = new AgentCommands(this)
            this.listDraw = new BuildingQue(this)
        }
        upgradeAttack() {
            if (this.faction.hotrock >= this.attackCost) {
                this.faction.hotrock -= this.attackCost
                this.attackCost += 40
                this.damage *= 1.07
                if (this.firerate < gargantuanNumber * 5) {
                    this.firerate *= Math.sqrt(Math.sqrt(2))
                } else {
                    this.firerate = gargantuanNumber * 5
                }
            }
        }
        upgradeSpeed() {
            if (this.faction.hotrock >= this.speedCost) {
                this.faction.hotrock -= this.speedCost
                this.speedCost += 40
                this.sight++
                if (this.speedCost % 80 == 0) {
                    if (this.attackrange < 10) {
                        this.attackrange++
                    }
                }
                if (this.speedCost % 120 == 0) {
                    if (this.movespeed > 1) {
                        this.movespeed -= 1
                    }
                }

            }
        }
        upgradeSpeedSchlorkupine() {
            if (this.faction.hotrock >= this.speedCost) {
                this.faction.hotrock -= this.speedCost
                this.speedCost += 40
                this.sight++
                if (this.speedCost % 120 == 0) {
                    if (this.attackrange < 10) {
                        this.attackrange++
                    }
                }
                if (this.speedCost % 160 == 0) {
                    if (this.movespeed > 1) {
                        this.movespeed -= 1
                    }
                }

            }
        }
        upgradeIncome() {
            if (this.faction.hotrock >= this.incomeCost) {
                this.faction.hotrock -= this.incomeCost
                this.incomeCost += 40
                this.harvestBonusTargetroid += .2
                this.harvestBonusTargetroid *= 1.05
            }
        }
        upgradeDefense() {
            if (this.faction.hotrock >= this.defenseCost) {
                this.faction.hotrock -= this.defenseCost
                this.defenseCost += 40
                this.regen += .01
                this.regen *= 1.1
                if (this.defenseCost % 80 == 0) {
                    this.maxhealth += 500
                    this.health += 500
                    this.defense += 3
                } else {
                    this.defense += 2
                    this.maxhealth += 1000
                    this.health += 1000
                }
            }
        }
        upgradeDefenseSchlorkupine() {
            if (this.faction.hotrock >= this.defenseCost) {
                this.faction.hotrock -= this.defenseCost
                this.defenseCost += 40
                this.regen += .009
                this.regen *= 1.09
                this.spikes += .02
                if (this.defenseCost % 80 == 0) {
                    this.maxhealth += 400
                    this.health += 400
                    this.defense += 2
                } else {
                    this.defense += 1
                    this.maxhealth += 800
                    this.health += 800
                }
            }
        }
        isAlagadile() {
            this.babyalagadile = 1
            this.alagadile = 1
            this.body.color = "teal"
            this.body.radius = 4
            this.movespeed = 10
            this.firerate = gargantuanNumber / 3
            this.decayRate = 0
            this.damage = 14
            this.name = "Baby Alagadile"
            // this.nymph = 1
            this.defense = 8
            this.sight = -6 + this.movespeed
            this.attackrange = this.sight
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 320
            this.maxhealth = this.health
        }
        isBeeWorker() {
            this.bee = 1
            this.warmth = 0
            this.beeworker = 1
            this.body.color = "#FFAA0008"
            this.body.radius = 10
            this.movespeed = 4
            this.firerate = gargantuanNumber / 3
            this.decayRate = 0
            this.damage = 14
            this.name = "Beeple Worker"
            // this.nymph = 1
            this.defense = 0
            this.sight = 1 + this.movespeed
            this.attackrange = this.sight
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 280
            this.maxhealth = this.health
        }
        isBeeSoldier() {
            this.bee = 1
            this.warmth = 0
            this.beesoldier = 1
            this.body.color = "#FFAA0008"
            this.body.radius = 20
            this.movespeed = 4
            this.firerate = gargantuanNumber / 6
            this.decayRate = 0
            this.damage = 23
            this.name = "Beeple Soldier"
            // this.nymph = 1
            this.defense = 6
            this.sight = 2 + this.movespeed
            this.attackrange = this.sight
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 1369
            this.maxhealth = this.health
        }
        isBeeMega() {
            this.bee = 1
            this.beemega = 1
            this.warmth = 0
            this.body.color = "#FFAA0008"
            this.body.radius = 30
            this.movespeed = 6
            this.firerate = gargantuanNumber / 8
            this.decayRate = 0
            this.damage = 51
            this.name = "Beeple Queen"
            // this.nymph = 1
            this.defense = 17
            this.sight = 1 + this.movespeed
            this.attackrange = this.sight
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 2060
            this.maxhealth = this.health
        }
        isBeeScout() {
            this.bee = 1
            this.beescout = 1
            this.warmth = 0
            this.body.color = "#FFAA0008"
            this.body.radius = 20
            this.movespeed = 2
            this.firerate = gargantuanNumber / 3
            this.decayRate = 0
            this.damage = 10
            this.name = "Beeple Scout"
            // this.nymph = 1
            this.defense = 1
            this.sight = 8 + this.movespeed
            this.attackrange = this.sight-3
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 420
            this.maxhealth = this.health
        }
        isBigAlagadile() {
            this.bigalagadile = 1
            this.alagadile = 1
            this.body.color = "teal"
            this.body.radius = 4
            this.movespeed = 13
            this.firerate = gargantuanNumber / 5
            this.decayRate = 0
            this.damage = 27
            this.name = "Big Alagadile"
            // this.nymph = 1
            this.defense = 13
            this.sight = -8 + this.movespeed
            this.attackrange = this.sight
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 1800
            this.maxhealth = this.health
        }
        isHunchAlagadile() {
            this.hunchalagadile = 1
            this.alagadile = 1
            this.body.color = "teal"
            this.body.radius = 4
            this.movespeed = 11
            this.firerate = gargantuanNumber / 4
            this.decayRate = 0
            this.damage = 21
            this.name = "Hunch Alagadile"
            // this.nymph = 1
            this.defense = 10
            this.sight = -7 + this.movespeed
            this.attackrange = this.sight
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 960
            this.maxhealth = this.health
        }
        isBigHunchAlagadile() {
            this.bighunchalagadile = 1
            this.alagadile = 1
            this.body.color = "teal"
            this.body.radius = 4
            this.movespeed = 15
            this.firerate = gargantuanNumber / 8
            this.decayRate = 0
            this.damage = 45
            this.name = "Big Hunch Alagadile"
            // this.nymph = 1
            this.defense = 18
            this.sight = -10 + this.movespeed
            this.attackrange = this.sight
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 2125
            this.maxhealth = this.health
        }
        isFruitingBuddy() {
            this.seer = 0
            this.sporevizir = 0
            this.mycoknight = 0
            this.body.color = "teal"
            this.body.radius = 6
            this.movespeed = 3 //2 and 3 too high?
            this.firerate = gargantuanNumber / 2
            this.decayRate = 0
            this.damage = 6
            this.name = "Plaztilite Fruiting-Buddy"
            this.fruiting = 1
            // this.boombuddy = 1
            this.fungi = 1
            this.defense = 4 //10
            this.sight = 2 + this.movespeed //1
            this.attackrange = this.sight - 1
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 135
            this.maxhealth = this.health
        }
        isSporeseer() {

            this.fruiting = 0
            this.sporevizir = 0
            this.mycoknight = 0
            this.body.color = "teal"
            this.body.radius = 6
            this.movespeed = 5 //2 and 3 too high?
            this.firerate = gargantuanNumber / 4
            this.decayRate = 0
            this.damage = 13
            this.name = "Plaztilite Spore-Seer"
            this.seer = 1
            this.fungi = 1
            this.defense = 12
            this.sight = 3 + this.movespeed
            this.attackrange = this.sight - 4 //1
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 595
            this.maxhealth = this.health
        }
        isSporevizir() {
            this.seer = 0
            this.fruiting = 0
            this.mycoknight = 0
            this.body.color = "teal"
            this.body.radius = 6
            this.movespeed = 6 //2 and 3 too high?
            this.firerate = gargantuanNumber / 4
            this.decayRate = 0
            this.damage = 15
            this.name = "Plaztilite Spore Vizier"
            this.sporevizir = 1
            this.fungi = 1
            this.defense = 16
            this.sight = 0 + this.movespeed //1
            this.attackrange = this.sight - 2 //1
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 625
            this.maxhealth = this.health
        }
        isMycoknight() {
            this.seer = 0
            this.sporevizir = 0
            this.fruiting = 0
            this.body.color = "teal"
            this.body.radius = 6
            this.movespeed = 7 //2 and 3 too high?
            this.firerate = gargantuanNumber / 5
            this.decayRate = 0
            this.damage = 34
            this.name = "Plaztilite Mycoknight"
            this.mycoknight = 1
            this.fungi = 1
            this.defense = 11
            this.sight = -1 + this.movespeed //1
            this.attackrange = this.sight - 2 //1
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 1110
            this.maxhealth = this.health
        }
        isPollinator() {
            this.body.color = "teal"
            this.goliophyte = 0
            this.body.radius = 4
            this.movespeed = 2 //2 and 3 too high?
            this.firerate = gargantuanNumber / 6
            this.decayRate = 0
            this.damage = (this.body.radius * 1.5) + 1
            this.name = "Librilbian Pollinator"
            this.pollinator = 1
            this.defense = 0
            this.sight = 3 + this.movespeed
            this.attackrange = this.sight - 1
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 170
            this.maxhealth = this.health
        }
        isGoliophyte() {
            this.pollinator = 0
            this.body.color = "teal"
            this.body.radius = 5.5
            this.movespeed = 8
            this.firerate = gargantuanNumber / 6 //7
            this.decayRate = 0
            this.damage = (this.body.radius * 4.5) + 1
            this.name = "Librilbian Golophyte"
            this.goliophyte = 1
            this.defense = 14
            this.sight = 2 + this.movespeed
            this.attackrange = this.sight - 1
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 1700
            this.maxhealth = this.health
        }
        isPodman() {
            this.pollinator = 0
            this.body.color = "teal"
            this.goliophyte = 0
            this.body.radius = 4
            this.movespeed = 4
            this.firerate = gargantuanNumber / 3 //4
            this.decayRate = 0
            this.damage = (43 / 3)
            this.name = "Librilbian Podman"
            this.podman = 1
            this.defense = 7
            this.sight = 2 + this.movespeed
            this.attackrange = this.sight - 1
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 990 //510 //490 //890
            this.maxhealth = this.health
        }
        isPufffellow() {
            this.pollinator = 0
            this.goliophyte = 0
            this.body.color = "teal"
            this.body.radius = 4.7
            this.movespeed = 2
            this.firerate = gargantuanNumber / 4//4 //lmao 4.7
            this.decayRate = 0
            this.damage = (this.body.radius * 2.6) + 0  //2.1 // +1
            this.name = "Librilbian Puff-Fellow"
            this.pufffellow = 1
            this.defense = 4
            this.sight = 2 + this.movespeed
            this.attackrange = this.sight - 1
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 440//300 //530 //470
            this.maxhealth = this.health
        }
        isSchlorkupine() {
            this.body.color = "teal"
            this.body.radius = 4
            this.movespeed = 7
            this.firerate = gargantuanNumber / 11 //3 make more viable in combat
            this.decayRate = 0
            this.damage = 19
            this.name = "Schlorkupine"
            this.schlorkupine = 1
            this.regenerating = 1
            this.regen = .01
            this.spikes = .02
            this.attackCost = 80
            this.incomeCost = 80
            this.defenseCost = 80
            this.speedCost = 80
            this.defense = 8
            this.harvestBonusTargetroid = .1
            this.sight = 1 + this.movespeed
            // this.firerate = gargantuanNumber/(this.movespeed * 5)
            this.attackrange = this.sight - 1
            // this.health = this.sight * 100
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 1800
            this.maxhealth = this.health
        }
        isTargetroid() {
            this.body.color = "teal"
            this.body.radius = 4
            this.movespeed = 5
            this.firerate = gargantuanNumber / 10 //3 make more viable in combat
            this.decayRate = 0
            this.damage = 20
            this.name = "Targetroid"
            this.targetroid = 1
            this.regenerating = 1
            this.regen = .01
            this.attackCost = 80
            this.incomeCost = 80
            this.defenseCost = 80
            this.speedCost = 80
            this.defense = 5
            this.harvestBonusTargetroid = .1
            this.sight = 1 + this.movespeed
            // this.firerate = gargantuanNumber/(this.movespeed * 5)
            this.attackrange = this.sight - 1
            // this.health = this.sight * 100
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 2000
            this.maxhealth = this.health
        }
        isNymph() {
            this.body.color = "teal"
            this.body.radius = 4
            this.movespeed = 2
            this.firerate = gargantuanNumber / 2 //3 make more viable in combat
            this.decayRate = 0
            this.damage = (this.body.radius * 2.75) + 1
            this.name = "Nymph"
            this.nymph = 1
            this.defense = 3
            this.sight = 1 + this.movespeed
            // this.firerate = gargantuanNumber/(this.movespeed * 5)
            this.attackrange = this.sight - 1
            // this.health = this.sight * 100
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 70
            this.maxhealth = this.health
        }
        isGogonaut() {
            this.gogonaut = 1
            this.gogo = 1
            this.body.color = "teal"
            this.body.radius = 4
            this.movespeed = 4
            this.firerate = gargantuanNumber / 3
            this.decayRate = 0
            this.damage = 7
            this.name = "Gogonaut"
            // this.nymph = 1
            this.defense = 6
            this.sight = 1 + this.movespeed
            this.attackrange = this.sight - 1
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 500
            this.maxhealth = this.health
        }
        isGogonautDefender() {
            this.gogonautdefender = 1
            this.gogo = 1
            this.body.color = "teal"
            this.body.radius = 4
            this.movespeed = 4
            this.firerate = gargantuanNumber / 6
            this.decayRate = 0
            this.damage = 23
            this.name = "Gogonaut Defender"
            // this.nymph = 1
            this.defense = 11
            this.sight = 1 + this.movespeed
            this.attackrange = this.sight - 1
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 1860
            this.maxhealth = this.health
        }
        isGogonautTeam() {
            this.gogonautteam = 1
            this.gogo = 1
            this.body.color = "teal"
            this.body.radius = 4
            this.movespeed = 3
            this.firerate = gargantuanNumber / 3
            this.decayRate = 0
            this.damage = 10
            this.name = "Gogonaut Team"
            // this.nymph = 1
            this.defense = 8
            this.sight = 2 + this.movespeed
            this.attackrange = this.sight - 1
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 750
            this.maxhealth = this.health
        }
        isGogonautChampion() {
            this.gogonautchampion = 1
            this.gogo = 1
            this.body.color = "teal"
            this.body.radius = 4
            this.movespeed = 5
            this.firerate = gargantuanNumber / 8
            this.decayRate = 0
            this.damage = 33
            this.name = "Gogonaut Champion"
            // this.nymph = 1
            this.defense = 16
            this.sight = 1 + this.movespeed
            this.attackrange = this.sight - 1
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 2345
            this.maxhealth = this.health
        }
        isFlugoon() {
            this.flugoon = 1
            this.ave = 1
            this.body.color = "teal"
            this.body.radius = 4
            this.movespeed = 5
            this.firerate = gargantuanNumber / 7
            this.decayRate = 0
            this.damage = 20
            this.name = "Avesectian Flugoon"
            // this.nymph = 1
            this.defense = 12
            this.sight = 3 + this.movespeed
            this.attackrange = this.sight - 1
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 1740
            this.maxhealth = this.health
        }
        isBuzzlet() {
            this.buzzlet = 1
            this.ave = 1
            this.body.color = "teal"
            this.body.radius = 4
            this.movespeed = 2
            this.firerate = gargantuanNumber / 2
            this.decayRate = 0
            this.damage = 3
            this.name = "Avesectian Buzzlet"
            // this.nymph = 1
            this.defense = 6
            this.sight = 3 + this.movespeed
            this.attackrange = this.sight - 1
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 50
            this.maxhealth = this.health
        }
        isStarbatross() {
            this.starbatross = 1
            // this.drone = 1 //to see gamergate dig
            this.ave = 1
            this.body.color = "teal"
            this.body.radius = 4
            this.movespeed = 4
            this.firerate = gargantuanNumber / 5
            this.decayRate = 0
            this.damage = 24
            this.name = "Avesectian Starbatross"
            // this.nymph = 1
            this.defense = 6
            this.sight = 3 + this.movespeed
            this.attackrange = this.sight - 1
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 870
            this.maxhealth = this.health
        }
        isMegagnat() {
            this.megagnat = 1
            this.ave = 1
            this.body.color = "teal"
            this.body.radius = 4
            this.movespeed = 6
            this.firerate = gargantuanNumber / 12
            this.decayRate = 0
            this.damage = 30
            this.name = "Avesectian Megagnat"
            // this.nymph = 1
            this.defense = 4
            this.sight = 1 + this.movespeed
            this.attackrange = this.sight - 1
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.health = 1170
            this.maxhealth = this.health
        }
        isScout() {
            this.drone = 1
            this.movespeed = 2
            this.body.color = "red"
            this.body.radius = 4
            this.defense = 1
            this.damage = this.body.radius
            this.name = "Scout Drone"
            this.sight = 4 + this.movespeed
            this.damage = this.body.radius
            this.firerate = gargantuanNumber / 3  // 9//(this.movespeed * 5)
            this.attackrange = this.sight - 1
            this.health = (this.sight - 2) * 100
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.decayRate = ((this.sight - 2) * this.movespeed) * .015
            this.health = 250
            this.maxhealth = this.health
        }
        isHamartanworker() {
            this.hamartanworker = 1
            this.hamartansoldier = 0
            this.hamartansoldier = 0
            this.hamartanscout = 0
            this.movespeed = 3 //too high?
            this.body.color = "red"
            this.body.radius = 4
            this.defense = 1
            this.damage = this.body.radius
            this.name = "Hamartan Worker"
            this.sight = 4
            this.damage = this.body.radius
            this.firerate = gargantuanNumber / 7  // 9//(this.movespeed * 5) //10
            this.attackrange = this.sight - 1
            this.health = (this.sight - 2) * 100
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.decayRate = .09
        }
        isHamartaninvader() {
            this.hamartaninvader = 1
            this.hamartansoldier = 0
            this.hamartanscout = 0
            this.hamartanworker = 0
            this.movespeed = 7
            this.body.color = "red"
            this.body.radius = 4.5
            this.defense = 12 //14 //19
            this.damage = this.body.radius * 7
            this.name = "Hamartan Invader"
            this.sight = 6
            this.firerate = gargantuanNumber / 7   // 9//(this.movespeed * 5) // 7? //6? - 7
            this.attackrange = this.sight
            this.health = (this.sight - 1) * 420  //-1 //1.5
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.decayRate = .07
        }
        isHamartansoldier() {
            this.hamartansoldier = 1
            this.hamartaninvader = 0
            this.hamartanscout = 0
            this.hamartanworker = 0
            this.movespeed = 4 //5
            this.body.color = "red"
            this.body.radius = 4
            this.defense = 11 //9 //13
            this.damage = this.body.radius * 3.25 //2.9
            this.name = "Hamartan Soldier"
            this.sight = 7
            this.firerate = gargantuanNumber / 3  // 9//(this.movespeed * 5) //4
            this.attackrange = this.sight
            this.health = (this.sight - 2) * 170
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.decayRate = .09
        }
        isHamartanscout() {
            this.hamartaninvader = 0
            this.hamartanscout = 1
            this.hamartanworker = 0
            this.hamartansoldier = 0
            this.movespeed = 9 //13
            this.body.color = "red"
            this.body.radius = 4
            this.defense = 25
            this.damage = 3
            this.name = "Hamartan Scout"
            this.sight = 12
            this.firerate = gargantuanNumber / 1  // 9//(this.movespeed * 5) //20 lmao
            this.attackrange = this.sight - 5
            this.health = (this.sight - 2) * 9
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.decayRate = .05
        }
        isInfantry() {
            this.infantry = 1
            this.movespeed = 3 //4
            this.body.color = "magenta"
            this.body.radius = 4.8
            this.defense = 4
            this.damage = this.body.radius
            this.name = "Infantry"
            this.sight = 1 + this.movespeed
            this.damage = (this.body.radius * 2.9)
            this.firerate = gargantuanNumber / 5 //12 //(this.movespeed * 5)
            this.attackrange = this.sight
            this.health = this.sight * 100
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.decayRate = (this.sight * this.movespeed) * .02
            this.health = 460
            this.maxhealth = this.health
        }
        isSniper() {
            this.infantry = 2
            this.sniper = 1
            this.movespeed = 7//4
            this.body.color = "magenta"
            this.body.radius = 4.8
            this.defense = 7
            this.name = "Sniper"
            this.sight = 1 + this.movespeed
            this.damage = 24 //72 vs 70 + 3 armor for nymph
            this.firerate = gargantuanNumber / 3 //12 //(this.movespeed * 5)
            this.attackrange = this.sight
            this.maxhealth = this.health
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.decayRate = (12) * .02
            this.health = 775 //725
            this.maxhealth = this.health
            this.mounted = 0
        }
        isHarvester() {
            this.harvester = 1
            this.movespeed = 5 //5 // 4
            this.body.color = "gray"
            this.body.radius = 5.5
            this.defense = 10
            this.name = "Harvesting Vehicle"
            this.sight = 1 + this.movespeed
            this.damage = (this.body.radius * 5.6)
            this.firerate = gargantuanNumber / 7 //(this.movespeed * 5) // 6 //7
            this.attackrange = this.sight - 1
            this.shots = []
            this.attacktarget = {}
            this.attacktarget.tile = {}
            this.attacktarget.health = 0
            this.attackcounter = 0
            this.decayRate = (this.sight * this.movespeed) * .01
            this.health = 1400 //1400
            this.maxhealth = this.health
        }
        spawnNymph() {
            const agent1 = new Agent(this.tile, this.faction)
            agent1.isNymph()
            // agent1.body.color = "teal"
            // agent1.body.radius = 4
            // agent1.movespeed = 1
            // agent1.firerate = gargantuanNumber/3
            // agent1.decayRate = 0
            // agent1.damage = (agent1.body.radius * .5)
            // agent1.name = "Nymph"
            // agent1.nymph = 1
            // agent1.health = 70
            // agent1.maxhealth = agent1.health
            for (let t = -2; t <= 2; t++) {
                for (let k = -2; k <= 2; k++) {
                    if (this.tile.t + t >= 0) {
                        if (this.tile.k + k >= 0) {
                            if (this.tile.t + t < worldscale) {
                                if (this.tile.k + k < worldscale) {
                                    if (sandmap.blocks[this.tile.t + t][this.tile.k + k].walkable == true) {
                                        if (this.realPath.includes(sandmap.blocks[this.tile.t + t][this.tile.k + k])) {
                                        } else {
                                            agent1.pathToForAI(sandmap.blocks[this.tile.t + t][this.tile.k + k], 1, 1)
                                            break
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        makeNymph() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 109 && this.faction.units.length < (unitcap)) {
                    if (this.imago == 1 || this.imago == 2) {
                        this.faction.hotrock -= 109
                        this.spawn = 1
                        this.que = 1
                        this.timer = 55
                        this.maxtimer = this.timer
                        if (this.imago == 1) {
                            if (Math.random() < soundspamdrop * 3) {
                                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                                    soundCancel()
                                    youneedmyassagain.play()
                                }
                            }
                        } else if (this.imago == 2) {
                            if (Math.random() < soundspamdrop * 3) {
                                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                                    soundCancel()
                                    hoppe.play()
                                }
                            }
                        }
                    }
                }
            } else {
                if (this.faction.hotrock >= 109 && this.faction.units.length < (unitcap)) {
                    if (this.imago == 1 || this.imago == 2) {
                        this.faction.hotrock -= 109
                        this.loaded.push("spawn")
                        this.times.push(55)
                    }
                }

            }
        }
        finishMorph1() {
            if(this.dying > 0){
                return
            }
            if (this.sana != 1) {
                this.scurrier = 1 
                this.body.color = "blue"
                this.body.radius = 4.8
                this.movespeed = 3
                this.sight = 1 + this.movespeed
                this.firerate = gargantuanNumber / 2  //3 geez too slow//4
                this.decayRate = 0
                this.damage = 17.36 // (this.body.radius * 3.1) + 1
                this.name = "Scurrier"
                this.nymph = 2
                this.health = 660
                this.defense = 6
                this.maxhealth = this.health
                this.attackrange = this.sight - 1
            } else {

                this.scurrier = 1 
                this.body.color = "blue"
                this.body.radius = 4.8
                this.movespeed = 3
                this.sight = 3 + this.movespeed
                this.firerate = gargantuanNumber / 2  //3 geez too slow//4
                this.decayRate = 0
                this.damage = 27.36 // (this.body.radius * 3.1) + 1
                this.nymph = 2
                this.health = 990
                this.defense = 13
                this.maxhealth = this.health
                this.attackrange = this.sight
            }
            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                if (Math.random() < soundspamdrop) {
                    soundCancel()
                    if (Math.random() < .3) {
                        iknowcomeon.play()
                    } else if (Math.random() < .3) {
                        mylifesmine.play()
                    } else {
                        snazzyrim.play()
                    }
                }
            }
        }
        finishMorph2() {
            if(this.dying > 0){
                return
            }
            if (this.sana != 1) {
                this.body.color = "white"
                this.body.radius = 7.9  // 7.9
                this.movespeed = 6 //7 //8
                this.sight = 1 + this.movespeed
                this.firerate = gargantuanNumber / 5 // 6 // 9 //8
                this.decayRate = 0
                this.defense = 9
                this.damage = 42 // (this.body.radius * 4) + 1.5
                this.name = "Imago"
                this.walkcounter = 0
                this.imago = 1
                this.nymph = 0
                this.health = 2800
                this.maxhealth = this.health
            } else {

                this.body.color = "white"
                this.body.radius = 7.9  // 7.9
                this.movespeed = 4 //7 //8
                this.sight = 3 + this.movespeed
                this.firerate = gargantuanNumber / 4 // 6 // 9 //8
                this.decayRate = 0
                this.defense = 16
                this.damage = 59 // (this.body.radius * 4) + 1.5
                this.imago = 1
                this.nymph = 0
                this.health = 4200
                this.maxhealth = this.health
            }
            this.attackrange = this.sight - 1
            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    soundCancel()
                    if (start != 0) {
                        yeahiminthisroom.play()
                    }
                }
            }
        }
        finishMorphgamergate() {
            if(this.dying > 0){
                return
            }
            if (this.sana != 1) {
                this.gamergate = 1
                this.body.color = "white"
                this.body.radius = 6.5
                this.movespeed = 6
                this.sight = 1 + this.movespeed
                this.firerate = gargantuanNumber / 10 // 9 // 17?
                this.decayRate = 0
                this.defense = 18
                this.damage = 121 // 23.5  //(this.body.radius * 3) + 4
                this.name = "Gamergate"
                this.imago = 2
                this.nymph = 0
                this.gamergate = 1
                this.health = 1451
                this.maxhealth = this.health
                this.attackrange = this.sight //- 1
                this.submerged = 0
            } else {
                this.gamergate = 1
                this.body.color = "white"
                this.body.radius = 6.5
                this.movespeed = 4
                this.sight = 3 + this.movespeed
                this.firerate = gargantuanNumber / 7 // 9 // 17?
                this.decayRate = 0
                this.defense = 20
                this.damage = 151 // 23.5  //(this.body.radius * 3) + 4
                this.imago = 2
                this.nymph = 0
                this.gamergate = 1
                this.health = 4000
                this.maxhealth = this.health
                this.attackrange = this.sight
                this.submerged = 0
            }
            if (Math.random() < soundspamdrop) {
                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                    soundCancel()
                    doyouwantsome.play()
                }
            }
        }
        metamorphpufffellow() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 5) {
                    if (this.pollinator == 1) {
                        this.faction.hotrock -= 5
                        this.puffing = 1
                        this.que = 1
                        this.timer = 25
                        this.maxtimer = this.timer
                    }
                }
            }
        }
        metamorph1() {
            //////////console.log(this.que, 1)
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                //////////console.log(this.hotrock, 2)
                if (this.faction.hotrock >= 180) {
                    //////////console.log(this.nymph, 3)
                    if (this.nymph == 1) {
                        this.faction.hotrock -= 180 //180
                        this.morphing = 1
                        this.que = 1
                        this.timer = 100
                        this.maxtimer = this.timer
                    }
                }
            }
            //////////console.log(this.timer, 4)
        }
        metamorph2() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 240) {
                    if (this.nymph == 2) {
                        this.faction.hotrock -= 240
                        this.morphingagain = 1
                        this.que = 1
                        this.timer = 200
                        this.maxtimer = this.timer
                    }
                }
            }
        }
        metamorph3() {
            if (this.que != 1 || this.faction.isAI == 1) {
                if (this.que == 1) {
                    return
                }
                if (this.faction.hotrock >= 350) {
                    if (this.nymph == 2) {
                        this.faction.hotrock -= 350
                        this.morphinggamergate = 1
                        this.que = 1
                        this.timer = 200
                        this.maxtimer = this.timer
                    }
                }
            }
        }
        dataOutput() {
            //moved
        }
        attacksound() {


            for(let d = 1;d<sandmap.players.length;d++){
            const indexer = Math.abs((sandmap.players.indexOf(this.faction) + d)%sandmap.players.length)
            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                if (this.bee == 1) {
                    let wet = 1
                    if (Math.random() > (soundspamdrop * engageconstant)) {
                        wet = 0
                    }
                    for (let t = 0; t < sounds.length; t++) {
                        if (!sounds[t].paused) {
                            // //////////console.log("gh")
                            wet = 0
                            break
                        }
                    }
                    if (wet == 1) {
                    soundCancel()
                    beeaudio7.play()
                    }
                }
                if (this.ave == 1) {
                    let wet = 1
                    if (Math.random() > (soundspamdrop * engageconstant)) {
                        wet = 0
                    }
                    for (let t = 0; t < sounds.length; t++) {
                        if (!sounds[t].paused) {
                            // //////////console.log("gh")
                            wet = 0
                            break
                        }
                    }
                    if (wet == 1) {
                    soundCancel()
                    avesounds[Math.floor(Math.random() * (avesounds.length - 2))].play()
                    }
                }

                if (this.nymph == 1) {
                    if (this.seen1 == 0 && sandmap.players[indexer].units.length <= 22) {
                        this.seen1 = 1
                        textpainter.clear()
                        textpainter.push("Slackjawed Infantry", "#FF00AA", "Hey, that one's a different color, I thought we got this whole nest.")
                        textpainter.push("Tightassed Infantry", "#AA00FF", "It's not showing up on the infrascanner, let's see if I can hit it unguided.")
                    }


                    let wet = 1
                    if (Math.random() > (soundspamdrop * engageconstant)) {
                        wet = 0
                    }
                    for (let t = 0; t < sounds.length; t++) {
                        if (!sounds[t].paused) {
                            // //////////console.log("gh")
                            wet = 0
                            break
                        }
                    }
                    if (wet == 1) {
                        soundCancel()
                        if (Math.random() < .5) {
                            itstheedgeofusfight.play()
                        } else {
                            seethemseetheme.play()
                        }
                    }
                }
                if (this.imago == 1) {

                    if (this.seen1 == 2 && sandmap.players[indexer].units.length <= 17 && this.faction.units.length > 3) {
                        this.seen1 = 3
                        textpainter.clear()
                        textpainter.push("Lead Harvester", "#770099", "We need to stop this now, everyone on my position!")
                        textpainter.push("Associated Infantry", "#FF0066", "Charge!")
                        textpainter.push("Collective Infantry", "#DD0088", "I hope you know what you're doing.")
                        textpainter.push("Assembled Infantry", "#880066", "Right on it!!")
                        for (let t = 0; t < sandmap.players[indexer].units.length; t++) {

                            sandmap.players[indexer].units[t].ultrabreak = this.tile
                            sandmap.players[indexer].units[t].ultrawalk = 0
                            sandmap.players[indexer].units[t].start = sandmap.players[indexer].units[t].tile
                        }
                    }
                    if (this.seen1 == 1 && sandmap.players[indexer].units.length <= 22 && this.faction.units.length > 1) {
                        this.seen1 = 2
                        textpainter.clear()
                        textpainter.push("Bigamist Infantry", "#FF0000", "Looks like they're multiplying again! The scanners must be broken.")
                        textpainter.push("Widowed Infantry", "#4488AA", "I'll wire the base, but this far out, it's up to us!")
                    }

                    let wet = 1
                    if (Math.random() > (soundspamdrop * engageconstant)) {
                        wet = 0
                    }
                    for (let t = 0; t < sounds.length; t++) {
                        if (!sounds[t].paused) {
                            // //////////console.log("gh")
                            wet = 0
                            break
                        }
                    }
                    if (wet == 1) {
                        soundCancel()
                        if (Math.random() < .5) {
                            ahhbarber.play()
                        } else {
                            slamdownmustard.play()
                        }
                    }
                }
                if (this.imago == 2) {
                    if (this.seen1 == 2 && sandmap.players[indexer].units.length <= 17 && this.faction.units.length > 3) {
                        this.seen1 = 3
                        textpainter.clear()
                        textpainter.push("Lead Harvester", "#770099", "We need to stop this now, everyone on my position!")
                        textpainter.push("Associated Infantry", "#FF0066", "Charge!")
                        textpainter.push("Collective Infantry", "#DD0088", "I hope you know what you're doing.")
                        textpainter.push("Assembled Infantry", "#880066", "Right on it!!")
                        for (let t = 0; t < sandmap.players[indexer].units.length; t++) {
                            sandmap.players[indexer].units[t].ultrabreak = this.tile
                            sandmap.players[indexer].units[t].ultrawalk = 0
                            sandmap.players[indexer].units[t].start = sandmap.players[indexer].units[t].tile
                        }
                    }
                    if (this.seen1 == 1 && sandmap.players[indexer].units.length <= 22 && this.faction.units.length > 1) {
                        this.seen1 = 2
                        textpainter.clear()
                        textpainter.push("Bigamist Infantry", "#FF0000", "Looks like they're multiplying again! The scanners must be broken.")
                        textpainter.push("Widowed Infantry", "#4488AA", "I'll wire the base, but this far out, it's up to us!")
                    }

                    let wet = 1
                    if (Math.random() > (soundspamdrop * engageconstant)) {
                        wet = 0
                    }
                    for (let t = 0; t < sounds.length; t++) {
                        if (!sounds[t].paused) {
                            // //////////console.log("gh")
                            wet = 0
                            break
                        }
                    }
                    if (wet == 1) {
                        soundCancel()
                        youhurtme.play()
                    }
                }
                if (this.infantry == 2) {

                    let wet = 1
                    if (Math.random() > (soundspamdrop * engageconstant)) {
                        wet = 0
                    }
                    for (let t = 0; t < sounds.length; t++) {
                        if (!sounds[t].paused) {
                            // //////////console.log("gh")
                            wet = 0
                            break
                        }
                    }
                    if (wet == 1) {
                        soundCancel()
                        if (Math.random() < .3) {
                            isnipedyouaweekago2.play()
                        } else if (Math.random() < .3) {
                            isnipedyouaweekago.play()
                        } else if (Math.random() < .3) {
                            theresone.play()
                        } else if (Math.random() < .3) {
                            bossaroundhere.play()
                        } else if (Math.random() < .3) {
                            bossaroundhere2.play()
                        } else {
                            adjustingforwindspeed.play()
                        }
                    }
                }
                if (this.nymph == 2) {
                    if (this.seen1 == 0 && sandmap.players[indexer].units.length <= 22) {
                        this.seen1 = 1
                        textpainter.clear()
                        textpainter.push("Slackjawed Infantry", "#FF00AA", "Hey, that one's a different color, I thought we got this whole nest.")
                        textpainter.push("Tightassed Infantry", "#AA00FF", "It's not showing up on the infrascanner, let's see if I can hit it unguided.")
                    }

                    let wet = 1
                    if (Math.random() > (soundspamdrop * engageconstant)) {
                        wet = 0
                    }
                    for (let t = 0; t < sounds.length; t++) {
                        if (!sounds[t].paused) {
                            // //////////console.log("gh")
                            wet = 0
                            break
                        }
                    }
                    if (wet == 1) {
                        soundCancel()
                        if (Math.random() < .3) {
                            icannamethevillans.play()
                        } else if (Math.random() < .3) {
                            suresawwithvenom.play()
                        } else {
                            ohisthattheeyeofthesnake.play()
                        }
                    }
                }
                if (this.hamartaninvader == 1) {

                    let wet = 1
                    if (Math.random() > (soundspamdrop * engageconstant)) {
                        wet = 0
                    }
                    for (let t = 0; t < sounds.length; t++) {
                        if (!sounds[t].paused) {
                            // //////////console.log("gh")
                            wet = 0
                            break
                        }
                    }
                    if (wet == 1) {
                        soundCancel()
                        youhome.play()
                    }
                }
                if (this.hamartansoldier == 1) {

                    let wet = 1
                    if (Math.random() > (soundspamdrop * engageconstant)) {
                        wet = 0
                    }
                    for (let t = 0; t < sounds.length; t++) {
                        if (!sounds[t].paused) {
                            // //////////console.log("gh")
                            wet = 0
                            break
                        }
                    }
                    if (wet == 1) {
                        soundCancel()
                        if (Math.random() < .3) {
                            inthejetsarm.play()
                        } else if (Math.random() < .3) {
                            youareabuse.play()
                        } else if (Math.random() < .3) {
                            sorcery.play()
                        } else if (Math.random() < .3) {
                            arerats.play()
                        } else if (Math.random() < .3) {
                            enormoushead.play()
                        } else {
                            reallytacky.play()
                        }
                    }
                }
                if (this.drone == 1) {

                    let wet = 1
                    if (Math.random() > (soundspamdrop * engageconstant)) {
                        wet = 0
                    }
                    for (let t = 0; t < sounds.length; t++) {
                        if (!sounds[t].paused) {
                            // //////////console.log("gh")
                            wet = 0
                            break
                        }
                    }
                    if (wet == 1) {
                        soundCancel()
                        combatinit.play()
                    }
                }
                if (this.infantry == 1) {

                    let wet = 1
                    if (Math.random() > (soundspamdrop * engageconstant)) {
                        wet = 0
                    }
                    for (let t = 0; t < sounds.length; t++) {
                        if (!sounds[t].paused) {
                            // //////////console.log("gh")
                            wet = 0
                            break
                        }
                    }
                    if (wet == 1) {
                        soundCancel()
                        lightemup.play()
                    }
                }
                if (this.harvester == 1) {

                    let wet = 1
                    if (Math.random() > (soundspamdrop * engageconstant)) {
                        wet = 0
                    }
                    for (let t = 0; t < sounds.length; t++) {
                        if (!sounds[t].paused) {
                            // //////////console.log("gh")
                            wet = 0
                            break
                        }
                    }
                    if (wet == 1) {
                        soundCancel()
                        if (Math.random() < .3) {
                            myfuneral.play()
                        } else {
                            hopeyouknow.play()
                        }
                    }
                }
                if (this.pufffellow == 1) {

                    let wet = 1
                    if (Math.random() > (soundspamdrop * engageconstant)) {
                        wet = 0
                    }
                    for (let t = 0; t < sounds.length; t++) {
                        if (!sounds[t].paused) {
                            // //////////console.log("gh")
                            wet = 0
                            break
                        }
                    }
                    if (wet == 1) {
                        soundCancel()
                        pufffellowaudio.play()
                    }
                }
                if (this.pollinator == 1) {

                    let wet = 1
                    if (Math.random() > (soundspamdrop * engageconstant)) {
                        wet = 0
                    }
                    for (let t = 0; t < sounds.length; t++) {
                        if (!sounds[t].paused) {
                            // //////////console.log("gh")
                            wet = 0
                            break
                        }
                    }
                    if (wet == 1) {
                        soundCancel()
                        pollinatoraudio.play()
                    }
                }

                if (this.goliophyte == 1) {

                    let wet = 1
                    if (Math.random() > (soundspamdrop * engageconstant)) {
                        wet = 0
                    }
                    for (let t = 0; t < sounds.length; t++) {
                        if (!sounds[t].paused) {
                            // //////////console.log("gh")
                            wet = 0
                            break
                        }
                    }
                    if (wet == 1) {
                        soundCancel()
                        golophyteaudio.play()
                    }
                }


                if (this.fruiting == 1) {

                    let wet = 1
                    if (Math.random() > (soundspamdrop * engageconstant)) {
                        wet = 0
                    }
                    for (let t = 0; t < sounds.length; t++) {
                        if (!sounds[t].paused) {
                            // //////////console.log("gh")
                            wet = 0
                            break
                        }
                    }
                    if (wet == 1) {
                        soundCancel()
                        buddyaudio.play()
                    }
                }
                if (this.sporevizir == 1) {

                    let wet = 1
                    if (Math.random() > (soundspamdrop * engageconstant)) {
                        wet = 0
                    }
                    for (let t = 0; t < sounds.length; t++) {
                        if (!sounds[t].paused) {
                            // //////////console.log("gh")
                            wet = 0
                            break
                        }
                    }
                    if (wet == 1) {
                        soundCancel()
                        vizieraudio.play()
                    }
                }
                if (this.mycoknight == 1) {

                    let wet = 1
                    if (Math.random() > (soundspamdrop * engageconstant)) {
                        wet = 0
                    }
                    for (let t = 0; t < sounds.length; t++) {
                        if (!sounds[t].paused) {
                            // //////////console.log("gh")
                            wet = 0
                            break
                        }
                    }
                    if (wet == 1) {
                        soundCancel()
                        mycoknightaudio.play()
                    }
                }
                if (this.seer == 1) {

                    let wet = 1
                    if (Math.random() > (soundspamdrop * engageconstant)) {
                        wet = 0
                    }
                    for (let t = 0; t < sounds.length; t++) {
                        if (!sounds[t].paused) {
                            // //////////console.log("gh")
                            wet = 0
                            break
                        }
                    }
                    if (wet == 1) {
                        soundCancel()
                        seeraudio.play()
                    }
                }
            }
        }
        }
        isRangeTo(tile, range) {
            if (tile.t >= 0) {
                if (Math.abs(this.tile.t - tile.t) <= this.attackrange && Math.abs(this.tile.k - tile.k) <= range) {
                    return true
                }
            }
            return false
        }
        isInSmallRange(tile) {

            if (tile.t >= 0) {
                if (tile.ice != 1 || this.submerged == 1 || this.mounted == 0) {//tile.occupied == false &&
                    if (Math.abs(this.tile.t - tile.t) <= 0 && Math.abs(this.tile.k - tile.k) <= 0) {
                        // //////////console.log(tile, this)
                        return true
                    }
                } else {
                    if (Math.abs(this.tile.t - tile.t) <= 1 && Math.abs(this.tile.k - tile.k) <= 1) {
                        // //////////console.log(tile, this)
                        return true
                    }
                }
            }
            return false
        }
        isInSmallRangeBonus(tile, bonus) {

            if (tile.t >= 0) {
                if (tile.ice != 1 || this.submerged == 1 || this.mounted == 0) {//tile.occupied == false &&
                    if (Math.abs(this.tile.t - tile.t) <= 0 && Math.abs(this.tile.k - tile.k) <= (0 + bonus)) {
                        // //////////console.log(tile, this)
                        return true
                    }
                } else {
                    if (Math.abs(this.tile.t - tile.t) <= 1 && Math.abs(this.tile.k - tile.k) <= (1 + bonus)) {
                        // //////////console.log(tile, this)
                        return true
                    }
                }
            }
            return false
        }
        isInRange(tile) {
            if (tile.t >= 0) {
                if (Math.abs(this.tile.t - tile.t) <= this.attackrange && Math.abs(this.tile.k - tile.k) <= this.attackrange) {
                    // //////////console.log(tile, this)
                    return true
                }
            }
            return false
        }
        attack() {
            if(onlineNow == 1 && sandmap.players.indexOf(this.faction) != sandmap.turn){
                return
            }
            if (!(this.attacktarget.defense > 0)) {
                // //////////console.log("fis")
                this.attacktarget.defense = 0
            }
            // const scumrat = (this.shots.length * Math.max((this.damage - this.attacktarget.defense), 0))

            for(let d = 1;d<sandmap.players.length;d++){
            const indexer = Math.abs((sandmap.players.indexOf(this.faction) + d)%sandmap.players.length)


            if (this.attacktarget.health <= 0 || !this.isInRange(this.attacktarget.tile) || (this.attacktarget.debt + this.attacktarget.health <= 0)) { //21???



                for (let g = 0; g < sandmap.players[indexer].units.length; g++) {
                    if (this.isInRange(sandmap.players[indexer].units[g].tile)) {
                        if (this.attacktarget != sandmap.players[indexer].units[g] && sandmap.players[indexer].units[g].debt + sandmap.players[indexer].units[g].health > 0) {

                            this.attacksound()
                            this.attacktarget = sandmap.players[indexer].units[g]
                            this.attackindex =  sandmap.players[indexer].units[g].id
                            if (this.faction.isAI == 1) {
                                this.pathToRange = 1
                            }
                            this.attacktargetmover = this.attacktarget
            if(onlineNow == 1){
            }else{
                            this.attacktarget.faction.blocks[this.tile.t][this.tile.k].markdraw = 1
            }
                            if (sandmap.players[indexer].isAI == 1) {
                                sandmap.players[indexer].attackedAt = this.tile

                                if (sandmap.players[indexer].defending < 0) {
                                    sandmap.players[indexer].defending = 1
                                } else {
                                    sandmap.players[indexer].defending += sandmap.players[indexer].units.length
                                }

                            }
                            // break
                            return

                        }
                    }
                }


                this.antilink = new LineOP(this.body, this.body)




                for (let g = 0; g < sandmap.players[indexer].units.length; g++) {
                    this.antilink.target = sandmap.players[indexer].units[g].body
                    if (this.isInRange(sandmap.players[indexer].units[g].tile)) {
                        this.attacksound()
                        if (sandmap.players[indexer].units[g].submerged != 1) {
                            if ((this.attacktarget.debt + this.attacktarget.health <= 0)) {
                                if (this.attacktarget != sandmap.players[indexer].units[g] && sandmap.players[indexer].units[g].debt + sandmap.players[indexer].units[g].health > 0) {

                                    this.attacktarget = sandmap.players[indexer].units[g]
                            this.attackindex =  sandmap.players[indexer].units[g].id
                             if(sandmap.players.indexOf(this.faction) != sandmap.turn){
                                    this.attacktarget.faction.blocks[this.tile.t][this.tile.k].markdraw = 1
                             }
                                    this.faction.context.clearRect((this.attacktarget.tile.x * .1), (this.attacktarget.tile.y * .1), 1, 1)
                                    this.faction.contextx.clearRect((this.attacktarget.tile.x * .1), (this.attacktarget.tile.y * .1), 1, 1)
                                    if (sandmap.players[indexer].isAI == 1) {
                                        sandmap.players[indexer].units[g].ultrabreak = this.tile
                                        sandmap.players[indexer].units[g].attacktarget = this
                                        sandmap.players[indexer].units[g].pathToRange = 1
                                        sandmap.players[indexer].units[g].attacktargetmover = this.attacktarget
                                        sandmap.players[indexer].units[g].ultrawalk = 0
                                        sandmap.players[indexer].units[g].start = sandmap.players[indexer].units[g].tile
                                        sandmap.players[indexer].attackedAt = this.tile
                                        if (sandmap.players[indexer].defending < 0) {
                                            sandmap.players[indexer].defending = 1
                                        } else {
                                            sandmap.players[indexer].defending += sandmap.players[indexer].units.length
                                        }
                                        // }
                                    }
                                    // break
                                    return
                                }
                            } else {

                                if (this.attacktarget != sandmap.players[indexer].units[g] && sandmap.players[indexer].units[g].debt + sandmap.players[indexer].units[g].health > 0) {
                                    this.attacktarget = sandmap.players[indexer].units[g]
                            this.attackindex =  sandmap.players[indexer].units[g].id
                             if(sandmap.players.indexOf(this.faction) != sandmap.turn){
                                    this.attacktarget.faction.blocks[this.tile.t][this.tile.k].markdraw = 1
                             }
                                    this.faction.context.clearRect((this.attacktarget.tile.x * .1), (this.attacktarget.tile.y * .1), 1, 1)
                                    this.faction.contextx.clearRect((this.attacktarget.tile.x * .1), (this.attacktarget.tile.y * .1), 1, 1)
                                    if (sandmap.players[indexer].isAI == 1) {
                                        sandmap.players[indexer].units[g].ultrabreak = this.tile
                                        sandmap.players[indexer].units[g].attacktarget = this
                                        sandmap.players[indexer].units[g].ultrawalk = 0
                                        sandmap.players[indexer].units[g].start = sandmap.players[indexer].units[g].tile
                                        sandmap.players[indexer].attackedAt = this.tile
                                        if (sandmap.players[indexer].defending < 0) {
                                            sandmap.players[indexer].defending = 1
                                        } else {
                                            sandmap.players[indexer].defending += sandmap.players[indexer].units.length
                                        }
                                    }
                                    // break
                                    return
                                }


                            }
                        } else {
                            let wet = 0
                            for (let n = 0; n < this.faction.units.length; n++) { //sandmap.players[Math.abs(sandmap.players.indexOf(this.faction))]
                                sandmap.players[indexer].units[g].gameline.target = this.faction.units[n].body
                                // if (sandmap.players[indexer].units[g].gameline.hypotenuse() <= this.faction.units[n].sight * 10) { //*14??? or no? // was no mult
                                if (this.faction.units[n].isInRange(sandmap.players[indexer].units[g].tile)) { //*14??? or no? // was no mult

                                    if (this.faction.units[n].drone == 1 || this.faction.units[n].imago == 2 || this.faction.units[n].hamartanscout == 1 || this.faction.units[n].pufffellow == 1 || this.faction.units[n].sporevizir == 1) {
                                        wet = 1
                                        break
                                    }
                                }
                            }
                            if (wet == 1) {
                                this.attacktarget = sandmap.players[indexer].units[g]
                            this.attackindex =  sandmap.players[indexer].units[g].id
                            this.attackindex =  sandmap.players[indexer].units[g].id

                             if(sandmap.players.indexOf(this.faction) != sandmap.turn){
                                this.attacktarget.faction.blocks[this.tile.t][this.tile.k].markdraw = 1
                             }
                                // //////////console.log(this.attacktarget.faction.blocks[this.tile.t][this.tile.k])
                                if (sandmap.players[indexer].isAI == 1) {
                                    // if(sandmap.players[indexer].units[g].ultrabreak.id != this.tile.id){


                                    if (this.tile.id != sandmap.players[indexer].units[g].ultrabreak.id && (Math.abs(this.tile.x - sandmap.players[indexer].units[g].ultrabreak.x) < (sandmap.players[indexer].units[g].attackrange * 10) || Math.abs(this.tile.y - sandmap.players[indexer].units[g].ultrabreak.y) < (sandmap.players[indexer].units[g].attackrange * 10))) {

                                        // if(!(sandmap.players[indexer].units[g].megasplat > 0)){
                                        sandmap.players[indexer].units[g].ultrabreak = this.tile
                                        sandmap.players[indexer].units[g].ultrawalk = 0
                                        sandmap.players[indexer].units[g].megasplat = sandmap.players[indexer].units[g].movespeed
                                        sandmap.players[indexer].units[g].start = sandmap.players[indexer].units[g].tile
                                        sandmap.players[indexer].units[g].attacktarget = this
                                        // }
                                    }
                                    sandmap.players[indexer].attackedAt = this.tile

                                    if (sandmap.players[indexer].defending < 0) {
                                        sandmap.players[indexer].defending = 1
                                    } else {
                                        sandmap.players[indexer].defending += sandmap.players[indexer].units.length
                                    }


                                    // }
                                }
                                // break
                                return
                            }
                        }
                    }
                }

                for (let g = 0; g < sandmap.players[indexer].buildings.length; g++) {
                    this.antilink.target = sandmap.players[indexer].buildings[g].body
                    // if (sandmap.players[indexer].units[g].tile == sandmap.blocks[this.tile.t + t][this.tile.k + k]) {
                    // if (this.antilink.hypotenuse() < (this.attackrange *17.11)) {

                    if (this.isInRange(sandmap.players[indexer].buildings[g].tile)) {

                        if (this.attacktarget != sandmap.players[indexer].buildings[g] && sandmap.players[indexer].buildings[g].debt + sandmap.players[indexer].buildings[g].health > 0) {
                            // if(this.attacktarget != sandmap.players[indexer].buildings[g]){
                            this.attacktarget = sandmap.players[indexer].buildings[g]
                            this.attackindex =  sandmap.players[indexer].buildings[g].id
                             if(sandmap.players.indexOf(this.faction) != sandmap.turn){
                            this.attacktarget.faction.blocks[this.tile.t][this.tile.k].markdraw = 1
                             }
                            this.attacktarget.isABuilding = 1

                            if (sandmap.players[indexer].isAI == 1) {
                                sandmap.players[indexer].attackedAt = this.tile

                                if (sandmap.players[indexer].defending < 0) {
                                    sandmap.players[indexer].defending = 1
                                } else {
                                    sandmap.players[indexer].defending += sandmap.players[indexer].units.length
                                }

                            }
                            // break
                            return

                        }
                    }
                }
            } else {
            }
        }




        }
        smartAttack() {
            
            if(onlineNow == 1 && sandmap.players.indexOf(this.faction) != sandmap.turn){
                return
            }
            if (!(this.attacktarget.defense > 0)) {
                // //////////console.log("fis")
                this.attacktarget.defense = 0
            }
            // const scumrat = (this.shots.length * Math.max((this.damage - this.attacktarget.defense), 0))

            for(let d = 1;d<sandmap.players.length;d++){
                
            const indexer = Math.abs((sandmap.players.indexOf(this.faction) + d)%sandmap.players.length)


            if (this.attacktarget.health <= 0 || !this.isInRange(this.attacktarget.tile) || (this.attacktarget.debt + this.attacktarget.health <= 0)) { //21???
            }


            for (let g = 0; g < sandmap.players[indexer].units.length; g++) {
                if (this.isInRange(sandmap.players[indexer].units[g].tile)) {
                    if (this.attacktarget != sandmap.players[indexer].units[g] && sandmap.players[indexer].units[g].debt + sandmap.players[indexer].units[g].health > 0) {
                        if (this.attacktarget.health <= 0 || this.attacktarget.debt + this.attacktarget.health > sandmap.players[indexer].units[g].debt + sandmap.players[indexer].units[g].health) {
                            this.attacksound()
                            this.attacktarget = sandmap.players[indexer].units[g]
                            if (this.faction.isAI == 1) {
                                this.pathToRange = 1
                            }
                            this.attacktargetmover = this.attacktarget

                             if(sandmap.players.indexOf(this.faction) != sandmap.turn){
                                this.attacktarget.faction.blocks[this.tile.t][this.tile.k].markdraw = 1
                            }
                            if (sandmap.players[indexer].isAI == 1) {
                                sandmap.players[indexer].attackedAt = this.tile

                                if (sandmap.players[indexer].defending < 0) {
                                    sandmap.players[indexer].defending = 1
                                } else {
                                    sandmap.players[indexer].defending += sandmap.players[indexer].units.length
                                }

                            }
                        }
                        // break
                        // return

                    }
                }
            }
        }
            return

            this.antilink = new LineOP(this.body, this.body)




            for (let g = 0; g < sandmap.players[indexer].units.length; g++) {
                this.antilink.target = sandmap.players[indexer].units[g].body
                if (this.isInRange(sandmap.players[indexer].units[g].tile)) {
                    this.attacksound()
                    if (sandmap.players[indexer].units[g].submerged != 1) {
                        if ((this.attacktarget.debt + this.attacktarget.health <= 0)) {
                            if (this.attacktarget != sandmap.players[indexer].units[g] && sandmap.players[indexer].units[g].debt + sandmap.players[indexer].units[g].health > 0) {

                                this.attacktarget = sandmap.players[indexer].units[g]
                             if(sandmap.players.indexOf(this.faction) != sandmap.turn){
                                this.attacktarget.faction.blocks[this.tile.t][this.tile.k].markdraw = 1
                             }
                                this.faction.context.clearRect((this.attacktarget.tile.x * .1), (this.attacktarget.tile.y * .1), 1, 1)
                                this.faction.contextx.clearRect((this.attacktarget.tile.x * .1), (this.attacktarget.tile.y * .1), 1, 1)
                                if (sandmap.players[indexer].isAI == 1) {
                                    sandmap.players[indexer].units[g].ultrabreak = this.tile
                                    sandmap.players[indexer].units[g].attacktarget = this
                                    sandmap.players[indexer].units[g].pathToRange = 1
                                    sandmap.players[indexer].units[g].attacktargetmover = this.attacktarget
                                    sandmap.players[indexer].units[g].ultrawalk = 0
                                    sandmap.players[indexer].units[g].start = sandmap.players[indexer].units[g].tile
                                    sandmap.players[indexer].attackedAt = this.tile
                                    if (sandmap.players[indexer].defending < 0) {
                                        sandmap.players[indexer].defending = 1
                                    } else {
                                        sandmap.players[indexer].defending += sandmap.players[indexer].units.length
                                    }
                                    // }
                                }
                                // break
                                return
                            }
                        } else {

                            if (this.attacktarget != sandmap.players[indexer].units[g] && sandmap.players[indexer].units[g].debt + sandmap.players[indexer].units[g].health > 0) {
                                this.attacktarget = sandmap.players[indexer].units[g]
                             if(sandmap.players.indexOf(this.faction) != sandmap.turn){
                                this.attacktarget.faction.blocks[this.tile.t][this.tile.k].markdraw = 1
                             }
                                this.faction.context.clearRect((this.attacktarget.tile.x * .1), (this.attacktarget.tile.y * .1), 1, 1)
                                this.faction.contextx.clearRect((this.attacktarget.tile.x * .1), (this.attacktarget.tile.y * .1), 1, 1)
                                if (sandmap.players[indexer].isAI == 1) {
                                    sandmap.players[indexer].units[g].ultrabreak = this.tile
                                    sandmap.players[indexer].units[g].attacktarget = this
                                    sandmap.players[indexer].units[g].ultrawalk = 0
                                    sandmap.players[indexer].units[g].start = sandmap.players[indexer].units[g].tile
                                    sandmap.players[indexer].attackedAt = this.tile
                                    if (sandmap.players[indexer].defending < 0) {
                                        sandmap.players[indexer].defending = 1
                                    } else {
                                        sandmap.players[indexer].defending += sandmap.players[indexer].units.length
                                    }
                                }
                                // break
                                return
                            }


                        }
                    } else {
                        let wet = 0
                        for (let n = 0; n < this.faction.units.length; n++) { //sandmap.players[Math.abs(sandmap.players.indexOf(this.faction))]
                            sandmap.players[indexer].units[g].gameline.target = this.faction.units[n].body
                            // if (sandmap.players[indexer].units[g].gameline.hypotenuse() <= this.faction.units[n].sight * 10) { //*14??? or no? // was no mult
                            if (this.faction.units[n].isInRange(sandmap.players[indexer].units[g].tile)) { //*14??? or no? // was no mult

                                if (this.faction.units[n].drone == 1 || this.faction.units[n].imago == 2 || this.faction.units[n].hamartanscout == 1 || this.faction.units[n].pufffellow == 1 || this.faction.units[n].sporevizir == 1) {
                                    wet = 1
                                    break
                                }
                            }
                        }
                        if (wet == 1) {
                            this.attacktarget = sandmap.players[indexer].units[g]

                             if(sandmap.players.indexOf(this.faction) != sandmap.turn){
                            this.attacktarget.faction.blocks[this.tile.t][this.tile.k].markdraw = 1
                             }
                            // //////////console.log(this.attacktarget.faction.blocks[this.tile.t][this.tile.k])
                            if (sandmap.players[indexer].isAI == 1) {
                                // if(sandmap.players[indexer].units[g].ultrabreak.id != this.tile.id){


                                if (this.tile.id != sandmap.players[indexer].units[g].ultrabreak.id && (Math.abs(this.tile.x - sandmap.players[indexer].units[g].ultrabreak.x) < (sandmap.players[indexer].units[g].attackrange * 10) || Math.abs(this.tile.y - sandmap.players[indexer].units[g].ultrabreak.y) < (sandmap.players[indexer].units[g].attackrange * 10))) {

                                    // if(!(sandmap.players[indexer].units[g].megasplat > 0)){
                                    sandmap.players[indexer].units[g].ultrabreak = this.tile
                                    sandmap.players[indexer].units[g].ultrawalk = 0
                                    sandmap.players[indexer].units[g].megasplat = sandmap.players[indexer].units[g].movespeed
                                    sandmap.players[indexer].units[g].start = sandmap.players[indexer].units[g].tile
                                    sandmap.players[indexer].units[g].attacktarget = this
                                    // }
                                }
                                sandmap.players[indexer].attackedAt = this.tile

                                if (sandmap.players[indexer].defending < 0) {
                                    sandmap.players[indexer].defending = 1
                                } else {
                                    sandmap.players[indexer].defending += sandmap.players[indexer].units.length
                                }


                                // }
                            }
                            // break
                            return
                        }
                    }
                }
            }

            for (let g = 0; g < sandmap.players[indexer].buildings.length; g++) {
                this.antilink.target = sandmap.players[indexer].buildings[g].body
                // if (sandmap.players[indexer].units[g].tile == sandmap.blocks[this.tile.t + t][this.tile.k + k]) {
                // if (this.antilink.hypotenuse() < (this.attackrange *17.11)) {

                if (this.isInRange(sandmap.players[indexer].buildings[g].tile)) {

                    if (this.attacktarget != sandmap.players[indexer].buildings[g] && sandmap.players[indexer].buildings[g].debt + sandmap.players[indexer].buildings[g].health > 0) {
                        // if(this.attacktarget != sandmap.players[indexer].buildings[g]){
                        this.attacktarget = sandmap.players[indexer].buildings[g]
                             if(sandmap.players.indexOf(this.faction) != sandmap.turn){
                        this.attacktarget.faction.blocks[this.tile.t][this.tile.k].markdraw = 1
                             }
                        this.attacktarget.isABuilding = 1

                        if (sandmap.players[indexer].isAI == 1) {
                            sandmap.players[indexer].attackedAt = this.tile

                            if (sandmap.players[indexer].defending < 0) {
                                sandmap.players[indexer].defending = 1
                            } else {
                                sandmap.players[indexer].defending += sandmap.players[indexer].units.length
                            }

                        }
                        // break
                        return

                    }
                }
            }
            // } else {
            // }





        }
        shoot() {





            if(onlineNow == 1 && sandmap.players.indexOf(this.faction) != sandmap.turn){
                return
            }

            if(typeof this.attacktarget == "undefined"){
                return
            }else{
                if(typeof this.attacktarget.body == "undefined"){
                    return
                }else{
                    if(typeof this.attacktarget.body.x == "undefined"){
                        return
                    }
                }
            }
               if(sandmap.players.indexOf(this.faction) != sandmap.turn){

            if (this.attacktarget.health > 0) {
                this.attacktarget.faction.context.clearRect((this.tile.x * .1), (this.tile.y * .1), 1, 1)
                this.attacktarget.faction.contextx.clearRect((this.tile.x * .1), (this.tile.y * .1), 1, 1)
            }
               }else{

               }
            if (Math.abs(this.attacktarget.tile.x - this.tile.x) + Math.abs((this.attacktarget.tile.y - this.tile.y)) > (this.attackrange * 21)) { //21???
                this.attacktarget = {}
                this.attacktarget.tile = {}
                this.attacktarget.health = 0
                return
            }

            this.attackcounter += this.firerate
            // for(let d = 1;d<sandmap.players.length;d++){
            const indexer =  1// Math.abs((sandmap.players.indexOf(this.faction) + d)%sandmap.players.length)
            if (this.attackcounter > (gargantuanNumber * 5) && this.submerged != 1) { //3 because 0 strikeout
                this.attackcounter = 1
                const shot = new UnitCircle(this.body.x, this.body.y, 2, this.faction.color)
                shot.attacktarget = {}
                shot.attacktarget.tile = {}
                shot.attacktarget.body = new UnitCircle(this.attacktarget.body.x, this.attacktarget.body.y, 1, "transparent")
                shot.projectilespeed = this.projectilespeed
                shot.refhealth = this.attacktarget
                shot.refhealth.factionNum = this.attacktarget.factionNum
                // shot.refhealth.factionNum = sandmap.players.indexOf(this.attacktarget.faction)
                this.attacktarget.debt -= Math.max((this.damage * 3) - this.attacktarget.defense, 0)
                shot.attacktarget.defense = this.attacktarget.defense
                shot.stage = 0
                this.shots.push(shot)

                
                        let grid = []
                        //console.log(this, this.tile, this.tile.t, this.attacktarget)
                        let tk = (0.5 * (Math.round(this.tile.t) + this.tile.k) * (Math.round(this.tile.t) + this.tile.k + 1)) + this.tile.k
                        tk+= this.attacktarget.id
                        //console.log(tk)
                        grid.push({c:tk})
                        //console.log(grid)
                        let Json = {}
                        Json.array = [...grid]
                        Json.player = sandmap.turn
                        if(this.attacktarget.built == 1 ){

                        Json.dot = 2
                        }else{

                        Json.dot = 1
                        }
                        Json.player = this.attacktarget.factionNum
                            ////////console.log(Json)
                        if(campaignController.on !== 1 && AImode != 1){
                        //console.log(Json)

                            ws.send(JSON.stringify(Json))
                        }




                if (campaignController.mission > -1) {
                    sandmap.players[indexer].attackedAt = this.tile
                    if (sandmap.players[indexer].defending < 0) {
                        sandmap.players[indexer].defending = 20
                    } else {
                        sandmap.players[indexer].defending += 100
                    }
                    //////////console.log(sandmap.players[indexer].attackedAt)
                }

            }
            // }
        }
        smartAttackmove() {

            if(onlineNow == 1 && sandmap.players.indexOf(this.faction) != sandmap.turn){
                return
            }
            if (typeof this.attacktargetmove.tile != "undefined") {
                if (this.isInRange(this.attacktargetmove.tile) && this.attacktargetmove.debt + this.attacktargetmove.health > 0) {
                    // //////////console.log("skip")
                    return
                }
            }
            if (!(this.megasplat > 0)) {

                if (this.cooloff <= 0) {

            for(let d = 1;d<sandmap.players.length;d++){
                    const indexer = Math.abs((sandmap.players.indexOf(this.faction) + d)%sandmap.players.length)
                    if (this.attacktargetmove.health <= 0 || !this.isInRange(this.attacktargetmove.tile)) {
                        // for (let  t = -this.sight; t <= this.sight; t++) {
                        //     for (let  k = -this.sight; k <= this.sight; k++) {
                        //         if (this.tile.t + t >= 0) {
                        //             if (this.tile.k + k >= 0) {
                        //                 if (this.tile.t + t < worldscale) {
                        //                     if (this.tile.k + k < worldscale) {
                        //                         if (typeof (sandmap.blocks[this.tile.t + t] != undefined)) {
                        //                             if (typeof (sandmap.blocks[this.tile.t + t][this.tile.k + k] != undefined)) {
                        this.antilink = new LineOP(this.body, this.body)
                        for (let g = 0; g < sandmap.players[indexer].units.length; g++) {
                            this.antilink.target = sandmap.players[indexer].units[g].body
                            // if (sandmap.players[indexer].units[g].tile == sandmap.blocks[this.tile.t + t][this.tile.k + k]) {
                            // if (this.antilink.hypotenuse() <= (this.sight *17.11)) { //should probably be 14

                            if (this.isInRange(sandmap.players[indexer].units[g].tile)) {

                                //////////console.log("???2")
                                if (sandmap.players[indexer].units[g] != this.attacktargetmove) {

                                    if (sandmap.players[indexer].units[g].health < this.attacktargetmove.health || this.attacktargetmove.health <= 0) {
                                        this.attacktargetmove = sandmap.players[indexer].units[g]
                                        this.attacktarget = sandmap.players[indexer].units[g]
                                    }

                                    // sandmap.players[indexer].context.clearRect((this.attacktargetmove.tile.x * .1), (this.attacktargetmove.tile.y * .1), 1, 1)
                                    //  sandmap.players[indexer].contextx.clearRect((this.attacktargetmove.tile.x * .1), (this.attacktargetmove.tile.y * .1), 1, 1)
                                    if (typeof this.ultrabreak != "undefined") {
                                        if (this.ultrabreak.id != sandmap.players[indexer].units[g].tile.id && (Math.abs(this.ultrabreak.x - sandmap.players[indexer].units[g].tile.x) > (this.attackrange * 10) || Math.abs(this.ultrabreak.y - sandmap.players[indexer].units[g].tile.y) > (this.attackrange * 10))) {
                                            this.ultrabreak = this.attacktargetmove.tile
                                            this.ultrawalk = 0
                                            this.megasplat = this.movespeed
                                            if (this.faction.isAI == 1) {
                                                this.pathToRange = 1
                                            }
                                            this.attacktargetmover = this.attacktargetmove
                                            this.start = this.tile
                                            if (this.faction.type == 1) {
                                                this.hotrockrepathlimit = this.movespeed * this.sight
                                                this.defensepathlimit = this.movespeed * this.sight
                                            }
                                        }
                                    }
                                    // this.cooloff = 9

                                    if (this.isAI == 1) {
                                        if (sandmap.players[indexer].defending < 0) {
                                            sandmap.players[indexer].defending = 1
                                        } else {
                                            sandmap.players[indexer].defending += sandmap.players[indexer].units.length
                                        }
                                    }

                                    if (this.tile.walkable == false || this.tile.ice == 1 || this.tile.builtOn == 1) {
                                    } else {
                                        this.submerged = 0
                                    }
                                    // break
                                }
                            }
                        }
                        for (let g = 0; g < sandmap.players[indexer].buildings.length; g++) {
                            this.antilink.target = sandmap.players[indexer].buildings[g].body
                            // if (sandmap.players[indexer].buildings[g].tile == sandmap.blocks[this.tile.t + t][this.tile.k + k]) {
                            // if (this.antilink.hypotenuse() <= (this.sight *17.11)) {

                            if (this.isInRange(sandmap.players[indexer].buildings[g].tile)) {
                                //////////console.log("???")



                                if (sandmap.players[indexer].buildings[g] != this.attacktargetmove) {
                                    this.attacktargetmove = sandmap.players[indexer].buildings[g]
                                    if (typeof this.ultrabreak != "undefined") {
                                        if (this.ultrabreak.id != sandmap.players[indexer].buildings[g].tile.id && (Math.abs(this.ultrabreak.x - sandmap.players[indexer].buildings[g].tile.x) > (this.attackrange * 10) || Math.abs(this.ultrabreak.y - sandmap.players[indexer].buildings[g].tile.y) > (this.attackrange * 10))) {
                                            this.ultrabreak = this.attacktargetmove.tile
                                            this.ultrawalk = 0
                                            this.start = this.tile
                                            this.megasplat = this.movespeed
                                            if (this.faction.isAI == 1) {
                                                this.pathToRange = 1
                                            }
                                            this.attacktargetmover = this.attacktargetmove
                                            if (this.faction.type == 1) {
                                                this.hotrockrepathlimit = this.movespeed * this.sight
                                                this.defensepathlimit = this.movespeed * this.sight
                                            }
                                        }
                                    }
                                    // this.cooloff = 9

                                    if (this.isAI == 1) {
                                        if (sandmap.players[indexer].defending < 0) {
                                            sandmap.players[indexer].defending = 1
                                        } else {
                                            sandmap.players[indexer].defending += sandmap.players[indexer].units.length
                                        }
                                    }

                                    if (this.tile.walkable == false || this.tile.ice == 1 || this.tile.builtOn == 1) {
                                    } else {
                                        this.submerged = 0
                                    }
                                    break
                                }
                            }



                        }
                        for (let g = 0; g < sandmap.players[indexer].units.length; g++) {
                            this.antilink.target = sandmap.players[indexer].units[g].body
                            // if (sandmap.players[indexer].units[g].tile == sandmap.blocks[this.tile.t + t][this.tile.k + k]) {
                            // if (this.antilink.hypotenuse() <= (this.sight *17.11)) { //should probably be 14  //was 17

                            if (this.isInRange(sandmap.players[indexer].units[g].tile)) {

                                if (sandmap.players[indexer].units[g] != this.attacktargetmove) {

                                    //////////console.log("???3")
                                    this.attacktargetmove = sandmap.players[indexer].units[g]
                                    // sandmap.players[indexer].context.clearRect((this.attacktargetmove.tile.x * .1), (this.attacktargetmove.tile.y * .1), 1, 1)
                                    //  sandmap.players[indexer].contextx.clearRect((this.attacktargetmove.tile.x * .1), (this.attacktargetmove.tile.y * .1), 1, 1)


                                    if (this.isAI == 1) {
                                        if (sandmap.players[indexer].defending < 0) {
                                            sandmap.players[indexer].defending = 1
                                        } else {
                                            sandmap.players[indexer].defending += sandmap.players[indexer].units.length
                                        }
                                    }

                                    if (this.ultrabreak.id != sandmap.players[indexer].units[g].tile.id && (Math.abs(this.ultrabreak.x - sandmap.players[indexer].units[g].tile.x) > (this.attackrange * 10) || Math.abs(this.ultrabreak.y - sandmap.players[indexer].units[g].tile.y) > (this.attackrange * 10))) {
                                        this.ultrabreak = this.attacktargetmove.tile
                                        this.ultrawalk = 0
                                        this.megasplat = this.movespeed
                                        this.start = this.tile
                                        if (this.faction.type == 1) {
                                            this.hotrockrepathlimit = this.movespeed * this.sight
                                            this.defensepathlimit = this.movespeed * this.sight
                                        }
                                    }


                                    if (this.tile.walkable == false || this.tile.ice == 1 || this.tile.builtOn == 1) {
                                    } else {
                                        this.submerged = 0
                                    }
                                    break
                                }
                            }
                        }
                    } else {
                        if (Math.abs(this.attacktargetmove.tile.x - this.tile.x) + Math.abs((this.attacktargetmove.tile.y - this.tile.y)) > (this.sight * 21)) {
                            this.attacktargetmove = {}
                            this.attacktargetmove.health = 0
                            return
                        }
                    }
                }
                }
                this.cooloff--
            }

        }
        attackmove() {

            if(onlineNow == 1 && sandmap.players.indexOf(this.faction) != sandmap.turn){
                return
            }
            if (typeof this.attacktargetmove.tile != "undefined") {
                if (this.isInRange(this.attacktargetmove.tile) && this.attacktargetmove.debt + this.attacktargetmove.health > 0) {
                    // //////////console.log("skip")
                    return
                }
            }
            if (!(this.megasplat > 0)) {

                if (this.cooloff <= 0) {

            for(let d = 1;d<sandmap.players.length;d++){
                    const indexer = Math.abs((sandmap.players.indexOf(this.faction) + d)%sandmap.players.length)
                    if (this.attacktargetmove.health <= 0 || !this.isInRange(this.attacktargetmove.tile)) {
                        // for (let  t = -this.sight; t <= this.sight; t++) {
                        //     for (let  k = -this.sight; k <= this.sight; k++) {
                        //         if (this.tile.t + t >= 0) {
                        //             if (this.tile.k + k >= 0) {
                        //                 if (this.tile.t + t < worldscale) {
                        //                     if (this.tile.k + k < worldscale) {
                        //                         if (typeof (sandmap.blocks[this.tile.t + t] != undefined)) {
                        //                             if (typeof (sandmap.blocks[this.tile.t + t][this.tile.k + k] != undefined)) {
                        this.antilink = new LineOP(this.body, this.body)
                        for (let g = 0; g < sandmap.players[indexer].units.length; g++) {
                            this.antilink.target = sandmap.players[indexer].units[g].body
                            // if (sandmap.players[indexer].units[g].tile == sandmap.blocks[this.tile.t + t][this.tile.k + k]) {
                            // if (this.antilink.hypotenuse() <= (this.sight *17.11)) { //should probably be 14

                            if (this.isInRange(sandmap.players[indexer].units[g].tile)) {

                                //////////console.log("???2")
                                if (sandmap.players[indexer].units[g] != this.attacktargetmove) {

                                    this.attacktargetmove = sandmap.players[indexer].units[g]

                                    // sandmap.players[indexer].context.clearRect((this.attacktargetmove.tile.x * .1), (this.attacktargetmove.tile.y * .1), 1, 1)
                                    //  sandmap.players[indexer].contextx.clearRect((this.attacktargetmove.tile.x * .1), (this.attacktargetmove.tile.y * .1), 1, 1)
                                    if (typeof this.ultrabreak != "undefined") {
                                        if (this.ultrabreak.id != sandmap.players[indexer].units[g].tile.id && (Math.abs(this.ultrabreak.x - sandmap.players[indexer].units[g].tile.x) > (this.attackrange * 10) || Math.abs(this.ultrabreak.y - sandmap.players[indexer].units[g].tile.y) > (this.attackrange * 10))) {
                                            this.ultrabreak = this.attacktargetmove.tile
                                            this.ultrawalk = 0
                                            this.megasplat = this.movespeed
                                            if (this.faction.isAI == 1) {
                                                this.pathToRange = 1
                                            }
                                            this.attacktargetmover = this.attacktargetmove
                                            this.start = this.tile
                                            if (this.faction.type == 1) {
                                                this.hotrockrepathlimit = this.movespeed * this.sight
                                                this.defensepathlimit = this.movespeed * this.sight
                                            }
                                        }
                                    }
                                    // this.cooloff = 9

                                    if (this.isAI == 1) {
                                        if (sandmap.players[indexer].defending < 0) {
                                            sandmap.players[indexer].defending = 1
                                        } else {
                                            sandmap.players[indexer].defending += sandmap.players[indexer].units.length
                                        }
                                    }

                                    if (this.tile.walkable == false || this.tile.ice == 1 || this.tile.builtOn == 1) {
                                    } else {
                                        this.submerged = 0
                                    }
                                    break
                                }
                            }
                        }
                        for (let g = 0; g < sandmap.players[indexer].buildings.length; g++) {
                            this.antilink.target = sandmap.players[indexer].buildings[g].body
                            // if (sandmap.players[indexer].buildings[g].tile == sandmap.blocks[this.tile.t + t][this.tile.k + k]) {
                            // if (this.antilink.hypotenuse() <= (this.sight *17.11)) {

                            if (this.isInRange(sandmap.players[indexer].buildings[g].tile)) {
                                //////////console.log("???")



                                if (sandmap.players[indexer].buildings[g] != this.attacktargetmove) {
                                    this.attacktargetmove = sandmap.players[indexer].buildings[g]
                                    if (typeof this.ultrabreak != "undefined") {
                                        if (this.ultrabreak.id != sandmap.players[indexer].buildings[g].tile.id && (Math.abs(this.ultrabreak.x - sandmap.players[indexer].buildings[g].tile.x) > (this.attackrange * 10) || Math.abs(this.ultrabreak.y - sandmap.players[indexer].buildings[g].tile.y) > (this.attackrange * 10))) {
                                            this.ultrabreak = this.attacktargetmove.tile
                                            this.ultrawalk = 0
                                            this.start = this.tile
                                            this.megasplat = this.movespeed
                                            if (this.faction.isAI == 1) {
                                                this.pathToRange = 1
                                            }
                                            this.attacktargetmover = this.attacktargetmove
                                            if (this.faction.type == 1) {
                                                this.hotrockrepathlimit = this.movespeed * this.sight
                                                this.defensepathlimit = this.movespeed * this.sight
                                            }
                                        }
                                    }
                                    // this.cooloff = 9

                                    if (this.isAI == 1) {
                                        if (sandmap.players[indexer].defending < 0) {
                                            sandmap.players[indexer].defending = 1
                                        } else {
                                            sandmap.players[indexer].defending += sandmap.players[indexer].units.length
                                        }
                                    }

                                    if (this.tile.walkable == false || this.tile.ice == 1 || this.tile.builtOn == 1) {
                                    } else {
                                        this.submerged = 0
                                    }
                                    break
                                }
                            }



                        }
                        for (let g = 0; g < sandmap.players[indexer].units.length; g++) {
                            this.antilink.target = sandmap.players[indexer].units[g].body
                            // if (sandmap.players[indexer].units[g].tile == sandmap.blocks[this.tile.t + t][this.tile.k + k]) {
                            // if (this.antilink.hypotenuse() <= (this.sight *17.11)) { //should probably be 14  //was 17

                            if (this.isInRange(sandmap.players[indexer].units[g].tile)) {

                                if (sandmap.players[indexer].units[g] != this.attacktargetmove) {

                                    //////////console.log("???3")
                                    this.attacktargetmove = sandmap.players[indexer].units[g]
                                    // sandmap.players[indexer].context.clearRect((this.attacktargetmove.tile.x * .1), (this.attacktargetmove.tile.y * .1), 1, 1)
                                    //  sandmap.players[indexer].contextx.clearRect((this.attacktargetmove.tile.x * .1), (this.attacktargetmove.tile.y * .1), 1, 1)


                                    if (this.isAI == 1) {
                                        if (sandmap.players[indexer].defending < 0) {
                                            sandmap.players[indexer].defending = 1
                                        } else {
                                            sandmap.players[indexer].defending += sandmap.players[indexer].units.length
                                        }
                                    }

                                    if (this.ultrabreak.id != sandmap.players[indexer].units[g].tile.id && (Math.abs(this.ultrabreak.x - sandmap.players[indexer].units[g].tile.x) > (this.attackrange * 10) || Math.abs(this.ultrabreak.y - sandmap.players[indexer].units[g].tile.y) > (this.attackrange * 10))) {
                                        this.ultrabreak = this.attacktargetmove.tile
                                        this.ultrawalk = 0
                                        this.megasplat = this.movespeed
                                        this.start = this.tile
                                        if (this.faction.type == 1) {
                                            this.hotrockrepathlimit = this.movespeed * this.sight
                                            this.defensepathlimit = this.movespeed * this.sight
                                        }
                                    }


                                    if (this.tile.walkable == false || this.tile.ice == 1 || this.tile.builtOn == 1) {
                                    } else {
                                        this.submerged = 0
                                    }
                                    break
                                }
                            }
                        }
                    } else {
                        if (Math.abs(this.attacktargetmove.tile.x - this.tile.x) + Math.abs((this.attacktargetmove.tile.y - this.tile.y)) > (this.sight * 21)) {
                            this.attacktargetmove = {}
                            this.attacktargetmove.health = 0
                            return
                        }
                    }
                }
            }
                this.cooloff--
            }

        }
        attackmoveunit() {
            if (this.cooloff <= 0) {
                if (this.attacktargetmove.health <= 0 || !this.isInRange(this.attacktargetmove.tile)) {

            for(let d = 1;d<sandmap.players.length;d++){
                    const indexer = Math.abs((sandmap.players.indexOf(this.faction) + d)%sandmap.players.length)
                    this.antilink = new LineOP(this.body, this.body)
                    for (let g = 0; g < sandmap.players[indexer].units.length; g++) {
                        this.antilink.target = sandmap.players[indexer].units[g].body
                        // if (sandmap.players[Math.abs(sandmap.players.indexOf(this.faction) - 1)].units[g].tile == sandmap.blocks[this.tile.t + t][this.tile.k + k]) {
                        // if (this.antilink.hypotenuse() <= (this.sight *17.11)) { //should probably be 14 //was 17

                        if (this.isInRange(sandmap.players[indexer].units[g].tile)) {
                            this.attacktargetmove = sandmap.players[indexer].units[g]

                            if (this.ultrabreak.id != sandmap.players[indexer].units[g].tile.id && (Math.abs(this.ultrabreak.x - sandmap.players[indexer].units[g].tile.x) > (this.attackrange * 10) || Math.abs(this.ultrabreak.y - sandmap.players[indexer].units[g].tile.y) > (this.attackrange * 10))) {

                                this.ultrabreak = this.attacktargetmove.tile
                                this.ultrawalk = 0
                                this.start = this.tile
                            }


                            this.cooloff += 12
                            if (this.tile.walkable == false || this.tile.ice == 1 || this.tile.builtOn == 1) {
                            } else {
                                this.submerged = 0
                            }
                            break
                        }
                    }
                }
                } else {
                    if (Math.abs(this.attacktargetmove.tile.x - this.tile.x) + Math.abs((this.attacktargetmove.tile.y - this.tile.y)) > (this.sight * 21)) {
                        this.attacktargetmove = {}
                        this.attacktargetmove.health = 0
                        return
                    }
                }
            }
            this.cooloff--
        }
        pathTo(point, g = 1) { //Math.sign(campaignController.mission) //Math.sign(campaignController.mission)
            // if (this.faction.isAI == 1) {
            //     this.pathToForAI(point, g)
            //     return
            // }
            if (this.omegalimit > 0) {
                return
            }
            this.lockout = (this.movespeed + Math.floor(Math.random() * this.movespeed * 3)) * 3
            if (typeof point == "undefined") {
                return
            }

            if (point == this.emergencyTarget) {
                this.ultrabreak = point
                this.start = this.tile
                if (this.ultrawalk > ((this.movespeed + 5) * (this.realPath.length + 5)) * 20) {
                    this.ultrawalk = 1
                }
            }
            this.start = this.tile
            if (g == 1) {
                this.ultrabreak = point
            }
            if (this.stacksnap > 10) {
                return
            }
            if (point != this.realPath[this.realPath.length - 1]) {
                this.vec = new Vector(this.body, this.body.x - (this.tile.x + 5), this.body.y - (this.tile.y + 5))
                this.spot = new Point(point.x + 5, point.y + 5)
                if (!this.vec.isToward(this.spot)) {
                    this.movespeedcount = 0
                }
            }
            this.stepout = 1
            if (this.submerged == 1 || this.mounted == 0) {
                this.pather = liarsastar //big if?
            } else {
                this.pather = astar
            }
            this.pather.agent = this
            this.obvious = this.realPath[this.index]
            this.pathsto = []
            for (let t = 0; t < this.realPath.length; t++) {
                this.pathsto.push(this.realPath[t])
            }
            this.stacksnap++
            let options = {}
            options.closest = true
            if (this.faction.isAI != 1) {
            } else {

                // this.omegalimit = 30

            }
            this.realPath = [...this.pather.search(sandmap, this.tile, point, options, this)]
            this.cooloff = this.movespeed * 2
            this.moved = 1
            this.heatmoved = 1
            if (this.obvious == this.realPath[0]) {
                this.index = 0
            } else {
                this.realPath = [...this.pathsto]
                this.repath = 25 + Math.floor(Math.random() * 25) //10
                this.snapto = point
            }
        }
        see() {
            if(onlineNow == 1 && sandmap.players.indexOf(this.faction) != sandmap.turn){
                return
            }
            for (let t = -this.sight; t <= this.sight; t++) {
                for (let k = -this.sight; k <= this.sight; k++) {
                    if (this.tile.t + t >= 0) {
                        if (this.tile.k + k >= 0) {
                            if (this.tile.t + t < worldscale) {
                                if (this.tile.k + k < worldscale) {
                                    // if (typeof (sandmap.blocks[this.tile.t + t] != undefined)) {
                                    //     if (typeof (sandmap.blocks[this.tile.t + t][this.tile.k + k] != undefined)) {
                                    // this.faction.fog[this.tile.t + t][this.tile.k + k].color = "transparent"
                                    // this.faction.fog[this.tile.t + t][this.tile.k + k].timer = 100
                                    this.faction.blocks[this.tile.t + t][this.tile.k + k].markdraw = 1
                                    // //////////console.log("ebebbe")
                                    if (!sandmap.blocks[this.tile.t + t][this.tile.k + k].factions.includes(sandmap.players.indexOf(this.faction))) {
                                        sandmap.blocks[this.tile.t + t][this.tile.k + k].factions.push(sandmap.players.indexOf(this.faction))
                                        this.faction.seen.push(sandmap.blocks[this.tile.t + t][this.tile.k + k])
                                        if (!sandmap.blocks[this.tile.t + t][this.tile.k + k].factionsrock.includes(sandmap.players.indexOf(this.faction)) && sandmap.blocks[this.tile.t + t][this.tile.k + k].sourcerock > 0) {
                                            // this.faction.clickrate++
                                            sandmap.blocks[this.tile.t + t][this.tile.k + k].factionsrock.push(sandmap.players.indexOf(this.faction))
                                            this.faction.seenrocks.push(sandmap.blocks[this.tile.t + t][this.tile.k + k])
                                            //////////console.log(sandmap.blocks[this.tile.t + t][this.tile.k + k].factionsrock)
                                        } else {
                                            sandmap.blocks[this.tile.t + t][this.tile.k + k].factionsrock.push(sandmap.players.indexOf(this.faction))
                                        }
                                    }
                                    //     }
                                    // }
                                }
                            }
                        }
                    }
                }
            }
        }
        heatwallcheck() {
            this.dirs1 = 0
            this.dirs2 = 0
            this.dirs3 = 0
            this.dirs4 = 0
            for (let t = 0; t < this.faction.buildings.length; t++) {
                for (let k = 0; k < this.faction.buildings[t].tiles.length; k++) {
                    if (this.dirs1 == 0) {// right
                        if (this.faction.buildings[t].tiles[k].x >= this.tile.x) {
                            if (this.faction.buildings[t].tiles[k].y == this.tile.y) {
                                this.dirs1 += 1
                            }
                        }
                    }
                    if (this.dirs2 == 0) {// down
                        if (this.faction.buildings[t].tiles[k].y >= this.tile.y) {
                            if (this.faction.buildings[t].tiles[k].x == this.tile.x) {
                                this.dirs2 += 1
                            }
                        }
                    }
                    if (this.dirs3 == 0) { // left
                        if (this.faction.buildings[t].tiles[k].x <= this.tile.x) {
                            if (this.faction.buildings[t].tiles[k].y == this.tile.y) {
                                this.dirs3 += 1
                            }
                        }
                    }
                    if (this.dirs4 == 0) {  // up
                        if (this.faction.buildings[t].tiles[k].y <= this.tile.y) {
                            if (this.faction.buildings[t].tiles[k].x == this.tile.x) {
                                this.dirs4 += 1
                            }
                        }
                    }
                }
            }

            this.decayingInTheWind = 1 - ((this.dirs1 + this.dirs2 + this.dirs3 + this.dirs4) / 4)
        }
        spirecheck() {
            this.dirs1 = 0
            this.dirs2 = 0
            for (let t = 0; t < this.faction.buildings.length; t++) {
                if (this.faction.buildings[t].spire == 1) {
                    const link = new LineOP(this.body, this.faction.buildings[t].body)
                    if (this.dirs1 == 0) {// right
                        if (link.hypotenuse() <= 119) {
                            this.dirs1 = 1
                        }
                    }

                    if (this.dirs2 == 0) {// right
                        if (link.hypotenuse() <= 179) {
                            this.dirs2 = 1
                        }
                    } else {
                        if (link.hypotenuse() <= 179) {
                            this.dirs1 = 1
                        }
                    }
                }
            }

            this.suffocating = 1 - ((this.dirs1 + this.dirs2) / 2)
        }
        simpleMoveCheck(tile, unit) {
            if ((tile.walkable == false && unit.submerged !== 1 && unit.mounted !== 0) || (unit.realPath[unit.index].occupied == true && unit.faction == this.faction)) {
                return false
            }
            return true
        }

        async pathToForAI(point, g = Math.sign(campaignController.mission), firstNymphPath = 0) {
            if (this.joining > 0) {
                return
            }
            if (this.dying > 0) {
                return
            }
            if (Date.now() - globalAItimeFlag > 12 && firstNymphPath == 0) { //timelimit
                if (this.faction.isAI == 1) {
                    return
                }
            }
            if (typeof point == "undefined") {
                return
            }
            if (this.isInRange(point)) {
                //////////console.log(13)
                if (point.occupant.faction.id != this.faction.id) {
                    //////////console.log(14)
                    if (point.occupant.faction.id != -1) {
                        //////////console.log(15)
                        if (this.nymph != 1) {
                            //////////console.log(16)
                            //////////console.log(this)
                            if (this.tile.builtOn != 1) {
                                //////////console.log(17)
                                //////////console.log("2")
                                //////////console.log("thi")
                                return
                            }
                        }
                    }
                }
            }
            if (g == 1) {
                this.ultrabreak = point
                this.start = this.tile
            }
            if (this.stacksnap > 10) {
                //////////console.log(18)
                //////////console.log("1")
                return
            }

            if (this.faction.isAI == 1) {
                if (this.totalPathingLimitForAI > 0) {
                    //////////console.log("wut")
                    return
                } else {
                }
            }
            if ((point.walkable == true || this.submerged == 1 || (this.mounted == 0 && point.occupied == false)) && point != this.tile) {
                this.stepout = 1
                if (this.submerged == 1 || this.mounted == 0) {
                    this.pather = liarsastar //big if?
                } else {
                    this.pather = astar
                }
                this.pather.agent = this
                this.obvious = this.realPath[this.index]
                this.pathsto = []
                for (let t = this.index; t < this.realPath.length; t++) {
                    this.pathsto.push(this.realPath[t])
                }
                this.stacksnap++

                let options = {}
                if (this.faction.isAI == 1) {
                    options.closest = true
                } else {
                    options.closest = true
                }
                if (this.faction.isAI == 1) {
                    this.awaiting = 1
                    this.joining = 1
                    await this.pather.search(sandmap, this.tile, point, options, this, globalAItimeFlag * 2)//this.realPath = 
                    this.totalPathingLimitForAI = 10
                } else {
                    this.awaiting = 1
                    this.joining = 1
                    await this.pather.search(sandmap, this.tile, point, options, this, globalAItimeFlag * 2) //this.realPath =
                }
                this.cooloff = this.movespeed * 2
                this.moved = 1
                this.heatmoved = 1
                //////////console.log(this.realPath)
                // if (this.obvious == this.realPath[0]) {
                //     this.index = 0
                // } else {
                //     this.index = 0
                //     // this.realPath = await [...this.pathsto]
                //     this.repath = 10 + Math.floor(Math.random() * 10)
                //     this.snapto = point
                // }
            }

            // else {
            //     // //////////console.log("pointless")
            //     if (this.tile == this.start) {

            //         this.tempcheck = []
            //         let index = 0
            //         let wet = 0

            //         for (let t = this.ultrabreak.t - this.stepout; t <= this.ultrabreak.t + this.stepout; t++) {
            //             for (let k = this.ultrabreak.k - this.stepout; k <= this.ultrabreak.k + this.stepout; k++) {
            //                 if (t > 0) {
            //                     if (t < worldscale) {
            //                         if (k > 0) {
            //                             if (k < worldscale) {
            //                                 if (sandmap.blocks[t][k].walkable == true) {
            //                                     if (sandmap.blocks[t][k].occupied == false) {
            //                                         if (sandmap.blocks[t][k].dirty == false) {
            //                                             if (sandmap.blocks[t][k].closed == false) {
            //                                                 this.tempcheck.push(sandmap.blocks[t][k])
            //                                                 wet = 1
            //                                                 // break
            //                                             }
            //                                         }
            //                                     }
            //                                 }
            //                             }
            //                         }
            //                     }
            //                 }
            //             }
            //         }

            //         if (wet == 0) {
            //             this.stepout++
            //             // this.stepout*=2
            //             this.pathsto = []
            //             for (let t = 0; t < this.realPath.length; t++) {
            //                 this.pathsto.push(this.realPath[t])
            //             }
            //             // this.realPath = [...this.pathsto]
            //             this.repath = 40 + Math.floor(Math.random() * 40)
            //             this.snapto = point
            //         } else {
            //             let max = 9999999999
            //             let count = 0
            //             for (let t = 0; t < this.tempcheck.length; t++) {
            //                 // map_context.fillStyle = "red"
            //                 // map_context.fillRect(this.tempcheck[t].x, this.tempcheck[t].y, this.tempcheck[t].width, this.tempcheck[t].height)
            //                 // //////////console.log(this.tempcheck[t])
            //                 this.gameline.target = this.tempcheck[t]// = (new LineOP(this.tile, ).hypotenuse()
            //                 // //////////console.log(link)
            //                 const link = this.gameline.hypotenuse()
            //                 if (link < max) {
            //                     count++
            //                     max = link
            //                     index = t
            //                     // if(count > this.stepout*2){
            //                     //     break
            //                     // }
            //                 }
            //             }
            //             this.stacksnap++
            //             if (this.absolutePathLimit <= 0 && this.faction.isAI == 1) {
            //                 // this.pathToForAI(this.tempcheck[index])
            //                 this.absolutePathLimit = 20
            //             } else {
            //                 // this.pathToForAI(this.tempcheck[index])

            //             }
            //         }
            //     }
            // }
        }
        coordinatemove(time) {
            this.totalPathingLimitForAI--
            if (this.joining == 1) {
                if (this.awaiting == 0) {
                    this.joining = 0

                } else {
                    return
                }
            }
            if (this.faction.isAI == 1) {
                if (this.totalPathingLimitForAI > 0) {
                    //////////console.log("huh")
                    return
                }
            }
            if (time > 12 && this.faction.isAI == 1) { //timelimit
                // this.hotrockrepathlimit -= this.movespeed
                // this.defensepathlimit -= this.movespeed
                // this.defendsplatter -= this.movespeed
                return
            }
            // for(let t = 0;t<this.realPath.length;t++){
            //     map_context.fillStyle = `rgba(${0},${255-(t *2)},${0},.5)`
            //     map_context.fillRect(this.realPath[t].x, this.realPath[t].y, 10, 10)
            // }

            if (this.dying > 0) {
                return
            }
            this.omegalimit--

            this.lockout--

            // if(keysPressed['j']){
            //     if(this.selected == 1){
            //         //////////console.log(this)
            //     }
            // }


            if (this.faction.isAI == 1 && campaignController.mission <= -1) {
                if (this.movespeedcount == 0) {
                    //     if(this.faction.collectiveStrain <= 0){
                    //         this.faction.collectiveStrain = 0

                    //         if(this.faction.collectiveStrain < 1){
                    //             if (this.tile != this.start) {
                    //                 this.repath--
                    //             } else {

                    //                 if (this.repathsnap < 3) {

                    //                     if (Math.abs(this.ultrabreak.x - this.tile.x) > (this.attackrange * 10) || Math.abs(this.ultrabreak.y - this.tile.y) > (this.attackrange * 10) || (this.ultrabreak.hotrock > 0 && this.ultrabreak.occupied != true)) {
                    //                         if (this.ultrawalk % (this.movespeed * 2) == 0) {
                    //                             if (this.ultrawalk < ((this.movespeed + 2) * (this.realPath.length + 1)) * 5) {

                    //                                 if (Math.random() < 10 / Math.sqrt(this.faction.units.length)) {
                    //                                     this.repathsnap += 1
                    //                                     // //////////console.log("wow")
                    //                                     // if (Math.random() < .01) {
                    //                                     // this.ultrawalk+=10
                    //                                     this.faction.collectiveStrain+=.75
                    //                                     this.ultrawalk = 99999999999999
                    //                                     this.pathToForAI(this.ultrabreak, 1)
                    //                                     // } else {
                    //                                     //     // this.ultrawalk -= 1
                    //                                 }
                    //                             }
                    //                         }
                    //                     }
                    //                     // this.ultrawalk++
                    //                 } else if (this.tile.id != this.ultrabreak.id && this.repath <= 0) {


                    //                     if (Math.abs(this.ultrabreak.x - this.tile.x) > (this.attackrange * 10) || Math.abs(this.ultrabreak.y - this.tile.y) > (this.attackrange * 10) || (this.ultrabreak.hotrock > 0 && this.ultrabreak.occupied != true)) {
                    //                         if (this.ultrawalk % (this.movespeed * 2) == 0) {
                    //                             if (this.ultrawalk < ((this.movespeed + 2) * (this.realPath.length + 1)) * 5) {

                    //                                 // if (Math.random() < 10 / Math.sqrt(this.faction.units.length)) {
                    //                                     this.ultrawalk = 99999999999999
                    //                                     this.pathToForAI(this.ultrabreak, 1)
                    //                                     this.faction.collectiveStrain+=.75
                    //                                 // } else {
                    //                                 //     // this.ultrawalk -= 1
                    //                                 // }
                    //                             }
                    //                         }
                    //                     }
                    //                     // this.ultrawalk++


                    //                 } else {
                    //                     this.repathsnap = 0
                    //                     this.repath = -1000
                    //                 }
                    //             }

                    //             if (this.repathsnap >= 3) {
                    //                 this.repathsnap = 0
                    //                 this.repath = -1000
                    //             }
                    //         }
                    //     }else{
                    //         if(this.faction.collectiveStrain < 1){
                    //         if (this.tile != this.start) {
                    //             this.repath--
                    //         } else {

                    //             if (this.repathsnap < 3) {

                    //                 if (Math.abs(this.ultrabreak.x - this.tile.x) > (this.attackrange * 10) || Math.abs(this.ultrabreak.y - this.tile.y) > (this.attackrange * 10) || (this.ultrabreak.hotrock > 0 && this.ultrabreak.occupied != true)) {
                    //                     if (this.ultrawalk % (this.movespeed * 2) == 0) {
                    //                         if (this.ultrawalk < ((this.movespeed + 2) * (this.realPath.length + 1)) * 5) {

                    //                             if (Math.random() < 10 / Math.sqrt(this.faction.units.length)) {
                    //                                 this.repathsnap += 1
                    //                                 // //////////console.log("wow")
                    //                                 // if (Math.random() < .01) {
                    //                                 // this.ultrawalk+=10
                    //                                 this.faction.collectiveStrain+=.75
                    //                                 this.ultrawalk = 99999999999999
                    //                                 this.pathToForAI(this.ultrabreak, 1)
                    //                                 // } else {
                    //                                 //     // this.ultrawalk -= 1
                    //                             }
                    //                         }
                    //                     }
                    //                 }
                    //                 // this.ultrawalk++
                    //             } else if (this.tile.id != this.ultrabreak.id && this.repath <= 0) {


                    //                 if (Math.abs(this.ultrabreak.x - this.tile.x) > (this.attackrange * 10) || Math.abs(this.ultrabreak.y - this.tile.y) > (this.attackrange * 10) || (this.ultrabreak.hotrock > 0 && this.ultrabreak.occupied != true)) {
                    //                     if (this.ultrawalk % (this.movespeed * 2) == 0) {
                    //                         if (this.ultrawalk < ((this.movespeed + 2) * (this.realPath.length + 1)) * 5) {

                    //                             if (Math.random() < 10 / Math.sqrt(this.faction.units.length)) {
                    //                                 this.ultrawalk = 99999999999999
                    //                                 this.pathToForAI(this.ultrabreak, 1)
                    //                                 this.faction.collectiveStrain+=.75
                    //                             } else {
                    //                                 // this.ultrawalk -= 1
                    //                             }
                    //                         }
                    //                     }
                    //                 }
                    //                 // this.ultrawalk++


                    //             } else {
                    //                 this.repathsnap = 0
                    //                 this.repath = -1000
                    //             }
                    //         }

                    //         if (this.repathsnap >= 3) {
                    //             this.repathsnap = 0
                    //             this.repath = -1000
                    //         }
                    //     }
                    // }
                    // option 2
                    //         if(this.faction.collectiveStrain <= 0){
                    //             this.faction.collectiveStrain = 0
                    //         }

                    //     if(this.faction.collectiveStrain < 1){
                    //     if (this.ultrawalk < ((this.movespeed + 5) * (this.realPath.length + 5)) * 20) { // || this.start.id == this.tile.id // || (this.start.id == this.tile.id && this.start.id != this.ultrabreak.id)
                    //         //////////console.log(1)
                    //         // if (this.ultrawalk % (this.movespeed * 2) == 0) {
                    //         if (this.movespeedcount <= 0) {
                    //         //////////console.log(2)
                    //             if ( (this.start.id == this.tile.id && this.start.id != this.ultrabreak.id)) { //this.index < this.realPath.length - 1 ||
                    //                 //////////console.log(3)
                    //                 if (this.ultrabreak.id != this.tile.id){
                    //                     //////////console.log(4)
                    //                     if (this.lockout <= 0) {
                    //                         //////////console.log(5)
                    //                         // if (Math.random() < 5 / this.selmag) {
                    //                         // if (Math.abs(this.ultrabreak.t - this.tile.t) + Math.abs(this.ultrabreak.k - this.tile.k) > Math.max(Math.sqrt(this.selmag), 1) || this.selmag <= 8) { //4
                    //                         if (this.index == this.realPath.length-1) {


                    //                             this.pathToForAI(this.ultrabreak, 1)
                    //                             this.lockout = 40
                    //                             this.faction.collectiveStrain+=this.realPath.length*.06
                    //                             this.ultrawalk += (((this.movespeed + 5) * (this.realPath.length + 5)) * 20)
                    //                             if (this.ultrabreak.ice == 1 || this.ultrabreak.occupied == true) {
                    //                                 this.ultrawalk += (((this.movespeed + 5) * (this.realPath.length + 5)) * 20)
                    //                             }
                    //                         // }
                    //                         // }
                    //                         }else{
                    //                             if((this.realPath[this.index+1].occupied == true)) {
                    //                                 this.pathToForAI(this.ultrabreak, 1)
                    //                                 this.lockout = 100
                    //                                 this.faction.collectiveStrain+=this.realPath.length*.06
                    //                                 this.ultrawalk += (((this.movespeed + 5) * (this.realPath.length + 5)) * 20)
                    //                                 if (this.ultrabreak.ice == 1 || this.ultrabreak.occupied == true) {
                    //                                     this.ultrawalk += (((this.movespeed + 5) * (this.realPath.length + 5)) * 20)
                    //                                 }
                    //                             }
                    //                         }
                    //                     }
                    //                     // }
                    //                 } 
                    //             } else {
                    //                 if (this.lockout <= 0) {
                    //                     //////////console.log(9)
                    //                     if (this.tile.id != this.ultrabreak.id) {
                    //                         //////////console.log(10)
                    //                             //////////console.log(11)
                    //                             if (Math.abs(this.ultrabreak.t - this.tile.t) + Math.abs(this.ultrabreak.k - this.tile.k) > this.attackrange) {
                    //                         if (this.index == this.realPath.length-1 ) {
                    //                             //////////console.log(12)
                    //                                 this.pathToForAI(this.ultrabreak, 1)
                    //                                 this.lockout = 40
                    //                                 this.faction.collectiveStrain+=this.realPath.length*.06
                    //                                 this.ultrawalk += (((this.movespeed + 5) * (this.realPath.length + 5)) * 20)
                    //                                 if (this.ultrabreak.ice == 1 || this.ultrabreak.occupied == true) {
                    //                                     this.ultrawalk += (((this.movespeed + 5) * (this.realPath.length + 5)) * 20)
                    //                                 }
                    //                             }else{
                    //                                 if((this.realPath[this.index+1].occupied == true)){
                    //                                     this.pathToForAI(this.ultrabreak, 1)
                    //                                     this.lockout = 100
                    //                                     this.faction.collectiveStrain+=this.realPath.length*.06
                    //                                     this.ultrawalk += (((this.movespeed + 5) * (this.realPath.length + 5)) * 20)
                    //                                     if (this.ultrabreak.ice == 1 || this.ultrabreak.occupied == true) {
                    //                                         this.ultrawalk += (((this.movespeed + 5) * (this.realPath.length + 5)) * 20)
                    //                                     }
                    //                                 }

                    //                             }
                    //                             }

                    //                     }
                    //                 } else {
                    //                     // this.ultrawalk -= 1
                    //                 }

                    //             }
                    //         }
                    //     } else {

                    //         //////////console.log(6)
                    //         this.repathsnap = 0
                    //         this.repath = -1000
                    //     }
                    //     // this.ultrawalk++

                    //     this.ultrawalk += (((this.movespeed + 5) * (this.realPath.length + 5)) * 5)*4
                    // }
                    // if (this.ultrawalk == 0) {
                    //     if (this.tile.builtOn == 1) {
                    //         if (this.faction.type != 4) {
                    //             this.pathToForAI(this.ultrabreak, 1)
                    //             this.ultrawalk++
                    //             this.faction.collectiveStrain += .05
                    //         }
                    //     }
                    // }


                    if (this.ultrawalk == 0) {
                        if (this.faction.collectiveStrain <= 2) {
                            // //////////console.log(this.realPath[this.realPath.length-1].id , this.ultrabreak.id, this.tile.id,(this.tile.id != this.ultrabreak.id && this.realPath[this.realPath.length-1].id != this.ultrabreak.id))
                            // //////////console.log(this.tile , this.ultrabreak , this.realPath, this.realPath.length , this.ultrabreak)
                            if (typeof this.ultrabreak != "undefined") {

                                if (this.tile.id != this.ultrabreak.id && this.realPath[this.realPath.length - 1].id != this.ultrabreak.id) {

                                    // if(this.selected == 1){
                                    //     //////////console.log((this.ultrabreak.hotrock > 0 && this.ultrabreak.occupied != true))
                                    //     //////////console.log(Math.abs(this.ultrabreak.y - this.tile.y) > (this.attackrange*10), Math.abs(this.ultrabreak.x - this.tile.x) > (this.attackrange*10) )
                                    // }
                                    if (Math.abs(this.ultrabreak.x - this.tile.x) > (this.sight * 10) || Math.abs(this.ultrabreak.y - this.tile.y) > (this.sight * 10) || (this.ultrabreak.hotrock > 0 || (this.ultrabreak.occupied != true || (this.ultrabreak.builtOn != 1 && this.ultrabreak.slime != true)))) {  //sight??? yes sight the other is down 
                                        if (this.ultrabreak.hotrock > 0) {
                                            if (this.ultrabreak.occupied != true) {
                                                this.pathToForAI(this.ultrabreak, 1)
                                                this.ultrawalk++
                                                this.faction.collectiveStrain += .05
                                            }
                                        }



                                        if (this.ultrabreak.occupied == true) {
                                            if (this.ultrabreak.occupant.faction.id != this.faction.id) {
                                                //////////console.log("whwi")
                                                if (this.faction.type == 4) {
                                                    if (this.slimelimit >= 40) {
                                                        this.pathToForAI(this.ultrabreak, 1)
                                                        this.ultrawalk++
                                                        this.faction.collectiveStrain += .05
                                                        this.slimelimit = Math.floor(Math.random() * 35)
                                                    } else {
                                                        this.slimelimit++
                                                    }
                                                } else {
                                                    this.pathToForAI(this.ultrabreak, 1)
                                                    this.ultrawalk++
                                                    this.faction.collectiveStrain += .05
                                                }
                                            } else {
                                                if (this.ultrabreak.slime == true) { //this.faction.type == 4 ||
                                                    if (this.slimelimit >= 50) {
                                                        this.pathToForAI(this.ultrabreak, 1)
                                                        this.ultrawalk++
                                                        this.faction.collectiveStrain += .05
                                                        this.slimelimit = Math.floor(Math.random() * 35)
                                                    } else {
                                                        this.slimelimit++
                                                    }
                                                } else {
                                                    if (this.faction.type == 4 && this.tile.hotrock <= 0) {
                                                        if (this.slimelimit >= 50) {
                                                            this.pathToForAI(this.ultrabreak, 1)
                                                            this.ultrawalk++
                                                            this.faction.collectiveStrain += .05
                                                            this.slimelimit = Math.floor(Math.random() * 35)
                                                        } else {
                                                            this.slimelimit++
                                                        }
                                                    } else {
                                                        this.ultrawalk++
                                                    }
                                                }
                                            }
                                        } else if (this.ultrabreak.builtOn == 1) {
                                            if (this.ultrabreak.slime == true) { //this.faction.type == 4 ||
                                                if (this.slimelimit >= 50) {
                                                    this.pathToForAI(this.ultrabreak, 1)
                                                    this.ultrawalk++
                                                    this.faction.collectiveStrain += .05
                                                    this.slimelimit = Math.floor(Math.random() * 35)
                                                } else {
                                                    this.slimelimit++
                                                }
                                            } else {
                                                if (this.faction.type == 4 && this.tile.hotrock <= 0) {
                                                    if (this.slimelimit >= 50) {
                                                        this.pathToForAI(this.ultrabreak, 1)
                                                        this.ultrawalk++
                                                        this.faction.collectiveStrain += .05
                                                        this.slimelimit = Math.floor(Math.random() * 35)
                                                    } else {
                                                        this.slimelimit++
                                                    }
                                                } else {
                                                    this.ultrawalk++
                                                }
                                            }
                                        } else {
                                            this.pathToForAI(this.ultrabreak, 1)
                                            this.ultrawalk++
                                            this.faction.collectiveStrain += .05
                                        }
                                    } else {

                                        if (Math.abs(this.ultrabreak.x - this.tile.x) > (this.attackrange * 10) || Math.abs(this.ultrabreak.y - this.tile.y) > (this.attackrange * 10) || (this.ultrabreak.hotrock > 0 || (this.ultrabreak.occupied != true || (this.ultrabreak.builtOn != 1 && this.ultrabreak.slime != true)))) {
                                            if (this.ultrabreak.occupied == true) {
                                                if (this.ultrabreak.occupant.faction.id != this.faction.id) {
                                                    //////////console.log("whwi")
                                                    if (this.faction.type == 4) {
                                                        if (this.slimelimit >= 40) {
                                                            this.pathToForAI(this.ultrabreak, 1)
                                                            this.ultrawalk++
                                                            this.faction.collectiveStrain += .05
                                                            this.slimelimit = Math.floor(Math.random() * 35)
                                                        } else {
                                                            this.slimelimit++
                                                        }
                                                    } else {
                                                        this.pathToForAI(this.ultrabreak, 1)
                                                        this.ultrawalk++
                                                        this.faction.collectiveStrain += .05
                                                    }
                                                } else {
                                                    if (this.ultrabreak.slime == true) {//this.faction.type == 4 || 
                                                        if (this.slimelimit >= 50) {
                                                            this.pathToForAI(this.ultrabreak, 1)
                                                            this.ultrawalk++
                                                            this.faction.collectiveStrain += .05
                                                            this.slimelimit = Math.floor(Math.random() * 35)
                                                        } else {
                                                            this.slimelimit++
                                                        }
                                                    } else {
                                                        if (this.faction.type == 4 && this.tile.hotrock <= 0) {
                                                            if (this.slimelimit >= 50) {
                                                                this.pathToForAI(this.ultrabreak, 1)
                                                                this.ultrawalk++
                                                                this.faction.collectiveStrain += .05
                                                                this.slimelimit = Math.floor(Math.random() * 35)
                                                            } else {
                                                                this.slimelimit++
                                                            }
                                                        } else {
                                                            this.ultrawalk++
                                                        }
                                                    }
                                                }
                                            } else if (this.ultrabreak.builtOn == 1) {


                                                this.pathToForAI(this.ultrabreak, 1)
                                                this.ultrawalk++
                                                this.faction.collectiveStrain += .05


                                                // if(this.ultrabreak.slime == true){ //this.faction.type == 4 || 
                                                //     if(this.slimelimit>=50){
                                                //         this.pathToForAI(this.ultrabreak, 1)
                                                //         this.ultrawalk++
                                                //         this.faction.collectiveStrain += .05
                                                //         this.slimelimit = Math.floor(Math.random()*35)
                                                //     }else{
                                                //         this.slimelimit++
                                                //     }
                                                // }else{
                                                //     if(this.faction.type == 4 && this.tile.hotrock <= 0){
                                                //         if(this.slimelimit>=50){
                                                //             this.pathToForAI(this.ultrabreak, 1)
                                                //             this.ultrawalk++
                                                //             this.faction.collectiveStrain += .05
                                                //             this.slimelimit = Math.floor(Math.random()*35)
                                                //         }else{
                                                //             this.slimelimit++
                                                //         }
                                                //     }else{
                                                //         this.ultrawalk++
                                                //     }
                                                // }
                                            } else {
                                                this.pathToForAI(this.ultrabreak, 1)
                                                this.ultrawalk++
                                                this.faction.collectiveStrain += .05
                                            }
                                        }
                                        // this.ultrawalk++
                                        //what does this really do? makes them stop?
                                    }
                                }
                            }

                            if (this.faction.collectiveStrain <= 0) {
                                this.faction.collectiveStrain = 0
                            }
                        }
                        this.faction.collectiveStrain += .01

                        if (this.faction.collectiveStrain <= 0) {
                            this.faction.collectiveStrain = 0
                        }
                    } else {
                        if (this.tile != this.ultrabreak && this.realPath[this.realPath.length - 1] != this.ultrabreak) {
                            // //////////console.log(this.tile.id , this.ultrabreak.id , this.realPath[this.realPath.length - 1].id , this.ultrabreak.id)
                            if (typeof this.ultrabreak != "undefined") {
                                if (this.tile.id != this.ultrabreak.id && this.realPath[this.realPath.length - 1].id != this.ultrabreak.id) {
                                    if (this.index < this.realPath.length - 1) {
                                        if (this.faction.collectiveStrain <= 1) {
                                            if (!(Math.abs(this.ultrabreak.x - this.tile.x) > (this.attackrange * 10) || Math.abs(this.ultrabreak.y - this.tile.y) > (this.attackrange * 10))) {
                                                this.ultrawalk = 0
                                            }
                                            if (!(Math.abs(this.ultrabreak.x - this.tile.x) > (this.sight * 10) || Math.abs(this.ultrabreak.y - this.tile.y) > (this.sight * 10))) { //sight???
                                                this.ultrawalk = 0
                                            }
                                            this.faction.collectiveStrain += .05

                                            if (this.faction.collectiveStrain <= 0) {
                                                this.faction.collectiveStrain = 0
                                            }
                                        }
                                    }
                                }

                                this.faction.collectiveStrain += .01
                            }
                        }
                    }


                    if (this.repathsnap >= 3) {
                        this.repathsnap = 0
                        this.repath = -1000
                    }

                }
            } else if ((this.faction.isAI == 0) || (this.faction.isAI == 1 && campaignController.mission > -1)) {
                if (this.faction.isAI == 1) {
                    if (this.movespeedcount == 0) {

                        if (this.tile != this.start) {
                            this.repath--
                        } else {

                            if (this.repathsnap < 3) {

                                if (Math.abs(this.ultrabreak.x - this.tile.x) > (this.attackrange * 10) || Math.abs(this.ultrabreak.y - this.tile.y) > (this.attackrange * 10) || (this.ultrabreak.hotrock > 0 && this.ultrabreak.occupied != true)) {
                                    if (this.ultrawalk % (this.movespeed * 2) == 0) {
                                        if (this.ultrawalk < ((this.movespeed + 2) * (this.realPath.length + 1)) * 5) {

                                            if (Math.random() < 10 / Math.sqrt(this.faction.units.length)) {
                                                this.repathsnap += 1
                                                // //////////console.log("wow")
                                                // if (Math.random() < .01) {
                                                // this.ultrawalk+=10
                                                this.pathToForAI(this.ultrabreak, 1)
                                                // } else {
                                                //     // this.ultrawalk -= 1
                                            }
                                        }
                                    }
                                }
                                this.ultrawalk++
                            } else if (this.tile.id != this.ultrabreak.id && this.repath <= 0) {


                                if (Math.abs(this.ultrabreak.x - this.tile.x) > (this.attackrange * 10) || Math.abs(this.ultrabreak.y - this.tile.y) > (this.attackrange * 10) || (this.ultrabreak.hotrock > 0 && this.ultrabreak.occupied != true)) {
                                    if (this.ultrawalk % (this.movespeed * 2) == 0) {
                                        if (this.ultrawalk < ((this.movespeed + 2) * (this.realPath.length + 1)) * 5) {

                                            if (Math.random() < 10 / Math.sqrt(this.faction.units.length)) {
                                                this.ultrawalk += 10
                                                this.pathToForAI(this.ultrabreak, 1)
                                            } else {
                                                // this.ultrawalk -= 1
                                            }
                                        }
                                    }
                                }
                                this.ultrawalk++


                            } else {
                                this.repathsnap = 0
                                this.repath = -1000
                            }
                        }

                        if (this.repathsnap >= 3) {
                            this.repathsnap = 0
                            this.repath = -1000
                        }

                    }
                } else {
                    if (this.submerged == 1) {
                        //////////console.log(this)
                    }
                    //player controlled walking

                    if (this.movespeedcount == 0) {
                        if (this.shouldMove == 1) {
                            if (this.timeoutforAsync <= 0) {
                                if (!(this.isInSmallRangeBonus(this.ultrabreak, this.stepoutBonus))) {
                                    this.stepoutBonus++
                                    this.metrics = {}
                                    this.metrics.length = this.realPath.length
                                    this.metrics.end = this.realPath[this.realPath.length - 1]

                                    let gj = 0
                                    while (this.ultrabreak.walkable == false) { // && (this.submerged != 1 && this.mounted != 0)
                                        if (gj > 100) {
                                            break
                                        }
                                        if (this.submerged == 1 || this.mounted == 0) {
                                            if (this.ultrabreak.ice == 1) {
                                                break
                                            }
                                        }
                                        this.ultrabreak = sandmap.blocks[Math.min(Math.max(this.ultrabreak.t - (Math.sign(Math.random() - .5)), 0), worldscale - 1)][Math.min(Math.max(this.ultrabreak.k - (Math.sign(Math.random() - .5)), 0), worldscale - 1)]
                                    }
                                    this.pathToForAI(this.ultrabreak, 1)
                                    this.timeoutforAsync = 1
                                } else {
                                    // this.stepoutBonus = 0
                                    this.shouldMove = 0
                                    this.ultrabreak = this.realPath[this.realPath.length - 1]
                                }
                            } else {
                                this.stepoutBonus = 0
                                this.timeoutforAsync--
                                if (this.realPath.length != this.metrics.length || this.metrics.end != this.realPath[this.realPath.length - 1]) {
                                    if (Math.abs(this.ultrabreak.t - this.realPath[this.realPath.length - 1].t) + Math.abs(this.ultrabreak.k - this.realPath[this.realPath.length - 1].k) <= this.sight) {
                                        this.shouldMove = 0
                                        this.ultrabreak = this.realPath[this.realPath.length - 1]
                                    }
                                }
                            }
                        } else {
                            if (this.realPath.length > 3) {
                                if (this.index < this.realPath.length - 1) {
                                    if (this.realPath[this.index + 1].occupied == true && (this.movespeedcount == 0)) {
                                        if (!(this.isInSmallRangeBonus(this.ultrabreak, this.stepoutBonus))) {
                                            // if(!(this.jitterFix > 0)){
                                            //     this.jitterFix = this.movespeed*3
                                            if (this.patrolling == -1) {
                                                this.shouldMove = 1
                                                this.stepoutBonus++
                                            }
                                            // }else{
                                            //     this.jitterFix--
                                            // }
                                        }
                                    }
                                }
                            }
                        }
                    } else if (this.index < this.realPath.length - 1) {
                        if (this.realPath[this.index + 1].occupied == true) {

                            if (this.shouldMove == 1) {
                                if (this.timeoutforAsync <= 0) {
                                    if (!(this.isInSmallRangeBonus(this.ultrabreak, this.stepoutBonus))) {
                                        this.stepoutBonus++
                                        this.metrics = {}
                                        this.metrics.length = this.realPath.length
                                        this.metrics.end = this.realPath[this.realPath.length - 1]

                                        let gj = 0
                                        while (this.ultrabreak.walkable == false && (this.submerged != 1 && this.mounted != 0)) {
                                            if (gj > 100) {
                                                break
                                            }
                                            this.ultrabreak = sandmap.blocks[Math.min(Math.max(this.ultrabreak.t - (Math.sign(Math.random() - .5)), 0), worldscale - 1)][Math.min(Math.max(this.ultrabreak.k - (Math.sign(Math.random() - .5)), 0), worldscale - 1)]
                                        }
                                        this.pathToForAI(this.ultrabreak, 1)
                                        this.timeoutforAsync = 1
                                    } else {
                                        // this.stepoutBonus = 0
                                        this.shouldMove = 0
                                        this.ultrabreak = this.realPath[this.realPath.length - 1]
                                    }
                                } else {
                                    this.stepoutBonus = 0
                                    this.timeoutforAsync--
                                    if (this.realPath.length != this.metrics.length || this.metrics.end != this.realPath[this.realPath.length - 1]) {
                                        if (Math.abs(this.ultrabreak.t - this.realPath[this.realPath.length - 1].t) + Math.abs(this.ultrabreak.k - this.realPath[this.realPath.length - 1].k) <= this.sight) {
                                            this.shouldMove = 0
                                            this.ultrabreak = this.realPath[this.realPath.length - 1]
                                        }
                                    }
                                }
                            } else {
                                if (this.realPath.length > 3) {
                                    if (this.index < this.realPath.length - 1) {
                                        if (this.realPath[this.index + 1].occupied == true && (this.movespeedcount == 0)) {
                                            if (!(this.isInSmallRangeBonus(this.ultrabreak, this.stepoutBonus))) {
                                                // if(!(this.jitterFix > 0)){
                                                //     this.jitterFix = this.movespeed*3
                                                if (this.patrolling == -1) {
                                                    this.shouldMove = 1
                                                    this.stepoutBonus++
                                                }
                                                // }else{
                                                //     this.jitterFix--
                                                // }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // if (this.ultrawalk < ((this.movespeed + 5) * (this.realPath.length + 5)) * 20 || (this.start.id == this.tile.id && this.start.id != this.ultrabreak.id)) { // || this.start.id == this.tile.id
                    //     //////////console.log(1)
                    //     // if (this.ultrawalk % (this.movespeed * 2) == 0) {
                    //     if (this.movespeedcount <= 0) {
                    //         //////////console.log(2)
                    //         if (this.index < this.realPath.length - 1 && (this.start.id == this.tile.id && this.start.id != this.ultrabreak.id)) {
                    //             //////////console.log(3)
                    //             if (this.ultrabreak.id != this.tile.id) {
                    //                 //////////console.log(4)
                    //                 // if (this.lockout <= 0) {
                    //                     if (this.realPath[this.index + 1].occupied == true || (this.start.id == this.tile.id&& this.start.id != this.ultrabreak.id) ) {
                    //                         //////////console.log(5)
                    //                         // if (Math.random() < 5 / this.selmag) {
                    //                         // if (Math.abs(this.ultrabreak.t - this.tile.t) + Math.abs(this.ultrabreak.k - this.tile.k) > Math.max(Math.sqrt(this.selmag), 1) || this.selmag <= 8) { //4
                    //                         this.pathToForAI(this.ultrabreak, 1)
                    //                         this.ultrawalk += (((this.movespeed + 5) * (this.realPath.length + 5)) * .05)
                    //                         if (this.ultrabreak.ice == 1 || this.ultrabreak.occupied == true) {
                    //                             this.ultrawalk += (((this.movespeed + 5) * (this.realPath.length + 5)) * .05)
                    //                         }
                    //                         // }
                    //                         // }
                    //                     }
                    //                 // }
                    //                 // }
                    //             } else {
                    //                 //////////console.log(7)
                    //                 if (this.lockout <= 0) {
                    //                     //////////console.log(8)
                    //                     // if (Math.random() < 5 / this.selmag) {
                    //                     //     if (Math.abs(this.ultrabreak.t - this.tile.t) + Math.abs(this.ultrabreak.k - this.tile.k) > Math.sqrt(this.selmag) || this.selmag <= 4) {
                    //                     //         this.pathToForAI(this.ultrabreak, 1)
                    //                     //     }
                    //                     // }
                    //                     // } else {
                    //                     //     // this.ultrawalk -= 1
                    //                     // }
                    //                 }
                    //             }
                    //         } else {
                    //             // if (this.lockout <= 0) {
                    //                 //////////console.log(9)
                    //                 if (this.tile.id != this.ultrabreak.id || this.realPath.length == 1 || this.tile.id == this.start.id) {
                    //                     //////////console.log(10)
                    //                     // if (Math.random() < 5 / this.selmag) {
                    //                     //////////console.log(11)
                    //                     // if (Math.abs(this.ultrabreak.t - this.tile.t) + Math.abs(this.ultrabreak.k - this.tile.k) > Math.max(Math.sqrt(this.selmag), 1) || this.selmag <= 4) {
                    //                         //////////console.log(12)

                    //                         if (this.index < this.realPath.length - 1) {

                    //                             if (this.realPath[this.index + 1].occupied == true || (this.start.id == this.tile.id && this.start.id != this.ultrabreak.id)) {
                    //                                 this.pathToForAI(this.ultrabreak, 1)
                    //                                 this.ultrawalk += (((this.movespeed + 5) * (this.realPath.length + 5)) * .05)
                    //                                 if (this.ultrabreak.ice == 1 || this.ultrabreak.occupied == true) {
                    //                                     this.ultrawalk += (((this.movespeed + 5) * (this.realPath.length + 5)) * .05)
                    //                                 }
                    //                             }
                    //                         } else {

                    //                             if ((this.start.id == this.tile.id && this.start.id != this.ultrabreak.id)) {
                    //                                 this.pathToForAI(this.ultrabreak, 1)
                    //                                 this.ultrawalk += (((this.movespeed + 5) * (this.realPath.length + 5)) * .05)
                    //                                 if (this.ultrabreak.ice == 1 || this.ultrabreak.occupied == true) {
                    //                                     this.ultrawalk += (((this.movespeed + 5) * (this.realPath.length + 5)) * .05)
                    //                                 }
                    //                             }
                    //                         }

                    //                     // }
                    //                     // }

                    //                 }
                    //             // } else {
                    //             //     // this.ultrawalk -= 1
                    //             // }

                    //         }
                    //     }
                    // } else {

                    //     //////////console.log(6)
                    //     this.repathsnap = 0
                    //     this.repath = -1000
                    // }
                    // this.ultrawalk++
                }

            }


            // for (let t = this.index; t < this.realPath.length; t++) {
            //     map_context.fillStyle = this.pathcolor
            //     map_context.fillRect(this.realPath[t].x, this.realPath[t].y, 10, 10)
            // }


        }
        incrementMove() {

            this.tile.drawish = 0
            this.tile.walkable = true
            this.tile.occupied = false
            this.tile.occupant = {}
            this.tile.occupant.moving = false
            this.tile.occupant.faction = {}
            this.tile.occupant.faction.id = -1
            if(onlineNow == 1 && sandmap.players.indexOf(this.faction) != sandmap.turn){
            this.tile.occupied = true
            this.tile.occupant = this
            if (this.index == this.realPath.length - 1) {
                this.tile.occupant.moving = false
            } else {
                this.tile.occupant.moving = true
            }

            if (this.submerged != 1) {
                this.tile.walkable = false
            }
            this.tile.drawish = 1
                return
            }
            if (this.awaiting > 0) {
                return
            }
            if (this.dying > 0) {
                return
            }
            if (this.isTowardFlag == 1) {
                //////////console.log(this)
                this.isTowardFlag = 0
                this.vec = new Vector(this.body, this.body.x - (this.tile.x + 5), this.body.y - (this.tile.y + 5))
                // this.spot = new Point(this.realPath[this.realPath.length - 1].x + 5, this.realPath[this.realPath.length - 1].y + 5)
                if (this.index < this.realPath.length - 1) {
                    if (!this.vec.isToward(this.realPath[this.index + 1])) {
                        this.movespeedcount = 0
                    }
                }
            }
            if (this.tile.id != this.realPath[this.index].id) {
                this.heatmoved = 1
            }
            if (this.index < this.realPath.length - 1 && this.awaiting == 0) {
                if (this.faction.isAI == 1) {
                    if (this.pathToRange == 1) {
                        if (this.realPath[this.index + 1].occupied == true) {
                            this.ultrabreak = this.attacktargetmover.tile
                            this.ultrawalk = 0
                            this.start = this.tile
                        }
                    }
                }

                // if (this.realPath[this.index + 1].occupied == false) {
                if (this.realPath[this.index + 1].occupied != true) {
                    this.movespeedcount++
                    if (this.fungi == 1) {
                        if (this.tile.slime == 1) {
                            this.movespeedcount++
                            if (this.movespeedcount > this.movespeed) {
                                this.movespeedcount--
                            }
                        }
                    }

                    if (this.movespeedcount % this.movespeed == 0) {

                        // if(this.realPath[this.index+1].occupied == false){
                        //     this.movespeedcount = 0
                        //     this.moved = 1
                        //     this.index += 1
                        // }else{
                        this.movespeedcount = 0
                        this.moved = 1
                        this.index += 1
                        this.heatmoved = 1
                        //does this cause stutter
                        if ((this.realPath[this.index].walkable == false && this.submerged !== 1 && this.mounted !== 0)) {
                            this.movespeedcount = 0//this.movespeed-1
                            this.moved = 0
                            // this.index -= 1
                            if (this.index == this.realPath.length - 1) {
                                this.moving = false
                            }
                        } else if ((this.realPath[this.index].occupied == true && (this.submerged == 1 || this.mounted == 0))) {
                            this.movespeedcount = 0//this.movespeed-1
                            this.moved = 0
                            // this.index -= 1
                            if (this.index == this.realPath.length - 1) {
                                this.moving = false
                            }
                        }
                        // }
                    } else {
                    }
                }

                // }
            } else {
                // this.movespeedcount = 0
            }

            this.tile = this.realPath[this.index]



            this.tile.occupied = true
            this.tile.occupant = this
            if (this.index == this.realPath.length - 1) {
                this.tile.occupant.moving = false
            } else {
                this.tile.occupant.moving = true
            }

            if (this.submerged != 1) {
                this.tile.walkable = false
            }
            this.tile.drawish = 1
        }
        move() {
            if (this.awaiting > 0) {
                return
            }
            if (this.dying > 0) {
                return
            }
            this.megasplat--
            this.swing++


            // const scumrat = (this.shots.length * Math.max((this.damage - this.attacktarget.defense), 0))


            // if (this.swing % this.swingout == 0) {
            //     if (this.attacktarget.health <= 0 || !this.isInRange(this.attacktarget.tile) || scumrat > this.attacktarget.health) { //21???
            //         if (this.moved == 1 || ((this.seetime % this.firerate == 0) || (this.seetime % this.firerate == 0 && (this.health < this.maxhealth || sandmap.players[sandmap.turn] == this.faction)))  || scumrat > this.attacktarget.health) {
            // this.attack()
            //         }else{
            //     if(campaignController.mission > -1){
            //         if(sandmap.players[sandmap.turn] == this.faction){
            //         this.attack()
            //     }
            // }else{
            this.attack()
            // }
            //         }
            //     } else {
            //         if(this.attacktarget.health > 0){
            //             this.attacktarget.faction.context.clearRect((this.tile.x * .1), (this.tile.y * .1), 1, 1)
            //             this.attacktarget.faction.contextx.clearRect((this.tile.x * .1), (this.tile.y * .1), 1, 1)
            //         }
            //         // this.shoot()
            //     }
            // }
            if (!(this.attacktarget.health <= 0 || !this.isInRange(this.attacktarget.tile))) {
                this.shoot()
            }

            if (this.index != this.realPath.length - 1) {
                if (this.faction.surf == 1) {
                    if (this.faction.isAI == 1) {
                        if (this.faction.hotrock > 100) {
                            this.faction.buildWall(this.realPath[this.index + 1])
                        }
                    }
                }
            }


            //////////console.log(this.isInRange(this.attacktargetmover.tile))
            if (this.index == this.realPath.length - 1 || ((this.pathToRange == 1 && this.isInRange(this.attacktargetmover.tile)) && this.faction.isAI == 0) || ((this.pathToRange == 1 && this.isInRange(this.attacktargetmover.tile)) && this.faction.isAI == 1 && Math.random() < 1 / (this.movespeed * 4))) {
                // //////////console.log((this.pathToRange == 1 && this.isInRange(this.attacktarget.tile) && this.index != 0))
                if (this.pathToRange > 0 && this.index != this.realPath.length - 1) {
                    this.pathToRange = 0
                    if (this.faction.isAI == 1) {
                        this.ultrabreak = this.tile
                        this.ultrawalk = 999999999999999
                    }
                }
                this.realPath = [this.tile]
                this.index = 0
                this.movespeedcount = 0
                // this.moved = 1
            } else {

                // this.start = this.tile
                if (this.faction.surf == 1) {
                    if (this.faction.isAI == 1) {
                        if (this.faction.hotrock > 100) {
                            this.faction.buildWall(this.realPath[this.index + 1])
                        }
                    }
                }
            }
            if (this.faction.type == 0) {
                if (this.decayRate > 0) {
                    if (this.heatmoved == 1) {
                        this.heatwallcheck()
                        this.heatmoved = 0
                    }
                } else {
                    this.decayingInTheWind = 0
                }
            } else if (this.faction.type == 2) {
                this.aircheck++
                if (this.aircheck % this.faction.buildings.length == 0) {
                    this.spirecheck()
                } else if (typeof this.suffocating == "undefined") {
                    this.spirecheck()
                }
            } else {
                this.decayingInTheWind = 0
            }
            if (this.faction.type == 0) {
                this.health -= ((this.decayRate * this.decayingInTheWind * sandmap.windspeed)) * .1 //.1 is new
            }
            if (campaignController.mission == -1) {
                if (this.faction.type == 2) {
                    if (this.suffocating > 0) {
                        this.health -= ((this.decayRate * this.suffocating)) * .1 //.1 is new
                    } else {
                        this.health += (this.decayRate * .333)
                        if (this.health > this.maxhealth) {
                            this.health = this.maxhealth
                        }
                    }
                }
            }
            if (this.decayingInTheWind == 0 && this.faction.type == 0) {
                this.health += (this.decayRate * .5)
                if (this.health > this.maxhealth) {
                    this.health = this.maxhealth
                }
            }
            if (this.health <= 0) {
                this.marked = 1
            }
            if (this.tile.hotrock == 1) {

                if (this.fungi == 1) {
                    this.faction.hotrock += this.movespeed * .004
                    this.tile.sourcerock -= this.movespeed * .004
                    this.faction.income += this.movespeed * .004
                } else {
                    if (this.drone == 1 || this.hamartanscout == 1) { //|| this.hamartaninvader == 1 //

                        this.faction.hotrock += this.movespeed * .005
                        this.tile.sourcerock -= this.movespeed * .005
                        this.faction.income += this.movespeed * .005
                    } else {

                        this.faction.hotrock += this.movespeed * .01
                        this.tile.sourcerock -= this.movespeed * .01
                        if (this.nymph == 1 || this.harvester == 1 || this.hamartanworker == 1 || this.pollinator == 1) {
                            this.faction.hotrock += this.movespeed * .025
                            this.tile.sourcerock -= this.movespeed * .025
                            this.faction.income += this.movespeed * .025
                        }
                        if (this.infantry == 1) {
                            // this.faction.hotrock += this.movespeed * .0125
                            // this.tile.sourcerock -= this.movespeed * .0125
                            this.faction.hotrock += this.movespeed * .005//625
                            this.tile.sourcerock -= this.movespeed * .005 //625
                            this.faction.income += this.movespeed * .005
                        }
                        if (this.hamartanworker == 1) {
                            this.faction.hotrock += this.movespeed * .00625//625
                            this.tile.sourcerock -= this.movespeed * .00625 //625
                            this.faction.income += this.movespeed * .00625
                        }
                        if (this.harvester == 1) {
                            this.faction.hotrock -= this.movespeed * .015//625
                            this.tile.sourcerock += this.movespeed * .015 //625
                            this.faction.income -= this.movespeed * .015
                        }
                        if (this.nymph == 1 || this.harvester == 1 || this.pollinator == 1) { //  || this.pollinator == 1) { //harvester?
                            this.faction.hotrock += this.movespeed * .025
                            this.tile.sourcerock -= this.movespeed * .025
                            this.faction.income += this.movespeed * .025
                        }
                    }
                }
            }
            if (this.tile.hotrock == 2) {

                if (this.gogo == 1) {
                    this.faction.hotrock += this.movespeed * .0127
                    this.tile.sourcerock -= this.movespeed * .0127
                    this.faction.income += this.movespeed * .0127
                }

                if (this.targetroid == 1) {
                    this.faction.hotrock += .5 + this.harvestBonusTargetroid
                    this.tile.sourcerock -= .5 + this.harvestBonusTargetroid
                    this.faction.income += .5 + this.harvestBonusTargetroid
                }
                if (this.schlorkupine == 1) {
                    this.faction.hotrock += .5 + this.harvestBonusTargetroid
                    this.tile.sourcerock -= .5 + this.harvestBonusTargetroid
                    this.faction.income += .5 + this.harvestBonusTargetroid
                }

                if (this.sana == 1) {
                    this.faction.hotrock += this.movespeed * .27
                    this.tile.sourcerock -= this.movespeed * .27
                    this.faction.income += this.movespeed * .27
                }

                if (this.fungi == 1) {
                    this.faction.hotrock += this.movespeed * .008
                    this.tile.sourcerock -= this.movespeed * .008
                    this.faction.income += this.movespeed * .008
                } else {
                    if (this.drone == 1 || this.hamartanscout == 1) { // || this.hamartaninvader == 1 //
                        this.faction.hotrock += this.movespeed * .01
                        this.tile.sourcerock -= this.movespeed * .01
                        this.faction.income += this.movespeed * .01
                    } else {
                        this.faction.hotrock += this.movespeed * .02
                        this.tile.sourcerock -= this.movespeed * .02
                        this.faction.income += this.movespeed * .02
                        if (this.nymph == 1 || this.harvester == 1 || this.hamartanworker == 1 || this.pollinator == 1 || this.beeworker == 1) {
                            if (this.nymph == 1 || this.pollinator == 1) {
                                    //.05 before speed nerf
                                this.faction.hotrock += this.movespeed * .027
                                this.tile.sourcerock -= this.movespeed * .027
                                this.faction.income += this.movespeed * .027 
                            } else {

                                this.faction.hotrock += this.movespeed * .05
                                this.tile.sourcerock -= this.movespeed * .05
                                this.faction.income += this.movespeed * .05
                            }
                            if (this.sana == 1) {
                                this.faction.hotrock += this.movespeed * .27
                                this.tile.sourcerock -= this.movespeed * .27
                                this.faction.income += this.movespeed * .27
                            }
                        }
                        // if (this.pollinator == 1) {
                             //speed nerf
                        //     this.faction.hotrock += this.movespeed * .025
                        //     this.tile.sourcerock -= this.movespeed * .025
                        //     this.faction.income += this.movespeed * .025
                        // }
                        if (this.infantry == 1) {
                            this.faction.hotrock += this.movespeed * .01//625
                            this.tile.sourcerock -= this.movespeed * .01 //625
                            this.faction.income += this.movespeed * .01
                        }
                        if (this.hamartanworker == 1) {
                            this.faction.hotrock += this.movespeed * .0125 //125
                            this.tile.sourcerock -= this.movespeed * .0125 //125
                            this.faction.income += this.movespeed * .0125
                        }
                        if (this.harvester == 1) {
                            this.faction.hotrock += this.movespeed * .0321 //125  //.035
                            this.tile.sourcerock -= this.movespeed * .0321 //125
                            this.faction.income += this.movespeed * .0321
                        }

                        if (this.megagnat == 1) {
                            this.faction.hotrock += this.movespeed * .012
                            this.tile.sourcerock -= this.movespeed * .012
                            this.faction.income += this.movespeed * .012
                        }
                        if (this.buzzlet == 1) {
                            this.faction.hotrock += this.movespeed * .035
                            this.tile.sourcerock -= this.movespeed * .035
                            this.faction.income += this.movespeed * .035
                        }
                        if (this.nymph == 1 || this.pollinator == 1) { // || this.pollinator == 1) { //harvester?//|| this.harvester == 1 
                            this.faction.hotrock += this.movespeed * .026
                            this.tile.sourcerock -= this.movespeed * .026
                            this.faction.income += this.movespeed * .026

                            //nerfed speed was .05
                        }
                    }
                }
            }

            // this.tile.draw()
        }
        checkRangeConsistent() {
            this.hotrockrepathlimit--
            if (this.index < this.realPath.length - 1) {
                if (this.realPath[this.index + 1].occupied == true) {
                    this.hotrockrepathlimit -= this.movespeed
                    this.defensepathlimit -= this.movespeed
                } else if (this.realPath[this.realPath.length - 1].occupied == true) {
                    if (this.realPath[this.realPath.length - 1].occupant.faction.id == this.faction.id) {
                        this.hotrockrepathlimit -= this.movespeed
                    }
                }
            }
            this.defensepathlimit--
            if (typeof this.attacktarget != "undefined") {
                if (typeof this.attacktarget.tile != "undefined") {

                    if (this.isInRange(this.attacktarget.tile)) {

                    } else {
                        // //////////console.log("save")
                        this.attacktarget = {}
                        this.attacktarget.tile = {}
                        //new
                        this.attacktarget.tile.x = -100000
                        this.attacktarget.tile.y = -100000
                        this.attacktarget.tile.t = 0
                        this.attacktarget.tile.k = 0
                    }
                }
            }
        }
        draw() {
            //////////console.log("go")
            if(this.drawn != 1){
                this.drawn = 1
            }

            // if(this.faction.idtable.includes(this.id)  || sandmap.turn == sandmap.players.indexOf(this.faction)){
            //     this.faction.idtable.splice(this.faction.idtable.indexOf(this.id),1)
            // }else{
            //     return
            // }
            // this.body.draw()
            // if (this.awaiting > 0) {
            //     return
            // }


                //radar thing
                //goes with fg/g
                // this.players[this.turn].contextx.fillStyle = "#00000004"
                // this.players[this.turn].contextx.fillRect(0,0,this.players[this.turn].canvasx.width, this.players[this.turn].canvasx.height)
    
                // sandmap.players[0].contextx.fillStyle = this.faction.color+"10"
                // sandmap.players[0].contextx.fillRect(this.tile.t, this.tile.k, 1, 1)
    

                            // map_context.fillStyle = "blue"
                            // map_context.fillRect(this.faction.units[t].realPath[p].x, this.faction.units[t].realPath[p].y, 10, 10)

                            
            if (this.regenerating == 1) {
                this.health += this.regen
                if (this.health > this.maxhealth) {
                    this.health = this.maxhealth
                }
            }
            this.absolutePathLimit--


            if (this.pathNow == 1 || (this.pathQue.length > 0 && !this.isInSmallRange(this.ultrabreak))) {
                if (this.pathQue.length == 0) {
                    this.pathNow = 0
                    this.ultrabreak = this.emergencyTarget
                    this.lockout = -1
                    this.omegalimit = -1
                    this.ultrawalk = 0
                    this.shouldMove = 1
                    this.start = this.tile
                    // this.pathToForAI(this.ultrabreak, 1)
                } else {

                    if ((this.isInSmallRange(this.realPath[this.realPath.length - 1]) || (this.realPath.indexOf(this.ultrabreak) <= this.index)) || this.pathNow == 1) {
                        this.shouldMove = 1
                        this.ultrabreak = this.pathQue[0]
                        if (this.realPath[this.realPath.length - 1] == this.ultrabreak) {

                            this.pathNow = 0
                        } else {
                            this.pathNow = 0
                            this.lockout = -1
                            this.omegalimit = -1
                            this.ultrawalk = 0
                            // if(!this.realPath.includes(this.ultrabreak)) {
                            // //////////console.log("f")
                            // }
                            this.start = this.tile
                            // this.pathToForAI(this.ultrabreak, 1)

                            //////////console.log(this.isInSmallRange(this.pathQue[0]), this.pathQue[0].t, this.pathQue[0].k, this.tile.t,  this.tile.k)
                            if (this.isInSmallRange(this.pathQue[0])) {
                                //////////console.log("1")
                                if (this.patrolling == -1) {
                                    this.pathQue.splice(0, 1)
                                    this.shouldMove = 1
                                    //////////console.log("f")

                                } else {
                                    const temp = sandmap.blocks[this.pathQue[0].t][this.pathQue[0].k]
                                    this.pathQue.splice(0, 1)
                                    this.pathQue.push(temp)
                                    this.shouldMove = 1
                                    //////////console.log("g")

                                }
                            }
                        }
                    } else {
                        if (this.realPath[this.index] == this.tile || (this.realPath.indexOf(this.ultrabreak) <= this.index)) {
                            this.shouldMove = 1
                        }

                    }
                }
            } else if (typeof this.ultrabreak != "undefined") {
                if (this.isInSmallRange(this.ultrabreak) && this.pathQue.length > 0) {
                    // this.pathNow = 1
                    this.ultrabreak = this.pathQue[0]
                    if (this.realPath[this.realPath.length - 1] == this.ultrabreak) {

                        // this.shouldMove = 1
                        // this.lockout = -1
                        // this.omegalimit = -1
                        // this.ultrawalk = 0
                        // this.start = this.tile
                        if (this.isInSmallRange(this.pathQue[0])) {
                            //////////console.log("2")
                            if (this.patrolling == -1) {
                                this.pathQue.splice(0, 1)
                                this.shouldMove = 1
                            } else {
                                const temp = sandmap.blocks[this.pathQue[0].t][this.pathQue[0].k]
                                this.pathQue.splice(0, 1)
                                this.pathQue.push(temp)
                                this.shouldMove = 1
                            }
                        }
                    } else {

                        // if (this.isInSmallRange(this.ultrabreak)) {
                        this.shouldMove = 1
                        // }
                        this.lockout = -1
                        this.omegalimit = -1
                        this.ultrawalk = 0
                        this.start = this.tile
                        if (this.isInSmallRange(this.pathQue[0])) {
                            //////////console.log("3")
                            if (this.patrolling == -1) {
                                this.pathQue.splice(0, 1)
                            } else {
                                const temp = sandmap.blocks[this.pathQue[0].t][this.pathQue[0].k]
                                this.pathQue.splice(0, 1)
                                this.pathQue.push(temp)
                            }
                        }
                    }
                }
            }
            this.stacksnap = 0
            if (this.tile.builtOn == 1 || this.tile.ice == 1) {
                if (this.mounted == 0) {
                    if (this.super != 1) {
                        this.sight = 4 + this.movespeed
                        this.attackrange = this.sight
                    }
                }
            } else {
                if (this.mounted == 0) {
                    if (this.super != 1) {
                        this.sight = this.movespeed
                        this.attackrange = this.sight
                    }
                }
            }


            if (this.submerged == 1) {
                if (this.imago == 2) {
                    this.movespeed = 10
                    this.sight = 3
                    this.attackrange = 0
                }
            } else {
                if (this.imago == 2) {
                    this.movespeed = 6
                    this.sight = 7
                    this.attackrange = 7
                }
            }


            if (this.imago == 1 || this.imago == 2 || this.nymph > 0) {
                this.timer--
                if (this.timer == 0) {

                    if (this.spawn == 1) {
                        if (this.faction.units.length < unitcap) {
                            if (this.tile.ice == 1) {
                                this.timer = 1
                            } else {
                                this.que = 0
                                this.spawn = 0
                                this.spawnNymph()
                            }
                        } else {
                            // this
                        }
                    }
                    if (this.morphing == 1) {
                        this.morphing = 0
                        this.que = 0
                        this.finishMorph1()
                    }
                    if (this.morphingagain == 1) {
                        this.morphingagain = 0
                        this.que = 0
                        this.finishMorph2()
                    }
                    if (this.morphinggamergate == 1) {
                        this.morphinggamergate = 0
                        this.que = 0
                        this.finishMorphgamergate()
                    }
                    if (this.loaded.length > 0 && this.faction.isAI != 1) {
                        this[this.loaded[0]] = 1
                        this.timer = this.times[0]
                        this.maxtimer = this.times[0]
                        this.que = 1
                        // this.spawn = 1
                        this.loaded.splice(0, 1)
                        this.times.splice(0, 1)
                    }
                }
            }

            if (this.pollinator == 1) {
                this.timer--
                if (this.timer == 0) {
                    if (this.puffing == 1) {
                        if(this.dying > 0){
                        }else{
                            this.puffing = 0
                            this.que = 0
                            this.isPufffellow()
                            this.pollinator = 0
                        }
                    }
                }
            }


            if (this.realPath.length - 1 > this.index) {
                if (((this.realPath[this.index + 1].walkable == true || (this.submerged == 1 || this.mounted == 0)) && this.realPath[this.index + 1].occupied == false)) {// && (this.realPath[this.index + 1].claimed != true || this.realPath[this.index + 1].claimer == this)) { //?
                    const rat = (this.movespeedcount + 1) / this.movespeed
                    const invrat = 1 - rat
                    this.body.x = ((this.realPath[this.index].x + (this.tile.width * .5)) * invrat) + ((this.realPath[this.index + 1].x + (this.tile.width * .5)) * rat)
                    this.body.y = ((this.realPath[this.index].y + (this.tile.height * .5)) * invrat) + ((this.realPath[this.index + 1].y + (this.tile.height * .5)) * rat)
                    this.realPath[this.index + 1].claimed = true
                    this.realPath[this.index + 1].claimer = this
                } else {
                    this.body.x = this.tile.x + (this.tile.width * .5)
                    this.body.y = this.tile.y + (this.tile.height * .5)
                    if (this.realPath[this.index + 1].claimed != true) {
                        this.realPath[this.index + 1].claimed = true
                        this.realPath[this.index + 1].claimer = this
                    }
                }

            } else {

                this.body.x = this.tile.x + (this.tile.width * .5)
                this.body.y = this.tile.y + (this.tile.height * .5)
                // this.body = new UnitCircle(this.tile.x + (this.tile.width * .5), this.tile.y + (this.tile.height * .5), 5, this.faction.color)
            }

            if(this.bee == 1){
                if(onlineNow == 1){ 
                    let warm = 0
                    if(this.factionNum == sandmap.turn){
                        for(let t = 0;t<this.faction.units.length;t++){
                            if(this.faction.units[t] != this){
                                this.faction.units[t].gameline.object = this.faction.units[t].body
                                this.faction.units[t].gameline.target = this.body
                                if(this.faction.units[t].gameline.hypotenuse() < this.body.radius + this.faction.units[t].body.radius){
                                    this.warmth+=.001
                                    warm = 1
                                    // break
                                }
                            }
                        }
                    }
                    if(warm != 1){
                        this.warmth -= .005
                    }
                    this.warmth = Math.max(Math.min(1,this.warmth),0)
   
                if (this.beeworker == 1) {
                    this.movespeed = 5 - Math.min(Math.floor(this.warmth*3),2)
                }
                if (this.beesoldier == 1) {
                    this.movespeed = 5 - Math.min(Math.floor(this.warmth*3),2)
                }
                if (this.beescout == 1) {
                    this.movespeed = 3 - Math.min(Math.floor(this.warmth*3),1)
                }
                if (this.beemega == 1) {
                    this.movespeed = 7 - Math.min(Math.floor(this.warmth*4),2)
                }
                if(this.movespeed <= this.movespeedcount){
                    this.movespeedcount--
                }
                }else{
                    let warm = 0
                        for(let t = 0;t<this.faction.units.length;t++){
                            if(this.faction.units[t] != this){
                                this.faction.units[t].gameline.object = this.faction.units[t].body
                                this.faction.units[t].gameline.target = this.body
                                if(this.faction.units[t].gameline.hypotenuse() < this.body.radius + this.faction.units[t].body.radius){
                                    this.warmth+=.001
                                    warm = 1
                                    // break
                                }
                            }
                        }
                    if(warm != 1){
                        this.warmth -= .005
                    }
                    this.warmth = Math.max(Math.min(1,this.warmth),0)

                if (this.beeworker == 1) {
                    this.movespeed = 5 - Math.min(Math.floor(this.warmth*3),2)
                }
                if (this.beesoldier == 1) {
                    this.movespeed = 5 - Math.min(Math.floor(this.warmth*3),2)
                }
                if (this.beescout == 1) {
                    this.movespeed = 3 - Math.min(Math.floor(this.warmth*3),1)
                }
                if (this.beemega == 1) {
                    this.movespeed = 7 - Math.min(Math.floor(this.warmth*4),2)
                }
                if(this.movespeed <= this.movespeedcount){
                    this.movespeedcount--
                }
                }
                if (this.beeworker == 1) {
                    // if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                        if (this.dying <= 0) {
                            if (this.moving == true) {
                                this.walkcounter++
                            map_context.drawImage(beeworkerimgwalk, (this.walkcounter * 10) % 20, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                            map_context.drawImage(beeworkerimg, 0, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            }
                        }else{
                            map_context.drawImage(beeworkerdeathimg, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)

                        }
                    // }
                }
                if (this.beesoldier == 1) {
                    // if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                        if (this.dying <= 0) {
                            if (this.moving == true) {
                                this.walkcounter++
                            map_context.drawImage(beesoldierimgwalk, (this.walkcounter * 10) % 80, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                            map_context.drawImage(beesoldierimg, 0, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            }
                        }else{
                            map_context.drawImage(beesoldierdeathimg, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)

                        }
                    // }
                }
                if (this.beescout == 1) {
                    // if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                        if (this.dying <= 0) {
                            if (this.moving == true) {
                                this.walkcounter++
                            map_context.drawImage(beescoutimgwalk, (this.walkcounter * 10) % 20, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                            map_context.drawImage(beescoutimg, 0, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            }
                        }else{
                            map_context.drawImage(beescoutdeathimg, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    // }
                }
                if (this.beemega == 1) {
                    // if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                        if (this.dying <= 0) {
                            if (this.moving == true) {
                                this.walkcounter++
                            map_context.drawImage(beemegaimgwalk, (this.walkcounter * 10) % 80, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                            map_context.drawImage(beemegaimg, 0, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            }
                        }else{
                            map_context.drawImage(beemegadeathimg, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    // }
                }
            }else if (this.ave == 1) {
                if (this.flugoon == 1) {

                    if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                        if (this.dying <= 0) {
                            
                            if (this.moving == true) {
                                this.walkcounter++
                                map_context.drawImage(flugoonwalksheet, (this.walkcounter * 10) % 80, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                                map_context.drawImage(flugoon, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                            }
                        } else {

                            map_context.drawImage(flugoondeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    } else {

                        if (this.dying <= 0) {

                            if (this.moving == true) {
                                this.walkcounter++
                                map_context.drawImage(flugoonwalksheetinv, (this.walkcounter * 10) % 80, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                                map_context.drawImage(flugooninv, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                            }

                        } else {

                            map_context.drawImage(flugoondeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    }
                } else if (this.buzzlet == 1) {
                    if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                        if (this.dying <= 0) {


                            if (this.moving == true) {
                                this.walkcounter++
                                map_context.drawImage(buzzletwalksheet, (this.walkcounter * 10) % 40, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                                map_context.drawImage(buzzlet, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                            }


                        } else {

                            map_context.drawImage(buzzletdeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    } else {
                        if (this.dying <= 0) {

                            if (this.moving == true) {
                                this.walkcounter++
                                map_context.drawImage(buzzletwalksheetinv, (this.walkcounter * 10) % 40, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                                map_context.drawImage(buzzletinv, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                            }

                        } else {
                            map_context.drawImage(buzzletdeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    }
                } else if (this.starbatross == 1) {
                    if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                        if (this.dying <= 0) {

                            if (this.moving == true) {
                                this.walkcounter++
                                map_context.drawImage(starbatrosswalksheet, (this.walkcounter * 10) % 120, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                                map_context.drawImage(starbatross, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                            }
                        } else {
                            map_context.drawImage(starbatrossdeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    } else {
                        if (this.dying <= 0) {

                            if (this.moving == true) {
                                this.walkcounter++
                                map_context.drawImage(starbatrosswalksheetinv, (this.walkcounter * 10) % 120, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                                map_context.drawImage(starbatrossinv, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                            }
                        } else {
                            map_context.drawImage(starbatrossdeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }

                    }
                } else if (this.megagnat == 1) {
                    if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                        if (this.dying <= 0) {

                            if (this.moving == true) {
                                this.walkcounter++
                                map_context.drawImage(megagnatwalksheet, (this.walkcounter * 10) % 50, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                                map_context.drawImage(megagnat, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                            }
                        } else {
                            map_context.drawImage(megagnatdeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    } else {
                        if (this.dying <= 0) {

                            if (this.moving == true) {
                                this.walkcounter++
                                map_context.drawImage(megagnatwalksheetinv, (this.walkcounter * 10) % 50, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                                map_context.drawImage(megagnatinv, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                            }
                        } else {
                            map_context.drawImage(megagnatdeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    }
                }
            } else if (this.gogo == 1) {
                if (this.gogonaut == 1) {

                    if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                        if (this.dying <= 0) {

                            if (this.moving == true) {
                                this.walkcounter++
                                map_context.drawImage(gogonautwalksheet, (this.walkcounter * 10) % 60, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                                map_context.drawImage(gogonaut, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                            }
                            
                        } else {

                            map_context.drawImage(gogonautdeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    } else {

                        if (this.dying <= 0) {

                            if (this.moving == true) {
                                this.walkcounter++
                                map_context.drawImage(gogonautwalksheetinv, (this.walkcounter * 10) % 60, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                                map_context.drawImage(gogonautinv, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                            }

                        } else {

                            map_context.drawImage(gogonautdeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    }
                } else if (this.gogonautteam == 1) {
                    if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                        if (this.dying <= 0) {

                    
                            if (this.moving == true) {
                                this.walkcounter++
                                map_context.drawImage(gogonautteamwalksheet, (this.walkcounter * 10) % 50, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                                map_context.drawImage(gogonautteam, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                            }
                            
                        } else {

                            map_context.drawImage(gogonautteamdeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    } else {
                        if (this.dying <= 0) {

                    
                            if (this.moving == true) {
                                this.walkcounter++
                                map_context.drawImage(gogonautteamwalksheetinv, (this.walkcounter * 10) % 50, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                                map_context.drawImage(gogonautteaminv, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                            }
                        } else {
                            map_context.drawImage(gogonautteamdeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    }
                } else if (this.gogonautdefender == 1) {
                    if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                        if (this.dying <= 0) {

                            


                            if (this.moving == true) {
                                this.walkcounter++
                                map_context.drawImage(gogonautdefenderwalksheet, (this.walkcounter * 10) % 110, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                                map_context.drawImage(gogonautdefender, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                            }
                            
                        } else {
                            map_context.drawImage(gogonautdefenderdeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    } else {
                        if (this.dying <= 0) {

                            if (this.moving == true) {
                                this.walkcounter++
                                map_context.drawImage(gogonautdefenderwalksheetinv, (this.walkcounter * 10) % 110, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                                map_context.drawImage(gogonautdefenderinv, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                            }

                        } else {
                            map_context.drawImage(gogonautdefenderdeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }

                    }
                } else if (this.gogonautchampion == 1) {
                    if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                        if (this.dying <= 0) {

                            

                            if (this.moving == true) {
                                this.walkcounter++
                                if(this.walkcounter > 4){
                                    map_context.drawImage(gogonautchampionwalksheet, 40 + ((this.walkcounter * 10) % 40), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(gogonautchampionwalksheet, 0 + ((this.walkcounter * 10) % 40), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            } else {
                                if(this.walkcounter > 0){
                                    this.walkcounter--
                                }

                                if(this.walkcounter > 4){
                                    this.walkcounter = 4
                                    map_context.drawImage(gogonautchampionwalksheet, 40 + ((this.walkcounter * 10) % 40), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(gogonautchampionwalksheet, 0 + ((this.walkcounter * 10) % 120), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            }

                            
                            
                        } else {
                            map_context.drawImage(gogonautchampiondeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    } else {
                        if (this.dying <= 0) {


                            if (this.moving == true) {
                                this.walkcounter++
                                if(this.walkcounter > 4){
                                    map_context.drawImage(gogonautchampionwalksheetinv, 40 + ((this.walkcounter * 10) % 40), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(gogonautchampionwalksheetinv, 0 + ((this.walkcounter * 10) % 40), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            } else {
                                if(this.walkcounter > 0){
                                    this.walkcounter--
                                }

                                if(this.walkcounter > 4){
                                    this.walkcounter = 4
                                    map_context.drawImage(gogonautchampionwalksheetinv, 40 + ((this.walkcounter * 10) % 40), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(gogonautchampionwalksheetinv, 0 + ((this.walkcounter * 10) % 120), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            }
                        } else {
                            map_context.drawImage(gogonautchampiondeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    }
                }
            } else if (this.alagadile == 1) {
                if (this.bigalagadile == 1) {
                    if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                        if (this.dying <= 0) {
                            if (this.moving == true) {
                                this.walkcounter++
                                if(this.walkcounter > 4){
                                    map_context.drawImage(bigalagadilewalksheet, 40 + ((this.walkcounter * 10) % 70), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(bigalagadilewalksheet, 0 + ((this.walkcounter * 10) % 100), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            } else {
                                if(this.walkcounter > 0){
                                    this.walkcounter--
                                }

                                if(this.walkcounter > 4){
                                    this.walkcounter = 4
                                    map_context.drawImage(bigalagadilewalksheet, 40 + ((this.walkcounter * 10) % 70), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(bigalagadilewalksheet, 0 + ((this.walkcounter * 10) % 100), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            }
                        } else {
                            map_context.drawImage(bigalagadiledeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    } else {

                        if (this.dying <= 0) {
                            if (this.moving == true) {
                                this.walkcounter++
                                if(this.walkcounter > 4){
                                    map_context.drawImage(bigalagadilewalksheetinv, 40 + ((this.walkcounter * 10) % 70), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(bigalagadilewalksheetinv, 0 + ((this.walkcounter * 10) % 100), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            } else {
                                if(this.walkcounter > 0){
                                    this.walkcounter--
                                }
                                if(this.walkcounter > 4){
                                    this.walkcounter = 4
                                    map_context.drawImage(bigalagadilewalksheetinv, 40 + ((this.walkcounter * 10) % 70), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(bigalagadilewalksheetinv, 0 + ((this.walkcounter * 10) % 100), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            }
                        } else {
                            map_context.drawImage(bigalagadiledeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    }
                } else if (this.babyalagadile == 1) {
                    if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                        if (this.dying <= 0) {

                            if (this.moving == true) {
                                this.walkcounter++
                                if(this.walkcounter > 7){
                                    map_context.drawImage(alagadilewalksheet, 70 + ((this.walkcounter * 10) % 40), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(alagadilewalksheet, 0 + ((this.walkcounter * 10) % 80), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            } else {
                                if(this.walkcounter > 0){
                                    this.walkcounter--
                                }

                                if(this.walkcounter > 7){
                                    this.walkcounter = 7
                                    map_context.drawImage(alagadilewalksheet, 70 + ((this.walkcounter * 10) % 40), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(alagadilewalksheet, 0 + ((this.walkcounter * 10) % 80), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            }
                            
                        } else {

                            map_context.drawImage(alagadiledeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    } else {
                        if (this.dying <= 0) {

                            if (this.moving == true) {
                                this.walkcounter++
                                if(this.walkcounter > 7){
                                    map_context.drawImage(alagadilewalksheetinv, 70 + ((this.walkcounter * 10) % 40), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(alagadilewalksheetinv, 0 + ((this.walkcounter * 10) % 80), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            } else {
                                if(this.walkcounter > 0){
                                    this.walkcounter--
                                }

                                if(this.walkcounter > 7){
                                    this.walkcounter = 7
                                    map_context.drawImage(alagadilewalksheetinv, 70 + ((this.walkcounter * 10) % 40), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(alagadilewalksheetinv, 0 + ((this.walkcounter * 10) % 80), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            }

                        } else {
                            map_context.drawImage(alagadiledeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    }
                } else if (this.hunchalagadile == 1) {
                    if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                        if (this.dying <= 0) {
                            if (this.moving == true) {
                                this.walkcounter++
                                map_context.drawImage(hunchalagadilewalksheet, (this.walkcounter * 10) % 40, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                                map_context.drawImage(hunchalagadile, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                            }
                        } else {
                            map_context.drawImage(hunchalagadiledeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    } else {
                        if (this.dying <= 0) {
                            if (this.moving == true) {
                                this.walkcounter++
                                map_context.drawImage(hunchalagadilewalksheetinv, (this.walkcounter * 10) % 40, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                                map_context.drawImage(hunchalagadilewalksheetinv, 0, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            }
                        } else {
                            map_context.drawImage(hunchalagadiledeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }

                    }
                } else if (this.bighunchalagadile == 1) {
                    if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                        if (this.dying <= 0) {

                            if (this.moving == true) {
                                this.walkcounter++
                                map_context.drawImage(bighunchalagadilewalksheet, (this.walkcounter * 10) % 60, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                                map_context.drawImage(bighunchalagadilewalksheet, 0, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            }
                        } else {
                            map_context.drawImage(bighunchalagadiledeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    } else {
                        if (this.dying <= 0) {

                            if (this.moving == true) {
                                this.walkcounter++
                                map_context.drawImage(bighunchalagadilewalksheetinv, (this.walkcounter * 10) % 60, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                                map_context.drawImage(bighunchalagadilewalksheetinv, 0, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            }
                        } else {
                            map_context.drawImage(bighunchalagadiledeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    }
                }
            } else {
                if (this.targetroid == 1) {
                    if (sandmap.players.indexOf(this.faction) == sandmap.turn) {

                        if (this.moving == true) {
                            this.walkcounter++
                            map_context.drawImage(targetroidwalksheet, (this.walkcounter * 10) % 60, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        } else {
                            map_context.drawImage(targetroidwalksheet, 0, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    } else {

                        if (this.moving == true) {
                            this.walkcounter++
                            map_context.drawImage(targetroidwalksheetinv, (this.walkcounter * 10) % 60, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        } else {
                            map_context.drawImage(targetroidwalksheetinv, 0, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    }
                } else if (this.schlorkupine == 1) {
                    if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                        map_context.drawImage(schlorkupineimg, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                    } else {
                        map_context.drawImage(schlorkupineinvimg, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                    }
                } else if (this.hamartanscout == 1 || this.hamartansoldier == 1 || this.hamartaninvader == 1 || this.hamartanworker == 1) {
                    if (this.dying <= 0) {

                        if (this.hamartanscout == 1) {
                            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {


                                if (this.moving == true) {
                                    this.walkcounter++
                                    map_context.drawImage(hamartanscoutwalksheet, (this.walkcounter * 10) % 80, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                } else {
                                    map_context.drawImage(hamartanscout, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                                }

                            } else {

                                if (this.moving == true) {
                                    this.walkcounter++
                                    map_context.drawImage(hamartanscoutwalksheetinv, (this.walkcounter * 10) % 80, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                } else {
                                    map_context.drawImage(hamartanscoutinv, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                                }


                            }
                        } else if (this.hamartansoldier == 1) {

                            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {


                                if (this.moving == true) {
                                    this.walkcounter++
                                    map_context.drawImage(hamartansoldierwalksheet, (this.walkcounter * 10) % 90, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                } else {
                                    map_context.drawImage(hamartansoldier, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                                }

                            } else {

                                if (this.moving == true) {
                                    this.walkcounter++
                                    map_context.drawImage(hamartansoldierwalksheetinv, (this.walkcounter * 10) % 90, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                } else {
                                    map_context.drawImage(hamartansoldierinv, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                                }
                            }
                        } else if (this.hamartaninvader == 1) {

                            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {


                                if (this.moving == true) {
                                    this.walkcounter++
                                    if(this.walkcounter > 7){
                                        map_context.drawImage(hamartaninvaderwalksheet, 70 + ((this.walkcounter * 10) % 270), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                    }else{
                                        map_context.drawImage(hamartaninvaderwalksheet, 0 + ((this.walkcounter * 10) % 360), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                    }
                                } else {
                                    if(this.walkcounter > 0){
                                        this.walkcounter--
                                    }

                                    if(this.walkcounter > 7){
                                        this.walkcounter = 7
                                        map_context.drawImage(hamartaninvaderwalksheet, 70 + ((this.walkcounter * 10) % 270), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                    }else{
                                        map_context.drawImage(hamartaninvaderwalksheet, 0 + ((this.walkcounter * 10) % 360), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                    }
                                }
                            } else {


                                if (this.moving == true) {
                                    this.walkcounter++
                                    if(this.walkcounter > 7){
                                        map_context.drawImage(hamartaninvaderwalksheetinv, 70 + ((this.walkcounter * 10) % 270), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                    }else{
                                        map_context.drawImage(hamartaninvaderwalksheetinv, 0 + ((this.walkcounter * 10) % 360), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                    }
                                } else {
                                    if(this.walkcounter > 0){
                                        this.walkcounter--
                                    }

                                    if(this.walkcounter > 7){
                                        this.walkcounter = 7
                                        map_context.drawImage(hamartaninvaderwalksheetinv, 70 + ((this.walkcounter * 10) % 270), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                    }else{
                                        map_context.drawImage(hamartaninvaderwalksheetinv, 0 + ((this.walkcounter * 10) % 360), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                    }
                                }

                            }
                        } else if (this.hamartanworker == 1) {
                            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {

                                if (this.moving == true) {
                                    this.walkcounter++
                                    if(this.walkcounter > 4){                                        
                                        map_context.drawImage(hamartanworkerwalk, 40 + ((this.walkcounter * 10) % 130), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                    }else{
                                        map_context.drawImage(hamartanworkerwalk, 0 + ((this.walkcounter * 10) % 170), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                    }
                                } else {
                                    if(this.walkcounter > 0){
                                        this.walkcounter--
                                    }

                                    if(this.walkcounter > 4){
                                        this.walkcounter = 4
                                        map_context.drawImage(hamartanworkerwalk, 40 + ((this.walkcounter * 10) % 130), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                    }else{
                                        map_context.drawImage(hamartanworkerwalk, 0 + ((this.walkcounter * 10) % 170), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                    }
                                }
                                
                            } else {
                                // map_context.drawImage(hamartanworkerinv, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)

                                if (this.moving == true) {
                                    this.walkcounter++
                                    if(this.walkcounter > 4){                                        
                                        map_context.drawImage(hamartanworkerwalkinv, 40 + ((this.walkcounter * 10) % 130), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                    }else{
                                        map_context.drawImage(hamartanworkerwalkinv, 0 + ((this.walkcounter * 10) % 170), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                    }
                                } else {
                                    if(this.walkcounter > 0){
                                        this.walkcounter--
                                    }

                                    if(this.walkcounter > 4){
                                        this.walkcounter = 4
                                        map_context.drawImage(hamartanworkerwalkinv, 40 + ((this.walkcounter * 10) % 130), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                    }else{
                                        map_context.drawImage(hamartanworkerwalkinv, 0 + ((this.walkcounter * 10) % 170), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                    }
                                }
                            }
                        }
                    } else {
                        map_context.drawImage(hamartandeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                    }
                } else if (this.drone == 1) {
                    if (this.dying <= 0) {
                        if (this.super == 1) {
                            map_context.drawImage(superdrone, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                        } else {
                            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {

                            if (this.moving == true) {
                                this.walkcounter++
                                if(this.walkcounter >= 4){
                                    map_context.drawImage(dronewalksheet, 40, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(dronewalksheet, 0 + ((this.walkcounter * 10) % 40), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            } else {
                                if(this.walkcounter > 0){
                                    this.walkcounter--
                                }

                                if(this.walkcounter > 4){
                                    this.walkcounter = 4
                                    map_context.drawImage(dronewalksheet, 40, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(dronewalksheet, 0 + ((this.walkcounter * 10) % 40), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            }
                            } else {

                            if (this.moving == true) {
                                this.walkcounter++
                                if(this.walkcounter >= 4){
                                    map_context.drawImage(dronewalksheetinv, 40, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(dronewalksheetinv, 0 + ((this.walkcounter * 10) % 40), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            } else {
                                if(this.walkcounter > 0){
                                    this.walkcounter--
                                }

                                if(this.walkcounter > 4){
                                    this.walkcounter = 4
                                    map_context.drawImage(dronewalksheetinv, 40, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(dronewalksheetinv, 0 + ((this.walkcounter * 10) % 40), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            }

                            }
                        }
                    } else {
                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                            map_context.drawImage(dronedeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        } else {
                            map_context.drawImage(dronedeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)

                        }
                    }
                } else if (this.infantry == 1) {

                    if (this.dying <= 0) {
                        if (this.super == 1) {
                            map_context.drawImage(superinfantry, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                        } else {
                            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {

                                if (this.moving == true) {
                                    this.walkcounter++
                                    map_context.drawImage(infantrywalksheet, (this.walkcounter * 10) % 80, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                } else {
                                    map_context.drawImage(infantry, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                                }
                            } else {

                                if (this.moving == true) {
                                    this.walkcounter++
                                    map_context.drawImage(infantrywalksheetinv, (this.walkcounter * 10) % 80, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                } else {
                                    map_context.drawImage(infantryinv, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                                }

                            }
                        }
                    } else {

                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                            map_context.drawImage(infantrydeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        } else {
                            map_context.drawImage(infantrydeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)

                        }
                    }
                } else if (this.infantry == 2) {
                    if (this.dying <= 0) {
                        if (this.super == 1) {
                            map_context.drawImage(supersniper1, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                        } else {
                            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                                if (this.moving == true) {
                                    this.walkcounter++
                                    map_context.drawImage(sniperwalksheet, (this.walkcounter * 10) % 80, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                } else {
                                    map_context.drawImage(sniper1, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                                }
                            } else {

                                if (this.moving == true) {
                                    this.walkcounter++
                                    map_context.drawImage(sniperwalksheetinv, (this.walkcounter * 10) % 80, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                } else {
                                    // map_context.drawImage(sniper1inv, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                                    map_context.drawImage(sniperwalksheetinv, 0, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            }

                        }
                    } else {

                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                            map_context.drawImage(sniper1death, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        } else {
                            map_context.drawImage(sniper1deathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)

                        }

                    }
                } else if (this.harvester == 1) {
                    if (this.dying <= 0) {
                        if (this.super == 1) {
                            map_context.drawImage(superharvester, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                        } else {
                            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                                map_context.drawImage(harvester, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                            } else {
                                map_context.drawImage(harvesterinv, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)

                            }

                        }
                    } else {
                        map_context.drawImage(harvesterdeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)

                    }
                } else if (this.nymph == 1) {
                    if (this.dying <= 0) {
                        if (this.sana == 1) {
                            map_context.drawImage(nymphsana, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                        } else {
                            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {

                                if (this.moving == true) {
                                    this.walkcounter++
                                    map_context.drawImage(nymphsheet, (this.walkcounter * 10) % 40, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                } else {
                                    map_context.drawImage(nymph, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                                }

                            } else {

                                if (this.moving == true) {
                                    this.walkcounter++
                                    map_context.drawImage(nymphwalksheetinv, (this.walkcounter * 10) % 40, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                } else {
                                    map_context.drawImage(nymphinv, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                                }
                            }
                        }
                    } else {

                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                            map_context.drawImage(nymphdeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        } else {

                            map_context.drawImage(nymphdeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }

                    }
                } else if (this.nymph == 2) {
                    if (this.dying <= 0) {
                        if (this.sana == 1) {
                            map_context.drawImage(scuttlersana, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                        } else {
                            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                                if (this.moving == true) {
                                    this.walkcounter++
                                    map_context.drawImage(scuttlersheet, (this.walkcounter * 10) % 60, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                } else {
                                    map_context.drawImage(scuttler, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                                }
                            } else {
                                if (this.moving == true) {
                                    this.walkcounter++
                                    map_context.drawImage(scuttlersheetinv, (this.walkcounter * 10) % 60, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                } else {
                                    map_context.drawImage(scuttlerinv, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                                }

                            }
                        }
                    } else {

                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                            map_context.drawImage(scuttlerdeathimg, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        } else {

                            map_context.drawImage(scuttlerdeathimginv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }

                    }
                } else if (this.gamergate == 1) {

                    if (this.dying >= 1) {

                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                            map_context.drawImage(gamergatedeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        } else {

                            map_context.drawImage(gamergatedeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    } else {

                        if (this.submerged == 0) {

                            if (this.sana == 1) {
                                map_context.drawImage(gamergatesana, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                            } else {
                                if (sandmap.players.indexOf(this.faction) == sandmap.turn) {


                                    if (this.moving == true) {
                                        this.walkcounter++
                                        map_context.drawImage(gamergatesheet, (this.walkcounter * 10) % 80, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                    } else {
                                        map_context.drawImage(gamergate, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                                    }
                                } else {
                                    if (this.moving == true) {
                                        this.walkcounter++
                                        map_context.drawImage(gamergatewalksheetinv, (this.walkcounter * 10) % 80, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                    } else {
                                        map_context.drawImage(gamergateinv, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                                    }
                                }
                            }
                        } else {
                            if (sandmap.players[sandmap.turn] == this.faction) {

                                if (this.sana == 1) {
                                    map_context.drawImage(gamergatedugsana, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                                } else {
                                    if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                                        map_context.drawImage(gamergatedug, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                                    } else {
                                        map_context.drawImage(gamergateduginv, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                                    }
                                }
                            } else {
                                let wet = 0//0

                            for(let d = 1;d<sandmap.players.length;d++){
                                const indexer = Math.abs((sandmap.turn + d)%sandmap.players.length)
                                for (let k = 0; k < sandmap.players[indexer].units.length; k++) {
                                    if (sandmap.players[indexer].units[k].drone == 1 || sandmap.players[indexer].units[k].imago == 2 || sandmap.players[indexer].units[k].hamartanscout == 1 || sandmap.players[indexer].units[k].pufffellow == 1 || sandmap.players[indexer].units[k].sporevizir == 1) {
                                        if (this.gameline.target == sandmap.players[indexer].units[k].body) {
                                            if (this.gameline.hypotenuse() <= sandmap.players[indexer].units[k].sight) {
                                                wet = 1
                                                break
                                            }
                                        } else {
                                            this.gameline.target = sandmap.players[indexer].units[k].body
                                            if (this.gameline.hypotenuse() <= sandmap.players[indexer].units[k].sight) {
                                                wet = 1
                                                break
                                            }
                                        }
                                    }
                                }
                            }
                                if (wet == 1) {
                                    if (this.sana == 1) {
                                        map_context.drawImage(gamergatedugsana, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                                    } else {
                                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                                            map_context.drawImage(gamergatedug, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                                        } else {
                                            map_context.drawImage(gamergateduginv, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)

                                        }
                                    }
                                }
                            }
                        }
                    }
                } else if (this.imago == 1) {

                    if (this.dying <= 0) {
                        if (this.sana == 1) {
                            map_context.drawImage(imagosana, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                        } else {

                            if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                                if (this.moving == true) {
                                    this.walkcounter++
                                    map_context.drawImage(imagosheet, (this.walkcounter * 10) % 160, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                } else {
                                    map_context.drawImage(imago, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                                }
                            } else {
                                if (this.moving == true) {
                                    this.walkcounter++
                                    map_context.drawImage(imagowalksheetinv, (this.walkcounter * 10) % 160, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                } else {
                                    map_context.drawImage(imagowalksheetinv,0, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }

                            }
                        }
                    } else {

                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                            map_context.drawImage(imagodeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        } else {

                            map_context.drawImage(imagodeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    }
                } else if (this.pollinator == 1) {
                    if (this.dying <= 0) {
                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {

                            librilbianpollinatorwalksheet


                            if (this.moving == true) {
                                this.walkcounter++
                                map_context.drawImage(librilbianpollinatorwalksheet, 0 + ((this.walkcounter * 10) % 60), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                                map_context.drawImage(librilbianpollinator, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                            }
                            
                        } else {

                            if (this.moving == true) {
                                this.walkcounter++
                                map_context.drawImage(librilbianpollinatorwalksheetinv, 0 + ((this.walkcounter * 10) % 60), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                                map_context.drawImage(librilbianpollinatorinv, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                            }
                        }
                    } else {
                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                            map_context.drawImage(librilbianpollinatordeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)

                        } else {
                            map_context.drawImage(librilbianpollinatordeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)

                        }
                    }
                } else if (this.goliophyte == 1) {
                    if (this.dying <= 0) {
                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {

                            // goliophytewalksheet

                            if (this.moving == true) {
                                this.walkcounter++
                                if(this.walkcounter > 6){
                                    map_context.drawImage(goliophytewalksheet, 60 + ((this.walkcounter * 10) % 60), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(goliophytewalksheet, 0 + ((this.walkcounter * 10) % 120), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            } else {
                                if(this.walkcounter > 0){
                                    this.walkcounter--
                                }

                                if(this.walkcounter > 6){
                                    this.walkcounter = 6
                                    map_context.drawImage(goliophytewalksheet, 60 + ((this.walkcounter * 10) % 60), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(goliophytewalksheet, 0 + ((this.walkcounter * 10) % 120), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            }

                            
                            // map_context.drawImage(librilbiangoliophyte, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                        } else {

                            if (this.moving == true) {
                                this.walkcounter++
                                if(this.walkcounter > 6){
                                    map_context.drawImage(goliophytewalksheetinv, 60 + ((this.walkcounter * 10) % 60), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(goliophytewalksheetinv, 0 + ((this.walkcounter * 10) % 120), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            } else {
                                if(this.walkcounter > 0){
                                    this.walkcounter--
                                }

                                if(this.walkcounter > 6){
                                    this.walkcounter = 6
                                    map_context.drawImage(goliophytewalksheetinv, 60 + ((this.walkcounter * 10) % 60), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(goliophytewalksheetinv, 0 + ((this.walkcounter * 10) % 120), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            }
                        }
                    } else {

                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                            map_context.drawImage(librilbiangoliophytedeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)

                        } else {
                            map_context.drawImage(librilbiangoliophytedeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)

                        }
                    }
                } else if (this.pufffellow == 1) {
                    if (this.dying <= 0) {
                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {

                            if (this.moving == true) {
                                this.walkcounter++
                                map_context.drawImage(pufffellowwalksheet, 0 + ((this.walkcounter * 10) % 60), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                                map_context.drawImage(librilbianpufffellow, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                            }
                        } else {

                            if (this.moving == true) {
                                this.walkcounter++
                                map_context.drawImage(pufffellowwalksheetinv, 0 + ((this.walkcounter * 10) % 60), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            } else {
                                map_context.drawImage(librilbianpufffellowinv, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5)
                            }
                        }
                    } else {

                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                            map_context.drawImage(librilbianpufffellowdeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)

                        } else {
                            map_context.drawImage(librilbianpufffellowdeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)

                        }

                    }
                } else if (this.podman == 1) {
                    if (this.dying <= 0) {
                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {


                            if (this.moving == true) {
                                this.walkcounter++
                                if(this.walkcounter > 6){
                                    map_context.drawImage(podmanwalk, 40 + ((this.walkcounter * 10) % 60), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(podmanwalk, 0 + ((this.walkcounter * 10) % 100), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            } else {
                                if(this.walkcounter > 0){
                                    this.walkcounter--
                                }

                                if(this.walkcounter > 4){
                                    this.walkcounter = 4
                                    map_context.drawImage(podmanwalk, 40 + ((this.walkcounter * 10) % 60), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(podmanwalk, 0 + ((this.walkcounter * 10) % 100), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            }

                        } else {


                            if (this.moving == true) {
                                this.walkcounter++
                                if(this.walkcounter > 6){
                                    map_context.drawImage(librilbianpodmaninv, 40 + ((this.walkcounter * 10) % 60), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(librilbianpodmaninv, 0 + ((this.walkcounter * 10) % 100), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            } else {
                                if(this.walkcounter > 0){
                                    this.walkcounter--
                                }

                                if(this.walkcounter > 4){
                                    this.walkcounter = 4
                                    map_context.drawImage(librilbianpodmaninv, 40 + ((this.walkcounter * 10) % 60), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }else{
                                    map_context.drawImage(librilbianpodmaninv, 0 + ((this.walkcounter * 10) % 100), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                }
                            }
                        }
                    } else {


                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                            map_context.drawImage(librilbianpodmandeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)

                        } else {
                            map_context.drawImage(librilbianpodmandeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)

                        }
                    }
                } else if (this.fruiting == 1) {
                    if (this.dying <= 0) {
                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {

                            if (this.moving == true) {
                                this.walkcounter++
                                    map_context.drawImage(fruitingbuddywalksheet, 0 + ((this.walkcounter * 10) % 50), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                
                            } else {
                                    map_context.drawImage(fruitingbuddywalksheet, 0, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            }

                        } else {

                            if (this.moving == true) {
                                this.walkcounter++
                                    map_context.drawImage(fruitingbuddywalksheetinv, 0 + ((this.walkcounter * 10) % 50), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                
                            } else {
                                    map_context.drawImage(fruitingbuddywalksheetinv, 0, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            }
                        }
                    } else {

                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                            map_context.drawImage(fruitingbuddydeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        } else {
                            map_context.drawImage(fruitingbuddydeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }
                    }
                } else if (this.mycoknight == 1) {

                    if (this.dying <= 0) {
                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                            if (this.moving == true) {
                                this.walkcounter++
                                    map_context.drawImage(mycoknightwalksheet, 0 + ((this.walkcounter * 10) % 160), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                
                            } else {
                                    map_context.drawImage(mycoknight, 0, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            }
                        } else {

                            if (this.moving == true) {
                                this.walkcounter++
                                    map_context.drawImage(mycoknightwalksheetinv, 0 + ((this.walkcounter * 10) % 160), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                
                            } else {
                                    map_context.drawImage(mycoknightinv, 0, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            }

                        }
                    } else {

                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                            map_context.drawImage(mycoknightdeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        } else {
                            map_context.drawImage(mycoknightdeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)

                        }
                    }
                } else if (this.sporevizir == 1) {

                    if (this.dying <= 0) {
                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {

                            if (this.moving == true) {
                                this.walkcounter++
                                    map_context.drawImage(sporevizirwalksheet, 0 + ((this.walkcounter * 10) % 90), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                
                            } else {
                                    map_context.drawImage(sporevizirwalksheet, 0, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            }
                        } else {
                            if (this.moving == true) {
                                this.walkcounter++
                                    map_context.drawImage(sporevizirwalksheetinv, 0 + ((this.walkcounter * 10) % 90), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                
                            } else {
                                    map_context.drawImage(sporevizirwalksheetinv, 0, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            }

                        }
                    } else {
                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                            map_context.drawImage(sporevizirdeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)

                        } else {
                            map_context.drawImage(sporevizirdeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)


                        }

                    }
                } else if (this.seer == 1) {

                    if (this.dying <= 0) {
                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                            sporeseerwalksheet


                            if (this.moving == true) {
                                this.walkcounter+=1
                                    map_context.drawImage(sporeseerwalksheet, 0 + ((Math.floor(this.walkcounter )* 10) % 180), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                
                            } else {
                                    map_context.drawImage(sporeseerwalksheet, 0, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            }
                        } else {

                            if (this.moving == true) {
                                this.walkcounter+=1
                                    map_context.drawImage(sporeseerwalksheetinv, 0 + ((Math.floor(this.walkcounter )* 10) % 180), 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                                
                            } else {
                                    map_context.drawImage(sporeseerwalksheetinv, 0, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                            }

                        }
                    } else {
                        if (sandmap.players.indexOf(this.faction) == sandmap.turn) {
                            map_context.drawImage(sporeseerdeath, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        } else {
                            map_context.drawImage(sporeseerdeathinv, (this.dying - 1) * 10, 0, 10, 10, Math.floor(this.body.x) - 5, Math.floor(this.body.y) - 5, 10, 10)
                        }


                    }
                } else {
                    //////////console.log(this)
                    this.body.draw()
                }
            }


            if (this.selected == 1 || this.selected == 2 || globalHealthDraw == true) {
                if (sandmap.turn == sandmap.players.indexOf(this.faction) || globalHealthDraw == true) {
                    // this.dataOutput()
                    this.healthbar = new Rectangle(this.body.x - 5.5, this.body.y + 2.5, 11, 3, "black")
                    this.healthbar.draw()
                    if (this.health / this.maxhealth > .5) {
                        this.healthbar = new Rectangle(this.body.x - 5, this.body.y + 3, (this.health / this.maxhealth) * 10, 2, `rgb(${(1 - ((this.health / this.maxhealth))) * 512},${255},  0)`)
                    } else {
                        this.healthbar = new Rectangle(this.body.x - 5, this.body.y + 3, (this.health / this.maxhealth) * 10, 2, `rgb(${255},${(((this.health / this.maxhealth) * 1)) * 512},  0)`)
                    }
                    this.healthbar.draw()
                }
            } else {
                this.spawnsmall = {}
                this.morph = {}
                this.morph.isPointInside = empty
                this.morph2 = {}
                this.morph2.isPointInside = empty
                this.morph3 = {}
                this.morph3.isPointInside = empty
                // for(let t = 0;t<this.commandPanel.commandButtons.length;t++){
                //     this.commandPanel.commandButtons[t].isPointInside = empty
                // }


                this.attackUI = {}
                this.attackUI.isPointInside = empty
                this.speedUI = {}
                this.speedUI.isPointInside = empty
                this.defenseUI = {}
                this.defenseUI.isPointInside = empty
                this.incomeUI = {}
                this.incomeUI.isPointInside = empty

            }

            // for(let d = 1;d<sandmap.players.length;d++){
            const indexer = Math.abs((sandmap.players.indexOf(this.faction) -1))
            for (let t = 0; t < this.shots.length; t++) {
                this.shots[t].stage++
                let dindex = -1
                        if(onlineNow == 1){
                let target = {}
                let min = 100
                let index = -1
                let buildingflag = 0


                                // for(let d = 1;d<sandmap.players.length;d++){
                                    ////console.log(this.shots[t].refhealth.factionNum)
                                const indexer =this.shots[t].refhealth.factionNum/////// sandmap.players.indexOf(this.attacktarget.faction)   // Math.abs((sandmap.players.indexOf(this.faction) + d)%sandmap.players.length)


                                        for(let k = 0;k<sandmap.players[indexer].units.length;k++){
                                            if(Math.abs(this.shots[t].refhealth.id-sandmap.players[indexer].units[k].id) < min){
                                                min = Math.abs(this.shots[t].refhealth.id-sandmap.players[indexer].units[k].id)
                                                index = k
                                                dindex = indexer
                                                buildingflag = 0
                                            }
                                        }
                                        for(let k = 0;k<sandmap.players[indexer].buildings.length;k++){
                                            if(Math.abs(this.shots[t].refhealth.id-sandmap.players[indexer].buildings[k].id) < min){
                                                min = Math.abs(this.shots[t].refhealth.id-sandmap.players[indexer].buildings[k].id)
                                                index = k
                                                buildingflag = 1
                                                dindex = indexer
                                            }
                                        }

                                // }
                if(index == -1){
                    return
                }
                if(dindex == -1){
                    return
                }
                if(buildingflag == 0){
                    //////////console.log(dindex, index, sandmap.players[dindex],  sandmap.players[dindex].units)
                    target.x = sandmap.players[dindex].units[Math.min(index, sandmap.players[dindex].units.length-1)].body.x
                    target.y = sandmap.players[dindex].units[Math.min(index, sandmap.players[dindex].units.length-1)].body.y
                }else{
                    if(typeof sandmap.players[dindex].buildings[Math.min(index, sandmap.players[dindex].buildings.length-1)].body == "undefined"){
                        return
                    }
                    target.x = sandmap.players[dindex].buildings[Math.min(index, sandmap.players[dindex].buildings.length-1)].body.x
                    target.y = sandmap.players[dindex].buildings[Math.min(index, sandmap.players[dindex].buildings.length-1)].body.y
                }
                this.shots[t].x = (this.body.x * (1 - (this.shots[t].stage / this.projectilespeed))) + (((this.shots[t].stage / this.projectilespeed)) * target.x)
                this.shots[t].y = (this.body.y * (1 - (this.shots[t].stage / this.projectilespeed))) + (((this.shots[t].stage / this.projectilespeed)) * target.y)
                        }else{

                this.shots[t].x = (this.body.x * (1 - (this.shots[t].stage / this.projectilespeed))) + (((this.shots[t].stage / this.projectilespeed)) * this.shots[t].refhealth.body.x)
                this.shots[t].y = (this.body.y * (1 - (this.shots[t].stage / this.projectilespeed))) + (((this.shots[t].stage / this.projectilespeed)) * this.shots[t].refhealth.body.y)
                        }
                this.shots[t].draw()
                if (this.shots[t].stage >= this.projectilespeed) {
                    this.shots[t].refhealth.health -= Math.max((this.damage * 3) - this.shots[t].attacktarget.defense, 0) //5?
                    this.shots[t].refhealth.debt += Math.max((this.damage * 3) - this.shots[t].attacktarget.defense, 0) //5?

                        if(onlineNow == 1){
                            let Json = {}
                            Json.d = Math.max((this.damage * 3) - this.attacktarget.defense, 0)
                            Json.p =  dindex
                            if(this.attacktarget.built == 1){
                            Json.b =  1
                            }else{

                            Json.b =  0
                            }
                            Json.i = this.shots[t].refhealth.id // sandmap.players[Math.abs(sandmap.turn-1)].units.indexOf(this.attacktarget) //this.shots[t].refhealth.index //sandmap.players[Math.abs(sandmap.turn-1)].units.indexOf(this.shots[t].refhealth)
                            // roughSizeOfObject(Json)
                        if(campaignController.on !== 1 && AImode != 1){
                            ws.send(JSON.stringify(Json))
                        }
                        }
                        // }



                    if (this.shots[t].refhealth.spikes > 0) {
                        this.health -= (this.shots[t].refhealth.spikes * (this.damage * 3))
                        if (this.health < 0) {
                            this.health = -3
                        }
                    }

                    if (this.shots[t].refhealth.health < 0) {
                        this.shots[t].refhealth.health = -3
                    }
                    //////////console.log(this.shots[t].refhealth)

                    if (campaignController.mission > -1 && campaignController.mission < 5) {
                        sandmap.players[indexer].attackedAt = this.tile
                        if (sandmap.players[indexer].defending < 0) {
                            sandmap.players[indexer].defending = 1
                        } else {
                            sandmap.players[indexer].defending += sandmap.players[indexer].units.length
                        }
                        //////////console.log(sandmap.players[indexer].attackedAt)
                    } else if (campaignController.mission >= 5) {
                        sandmap.players[indexer].attackedAt = this.tile
                        if (sandmap.players[indexer].defending < 0) {
                            sandmap.players[indexer].defending = 1
                        } else {
                            if (sandmap.players[indexer].units.length > 10) {
                                sandmap.players[indexer].defending += (sandmap.players[indexer].units.length) * .5
                            } else {
                                sandmap.players[indexer].defending += (sandmap.players[indexer].units.length)
                            }
                        }
                    } else {
                        sandmap.players[indexer].attackedAt = this.tile
                        if (sandmap.players[indexer].defending < 0) {
                            sandmap.players[indexer].defending = 1
                        } else {
                            if (sandmap.players[indexer].units.length > 10) {
                                sandmap.players[indexer].defending += (sandmap.players[indexer].units.length) * .5
                            } else {
                                sandmap.players[indexer].defending += (sandmap.players[indexer].units.length)
                            }
                        }
                    }


                    this.shots[t].marked = 1

                    if (this.shots[t].refhealth.submerged == 1) {
                        this.attacktarget = {}
                        this.attacktarget.tile = {}

                        //new
                        this.attacktarget.tile.x = -100000
                        this.attacktarget.tile.y = -100000
                        this.attacktarget.tile.t = 0
                        this.attacktarget.tile.k = 0
                    }
                    // }
                }
            }
        // }
            for (let t = 0; t < this.shots.length; t++) {
                if (this.shots[t].marked == 1) {
                    this.shots.splice(t, 1)
                }
            }








        }
    }


    function invert_cantor(z) {
        let w = Math.floor((Math.sqrt(8 * z + 1) - 1) / 2)
        let t = w * (w + 1) / 2
        let pair = {}
        pair.x = w - z + t
        pair.y = z - t
        return pair
    }


    function startGame() {
        start = 0
        if(sandmap.players.length >= 1){
            sandmap.players[0].units = []
            for (let t = 0; t < 3; t++) {
                const agent1 = new Agent(sandmap.blocks[5][t + 5], sandmap.players[0])
            }
        }
        if(sandmap.players.length >= 2){
            sandmap.players[1].units = []
        for (let t = 0; t < 3; t++) {
            const agent2 = new Agent(sandmap.blocks[(worldscale - 6)][(worldscale - 6) - t], sandmap.players[1])
        }
    }

    if(sandmap.players.length >= 3){
        sandmap.players[2].units = []
        for (let t = 0; t < 3; t++) {
            const agent3 = new Agent(sandmap.blocks[(worldscale - 6)][( 6) - t], sandmap.players[2])
        }
    }

    if(sandmap.players.length >= 4){
        sandmap.players[3].units = []
        for (let t = 0; t < 3; t++) {
            const agent4 = new Agent(sandmap.blocks[(t + 6)][(worldscale - 6) - t], sandmap.players[3])
        }
    }
    start = 1
    }

    startGame()
    // const pather = astar.search(sandmap, sandmap.blocks[10][10], sandmap.blocks[12][25])
    // for(let t = 0;t<10;t++){
    // pather.findPath()

    // }
    start = 1

    const endbutton = new UiRectangle(sandmap.window.minibody.x + 260, sandmap.window.minibody.y - 77, 100, 75, "#333333")
    let connectedlight = new UiRectangle(sandmap.window.minibody.x + sandmap.window.minibody.width-10, sandmap.window.minibody.y - 10, 10, 10, "#FF00FF")
    let endgame = 0

    // for(let  t = 0;t<worldscale;t++){
    //     for(let  k = 0;k<worldscale;k++){    
    //         sandmap.players[0].seen.push(sandmap.blocks[t][k])   
    //         sandmap.players[1].seen.push(sandmap.blocks[t][k])    
    //         if(sandmap.blocks[t][k].sourcerock > 0){
    //             sandmap.players[0].seenrocks.push(sandmap.blocks[t][k])
    //             sandmap.players[1].seenrocks.push(sandmap.blocks[t][k])
    //         }
    //     }
    // }

    const topside = 0
    const underdog = 0

    class TestingPair {
        constructor(arr = [0, 0]) {
            this.arr = arr
        }
    }

    class TestingUnit {
        constructor() {
            this.map = {}
            this.total = 0
            this.type1 = 4
            this.type2 = 2
        }
        operate() {


            if (keysPressed['m']) {
                //////////console.log(this)
            }
            if ((sandmap.players[0].units.length > sandmap.players[1].units.length + 90 && sandmap.players[1].type != 8) || sandmap.players[1].units.length < 1) {

                // this.type1++
                if (this.type1 == 6) {
                    this.type1 = 7
                }
                if (this.type1 == 10) {
                    // this.type2++
                }
                if (this.type2 == 6) {
                    this.type2 = 7
                }
                this.type1 %= 10
                this.type2 %= 10
                let names = [`${sandmap.players[0].name}`, `${sandmap.players[1].name}`]
                // //////////console.log(this.map[`${names[0]}:${names[1]}`])
                // //////////console.log(`${names[0]}:${names[1]}`)
                if (typeof this.map[`${names[0]}:${names[1]}`] == "undefined") {
                    this.map[`${names[0]}:${names[1]}`] = [0, 0]
                }
                this.map[`${names[0]}:${names[1]}`][0]++


                score.initialize() // = new ScoreGraph()
                campaignController.initialize() // = new Campaign()
                sandmap.initialize(CANVAS_WIDTH, CANVAS_HEIGHT, 0, 0, []) // = new Sandmap(CANVAS_WIDTH, CANVAS_HEIGHT, 0, 0, []);
                start = 0
                playstart = 0
                endgame = 0
                // score = new ScoreGraph()
                score.initialize()
                sandmap.players[0].type = this.type1
                sandmap.players[1].type = this.type2
                sandmap.players[0].name = factionNames[this.type1]
                sandmap.players[1].name = factionNames[this.type2]
                sandmap.players[0].units = []
                sandmap.players[1].units = []
                start = 0
                for (let t = 0; t < campaignsounds.length; t++) {
                    campaignsounds[t].pause()
                    campaignsounds[t].currentTime = 0
                }
                for (let t = 0; t < 3; t++) {
                    const agent1 = new Agent(sandmap.blocks[5][t + 5], sandmap.players[0])
                }
                for (let t = 0; t < 3; t++) {
                    const agent2 = new Agent(sandmap.blocks[(worldscale - 6)][(worldscale - 6) - t], sandmap.players[1])
                }
                sandmap.players[0].clickrate = 1
                sandmap.players[1].clickrate = 1
                sandmap.players[0].isAI = 1
                sandmap.players[1].isAI = 1
                let mapfix = new Mapskinner(maplist[mapindex])
                start = 0
                playstart = 1
                return
            }
            if ((sandmap.players[0].units.length < sandmap.players[1].units.length - 90 && sandmap.players[0].type != 8) || sandmap.players[0].units.length < 1) {

                // this.type1++
                if (this.type1 == 6) {
                    this.type1 = 7
                }
                if (this.type1 == 10) {
                    // this.type2++
                }
                if (this.type2 == 6) {
                    this.type2 = 7
                }
                this.type1 %= 10
                this.type2 %= 10
                let names = [`${sandmap.players[0].name}`, `${sandmap.players[1].name}`]
                // //////////console.log(this.map[`${names[0]}:${names[1]}`])
                // //////////console.log(`${names[0]}:${names[1]}`)
                if (typeof this.map[`${names[0]}:${names[1]}`] == "undefined") {
                    this.map[`${names[0]}:${names[1]}`] = [0, 0]
                }
                this.map[`${names[0]}:${names[1]}`][1]++


                score.initialize() // = new ScoreGraph()
                campaignController.initialize() // = new Campaign()
                sandmap.initialize(CANVAS_WIDTH, CANVAS_HEIGHT, 0, 0, []) // = new Sandmap(CANVAS_WIDTH, CANVAS_HEIGHT, 0, 0, []);
                start = 0
                playstart = 0
                endgame = 0
                // score = new ScoreGraph()
                score.initialize()
                sandmap.players[0].type = this.type1
                sandmap.players[1].type = this.type2
                sandmap.players[0].name = factionNames[this.type1]
                sandmap.players[1].name = factionNames[this.type2]
                sandmap.players[0].units = []
                sandmap.players[1].units = []
                start = 0
                for (let t = 0; t < campaignsounds.length; t++) {
                    campaignsounds[t].pause()
                    campaignsounds[t].currentTime = 0
                }
                for (let t = 0; t < 3; t++) {
                    const agent1 = new Agent(sandmap.blocks[5][t + 5], sandmap.players[0])
                }
                for (let t = 0; t < 3; t++) {
                    const agent2 = new Agent(sandmap.blocks[(worldscale - 6)][(worldscale - 6) - t], sandmap.players[1])
                }

                sandmap.players[0].clickrate = 1
                sandmap.players[1].clickrate = 1
                sandmap.players[0].isAI = 1
                sandmap.players[1].isAI = 1
                let mapfix = new Mapskinner(maplist[mapindex])
                start = 0
                playstart = 1
                return
            }

        }
    }

    let testingUnit = new TestingUnit()

let count = 0

    function main() {
        if(onlineNow == 1){
            for(let k =0;k<sandmap.players.length;k++){
                if(k!= sandmap.turn){
                    for (let t = 0; t < sandmap.players[k].units.length; t++) {
                        sandmap.players[k].idtable.push(sandmap.players[k].units[t].id)
                        sandmap.players[k].units[t].decay--
                        if (sandmap.players[k].units[t].decay < 0) {
                            sandmap.players[k].units[t].health = -3
                        }
                    }
                    for (let t = 0; t < sandmap.players[k].buildings.length; t++) {
                        sandmap.players[k].idtable.push(sandmap.players[k].buildings[t].id)
                        sandmap.players[k].buildings[t].decay--
                        if (sandmap.players[k].buildings[t].decay < 0) {
                            sandmap.players[k].buildings[t].health = -3
                        }
                    }
                }
            }
        }

        //////////console.log("start")
        if(keysPressed['l']){
            //////////console.log(totalbytes, frames, (Date.now()-worldnow)/1000)
            // worldnow = Date.now()
            // totalbytes=0
            // frames=0
        }

        if(gamepadAPI.buttonPressed('Start')){
            paused = 1
        }
        if(keysPressed['Escape']){
            paused = 1
        }

        if(controllerSupport==1){
        gamepadAPI.update() //checks for button presses/stick movement on the connected controller)
        }
        // testingUnit.operate()
        if (keysPressed['?']) {

            score.initialize() // = new ScoreGraph()
            campaignController.initialize() // = new Campaign()
            sandmap.initialize(CANVAS_WIDTH, CANVAS_HEIGHT, 0, 0, []) // = new Sandmap(CANVAS_WIDTH, CANVAS_HEIGHT, 0, 0, []);
            start = 0
            playstart = 0
            endgame = 0
            // score = new ScoreGraph()
            score.initialize()
            sandmap.players[0].units = []
            sandmap.players[1].units = []
            start = 0
            for (let t = 0; t < campaignsounds.length; t++) {
                campaignsounds[t].pause()
                campaignsounds[t].currentTime = 0
            }
            for (let t = 0; t < 3; t++) {
                const agent1 = new Agent(sandmap.blocks[5][t + 5], sandmap.players[0])
            }
            for (let t = 0; t < 3; t++) {
                const agent2 = new Agent(sandmap.blocks[(worldscale - 6)][(worldscale - 6) - t], sandmap.players[1])
            }
            start = 0
            return
        }

        // if(keysPressed['p']){
        //     sandmap.players[0].units[0].health = 0
        // }

        if (campaignController.mission <= 9 && campaignController.mission > -1) {
            let wet = 0
            for (let t = 0; t < sandmap.players[0].units.length; t++) {
                if (sandmap.players[0].units[t].sana == 1) {
                    wet = 1
                }
            }
            if (wet == 0) {
                for (let t = 0; t < sandmap.players[0].units.length; t++) {
                    sandmap.players[0].units[t].health = 0

                }
                for (let t = 0; t < sandmap.players[0].buildings.length; t++) {
                    sandmap.players[0].buildings[t].health = 0

                }
                sandmap.players[0].hotrock = 0
            }
            //campaign played by AI
            // sandmap.players[0].clickrate = 1
            // sandmap.players[0].ai()
            // sandmap.players[1].aimode = -1
        }


        // if (keysPressed['l']) {
        //     endgame = 1
        // } else {
        //     endgame = 0
        // }
        if (keysPressed['R']) {
            return
        }
        // canvas_context.clearRect(0, 0, canvas.width, canvas.height)  // refreshes the image

        // uibox.draw()
        // map_context.clearRect(0, 0, map_canvas.width, map_canvas.height)  // refreshes the image
        if (endgame == 1) {
            if(score.drawn!= 1){

        uibox.draw()
                score.draw()
                score.drawn = 1
            }
        } else {

        canvas_context.clearRect(0, 0, canvas.width, canvas.height)  // refreshes the image

        uibox.draw()
        map_context.clearRect(0, 0, map_canvas.width, map_canvas.height)  // refreshes the image
            score.add()
            manageOddAudio()
            // // game code goes here
            dataflop = 0
            // sandmap.cleanDirty()

            // map_context.drawImage(sandmap.canvas, 0, 0, sandmap.canvas.width, sandmap.canvas.height, 0, 0, worldscale*10, worldscale*10)

            map_context.drawImage(snow, 0, 0, snow.width, snow.height, 0, 0, worldscale * 10, worldscale * 10)
            if (sandmap.backgroundcheck == 1) {
                sandmap.dirtAura()
            }
            map_context.drawImage(sandmap.canvas, 0, 0, sandmap.canvas.width, sandmap.canvas.height, 0, 0, worldscale * 10, worldscale * 10)
            map_context.drawImage(sandmap.hotrockCanvas, 0, 0, sandmap.canvas.width, sandmap.canvas.height, 0, 0, worldscale * 10, worldscale * 10)
            sandmap.hotrockCanvas_context.clearRect(0, 0, sandmap.hotrockCanvas.width, sandmap.hotrockCanvas.height)
            map_context.drawImage(sandmap.buildingCanvas, 0, 0, sandmap.canvas.width, sandmap.canvas.height, 0, 0, worldscale * 10, worldscale * 10)


            sandmap.draw()

            if (keysPressed[' ']) {
                sandmap.cameratrack = 1
            }
            if (keysPressed['z']) {
                sandmap.cameratrack = 0
            }

            if (sandmap.cameratrack == 1) {
                let wet = 0
                let hold = {}
                for (let t = 0; t < sandmap.players[sandmap.turn].units.length; t++) {
                    if (sandmap.players[sandmap.turn].units[t].selected == 1) {
                        wet++
                        hold = sandmap.players[sandmap.turn].units[t]
                    }
                }
                if (wet == 1) {
                    sandmap.window.guide.x = hold.body.x - (sandmap.window.body.width * .25)
                    sandmap.window.guide.y = hold.body.y - (sandmap.window.body.height * .25)

                    if (sandmap.window.guide.x < 0) {
                        sandmap.window.guide.x = 0
                    }
                    if (sandmap.window.guide.y < 0) {
                        sandmap.window.guide.y = 0
                    }
                    if (sandmap.window.guide.x > map_canvas.width - (sandmap.window.body.width * .5)) {
                        sandmap.window.guide.x = map_canvas.width - (sandmap.window.body.width * .5)
                    }
                    if (sandmap.window.guide.y > map_canvas.width - (sandmap.window.body.height * .5)) {
                        sandmap.window.guide.y = map_canvas.width - (sandmap.window.body.height * .5)
                    }
                } else if (wet >= 2) {
                    const dummy = {}
                    dummy.x = 0
                    dummy.y = 0
                    let count = 0
                    for (let t = 0; t < sandmap.players[sandmap.turn].units.length; t++) {
                        if (sandmap.players[sandmap.turn].units[t].selected == 1) {
                            dummy.x += sandmap.players[sandmap.turn].units[t].body.x
                            dummy.y += sandmap.players[sandmap.turn].units[t].body.y
                            count++
                        }
                    }
                    dummy.x /= count
                    dummy.y /= count
                    sandmap.window.guide.x = dummy.x - (sandmap.window.body.width * .25)
                    sandmap.window.guide.y = dummy.y - (sandmap.window.body.height * .25)

                    if (sandmap.window.guide.x < 0) {
                        sandmap.window.guide.x = 0
                    }
                    if (sandmap.window.guide.y < 0) {
                        sandmap.window.guide.y = 0
                    }
                    if (sandmap.window.guide.x > map_canvas.width - (sandmap.window.body.width * .5)) {
                        sandmap.window.guide.x = map_canvas.width - (sandmap.window.body.width * .5)
                    }
                    if (sandmap.window.guide.y > map_canvas.width - (sandmap.window.body.height * .5)) {
                        sandmap.window.guide.y = map_canvas.width - (sandmap.window.body.height * .5)
                    }
                }
            }
            if (keysPressed['H']) {
                sandmap.turn = 1
            }
            if (keysPressed['J']) {
                sandmap.turn = 2
            }
            if (keysPressed['G']) {
                sandmap.turn = 3
            }

            if (keysPressed['O']) {
                for (let t = 0; t < sandmap.players[sandmap.turn].units.length; t++) {
                    sandmap.players[sandmap.turn].units[t].health = -1000
                }
                for (let t = 0; t < sandmap.players[sandmap.turn].buildings.length; t++) {
                    sandmap.players[sandmap.turn].buildings[t].health = -1000
                }
                sandmap.players[sandmap.turn].hotrock = 0

            }
            if (keysPressed['K']) {
                sandmap.turn = 0
            }

            //testing
            // if (Math.abs(sandmap.players[0].units.length - sandmap.players[1].units.length) >= 45 || Math.abs(sandmap.players[0].units.length * sandmap.players[1].units.length) == 0) { //40
            //     start = 0
            //     if (sandmap.players[0].units.length > sandmap.players[1].units.length) {
            //         topside++
            //     } else {
            //         underdog++
            //     }
            //     //////////console.log(topside, underdog)
            //     sandmap = new Sandmap(CANVAS_WIDTH, CANVAS_HEIGHT, 0, 0, []);
            //     startGame()
            // }


            // if (keysPressed['q']) {
            //     //////////console.log(sandmap)
            // }
            //////////console.log(selectrect)

            let endmark = 0
            for(let t = 0;t<sandmap.players.length;t++){
                if(sandmap.players[t].units.length > 0){
                    endmark++
                }
            }


            if (endmark <= 1) {
                endbutton.draw()
                canvas_context.fillStyle = "white"
                canvas_context.font = "40px arial"
                canvas_context.fillText("End", endbutton.x + 15, endbutton.y + 52)
            }
        }


        textpainter.draw()

        // sandmap.window.seeGuide.draw()
    }
})
                    </script>
                </div id="go">
            </div>
            <!-- Right side banner. No content for now. Perhaps ad-space in the future. -->
            <aside class="gamepage-right-aside">
                <!-- Add content here later. --></aside>
        </div>
        <!-- Simple footer. Just a copyright notice. -->
        <footer class="games-footer"></footer>
    </div>
</html>
